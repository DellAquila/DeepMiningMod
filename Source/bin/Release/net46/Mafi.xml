<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Mafi</name>
    </assembly>
    <members>
        <member name="T:Mafi.ArrayPool`1">
            <summary>
            Pools for small arrays, currently up to size 255. Larger arrays are always allocated and never stored. For
            details see <see cref="T:Mafi.ObjectPool`1"/>.
            </summary>
        </member>
        <member name="M:Mafi.ArrayPool`1.Get(System.Int32)">
            <summary>
            Returns pooled array of requested size.
            </summary>
        </member>
        <member name="M:Mafi.ArrayPool`1.GetAndInit(`0)">
            <summary>
            Returns pooled array of length 1 with given item at index 0.
            </summary>
        </member>
        <member name="M:Mafi.ArrayPool`1.GetAndInit(`0,`0)">
            <summary>
            Returns pooled array of length 2 with given items at indices 0 and 1 respectively.
            </summary>
        </member>
        <member name="M:Mafi.ArrayPool`1.ReturnToPool(`0[])">
             <summary>
             Returns array to the pool. Please make sure than only arrays that are no longer in use are returned. The
             array being returned to pool should come from <see cref="T:Mafi.ArrayPool`1"/>, but not necessarily.
            
             TODO: This is slow because of Array.Clear and because of inefficient pool insertion. Improve this.
             </summary>
        </member>
        <member name="M:Mafi.ArraysPoolExtensions.ReturnToPool``1(``0[])">
            <summary>
            Returns this array to the pool. Please make sure than only arrays that are no longer in use are returned.
            </summary>
        </member>
        <member name="T:Mafi.ArrayPoolCustom`1">
            <summary>
            Custom non-static array pool for classes that need to pool arrays but don't need thread safety.
            </summary>
        </member>
        <member name="M:Mafi.ArrayPoolCustom`1.Get(System.Int32)">
            <summary>
            Returns pooled array of requested size.
            </summary>
        </member>
        <member name="T:Mafi.Assert">
             <summary>
             Debug-only assertions for ensuring that values are as expected. USE THIS EXTENSIVELY. Because those assertions
             are debug-only DO NOT rely on them. It's like little unit tests within methods where normal unit tests cannot
             reach.
            
             Primary use is for places where certain values should have certain value 100% and you wanted just to make sure.
            
             Consider usage of <see cref="T:Mafi.Log"/> class for logging of warnings or errors.
             </summary>
        </member>
        <member name="F:Mafi.Assert.ASSERT_CONDITIONAL">
            <summary>
            Assertions will be performed only when the project is compiled with this conditional.
            </summary>
            <remarks>
            We define this to be equal as Unity Assert condition because Unity keeps re-generating its project file and
            deleting our defined constants!
            </remarks>
        </member>
        <member name="F:Mafi.Assert.ENABLED">
            <summary>
            Whether asserts are currently enabled.
            </summary>
        </member>
        <member name="E:Mafi.Assert.AssertFired">
            <summary>
            Event that is fired when an assertion fails. Note that the handler have to be thread safe!
            </summary>
            <remarks>This event is internal to not be exposed to mods.</remarks>
        </member>
        <member name="E:Mafi.Assert.AssertFiredThreadStatic">
            <summary>
            Thread-static version of <see cref="E:Mafi.Assert.AssertFired"/> event. Useful in tests that run in parallel.
            </summary>
        </member>
        <member name="M:Mafi.Assert.That``1(``0)">
            <summary>
            Starts assertion about value of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Mafi.Assert.GetCleanStackTrace(System.Int32)">
            <summary>
            Cleans given stack trace or generates new stack trace if given stack trace is null.
            </summary>
        </member>
        <member name="T:Mafi.CheckExtensions">
            <summary>
            Helper extension methods for runtime checks.
            </summary>
        </member>
        <member name="M:Mafi.CheckExtensions.CheckNotNull``1(``0,System.String)">
            <summary>
            Returns given <paramref name="value"/> if it is not null. Throws <see cref="T:Mafi.CheckException"/> otherwise.
            </summary>
            <remarks>
            We prefer to throw the exception immediately to reduce possibility of missing it and then getting the <see
            cref="T:Mafi.CheckException"/> somewhere in the program possibly much later. And this is true for both DEBUG and
            RELEASE modes. Nulls are EVIL!
            </remarks>
            <example>
            Intended use of this class is in assignments:
            <code>
            public void SomeMethod(string str) {
            m_str = str.CheckNotNull(); // Instead of just `m_str = str;`
            }
            </code>
            </example>
        </member>
        <member name="M:Mafi.CheckExtensions.CheckNotNullOrEmpty(System.String)">
            <summary>
            Checks whether given string is not null or empty. If the check is positive the string is returned, otherwise
            <see cref="T:Mafi.CheckException"/> is thrown.
            </summary>
        </member>
        <member name="M:Mafi.CheckExtensions.CheckNonEmpty``1(``0[])">
            <summary>
            Returns given <paramref name="array"/> if it is not null or empty. Otherwise throws <see
            cref="T:Mafi.CheckException"/>.
            </summary>
        </member>
        <member name="M:Mafi.CheckExtensions.CheckNonEmptyOfNonNulls``1(``0[])">
            <summary>
            Returns given <paramref name="array"/> if it is not null or empty and all elements are not null. Otherwise
            throws <see cref="T:Mafi.CheckException"/>.
            </summary>
        </member>
        <member name="M:Mafi.CheckExtensions.CheckLength``1(``0[],System.Int32)">
            <summary>
            Checks whether given <paramref name="array"/> is not null and its length is greater or equal to <paramref
            name="minLength"/>. If the check is positive the array is returned, otherwise <see cref="T:Mafi.CheckException"/> is
            thrown.
            </summary>
        </member>
        <member name="M:Mafi.CheckExtensions.CheckNotEmpty``1(Mafi.Collections.ImmutableCollections.ImmutableArray{``0})">
            <summary>
            Returns given <paramref name="array"/> if it is not null or empty. Otherwise throws <see
            cref="T:Mafi.CheckException"/>.
            </summary>
        </member>
        <member name="M:Mafi.CheckExtensions.CheckLength``1(Mafi.Collections.ImmutableCollections.ImmutableArray{``0},System.Int32)">
            <summary>
            Checks whether given immutable <paramref name="array"/> is initialized (internal array non-null) and its
            length is greater or equal to <paramref name="minLength"/>. If the check is positive the array is returned,
            otherwise <see cref="T:Mafi.CheckException"/> is thrown.
            </summary>
        </member>
        <member name="M:Mafi.CheckExtensions.CheckNotDefaultStruct``1(``0)">
            <summary>
            Checks whether given struct is NOT equal to <c>default(T)</c>.
            </summary>
        </member>
        <member name="T:Mafi.BuildInfoData">
            <summary>
            Represents build data that stores details about how current assembly was built.
            </summary>
            <remarks>
            Here is an overview in which build configurations are defines set.
            <code>
            +------------------------------------------------------------------------------------------------------------+
            |                            |       |         | ReleaseNoAsserts |            |              | AlphaRelease |
            |                            | Debug | Release | NoTracing        | AlphaDebug | AlphaRelease | WithCheats   |
            |----------------------------+-------+---------+------------------+------------+--------------|--------------|
            |                      DEBUG |   X   |         |                  |     X      |              |              |
            |----------------------------+-------+---------+------------------+------------+--------------|--------------|
            |                   DEV_ONLY |   X   |    X    |       X          |            |              |              |
            |----------------------------+-------+---------+------------------+------------+--------------|--------------|
            |                 ALPHA_ONLY |       |         |                  |     X      |      X       |      X       |
            |----------------------------+-------+---------+------------------+------------+--------------|--------------|
            |             CHEATS_ENABLED |   X   |    X    |       X          |     X      |              |              |
            |----------------------------+-------+---------+------------------+------------+--------------|--------------|
            |             RELEASE_CHEATS |   X   |    X    |       X          |     X      |              |      X       |
            |----------------------------+-------+---------+------------------+------------+--------------|--------------|
            |            MAFI_ASSERTIONS |   X   |    X    |                  |     X      |      X       |      X       |
            |----------------------------+-------+---------+------------------+------------+--------------|--------------|
            | MAFI_ASSERTIONS_DEBUG_ONLY |   X   |         |                  |     X      |              |              |
            |----------------------------+-------+---------+------------------+------------+--------------|--------------|
            |               MAFI_TRACING |   X   |    X    |                  |     X      |              |              |
            |----------------------------+-------+---------+------------------+------------+--------------|--------------|
            |         MAFI_PERF_COUNTERS |   X   |         |                  |     X      |              |              |
            +---------------------------------------------------------------------------------------------+--------------+
            </code>
            </remarks>
        </member>
        <member name="T:Mafi.Collections.ArrayDataStorageSlim`1">
             <summary>
             Stores elements in array. Resulting array may have "holes" from removed elements with value of <c>default</c>.
             It guarantees that inserted elements index never changes and the internal array is never larger
             than the number of stored elements.
            
             This datastructure supports storing values of <c>default</c>.
            
             Default value of this struct is a valid empty array and it is ok to Add directly to it.
            
             Note that we store removed indices as <see cref="T:System.UInt16"/> in order to save memory.
             Thus, the total number of stored elements should NOT exceed <see cref="F:System.UInt16.MaxValue"/> (65k).
             </summary>
        </member>
        <member name="P:Mafi.Collections.ArrayDataStorageSlim`1.Count">
            <summary>
            Number of stored non-empty elements.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ArrayDataStorageSlim`1.HighestUsedCount">
            <summary>
            The highest count that has (or had) a valid item. Note that removing elements in random order will
            not decrease this value. You can use <see cref="M:Mafi.Collections.ArrayDataStorageSlim`1.RecomputeHighestUsedCount"/> to update this to the highest
            valid element.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ArrayDataStorageSlim`1.Item(System.Int32)">
            <summary>
            Indexer with unchecked array access (for performance).
            </summary>
        </member>
        <member name="M:Mafi.Collections.ArrayDataStorageSlim`1.Add(`0)">
            <summary>
            Adds an item and returns its index. This is O(1) operation (amortized).
            </summary>
        </member>
        <member name="M:Mafi.Collections.ArrayDataStorageSlim`1.UpdateAt(System.UInt16,`0)">
            <summary>
            Updates an existing item.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ArrayDataStorageSlim`1.Remove(System.UInt16)">
            <summary>
            Removes stored element at the given index and resets backing array value at that index to <c>default</c>.
            This is O(1) operation (amortized).
            </summary>
        </member>
        <member name="M:Mafi.Collections.ArrayDataStorageSlim`1.RecomputeHighestUsedCount">
            <summary>
            In case there were many elements removed from the end, recomputing <see cref="P:Mafi.Collections.ArrayDataStorageSlim`1.HighestUsedCount"/> might make
            it lower. This is O(n log n) operation where n is the number of empty indices lower than
            <see cref="P:Mafi.Collections.ArrayDataStorageSlim`1.HighestUsedCount"/>.
            </summary>
        </member>
        <member name="T:Mafi.Collections.BitHelper">
             <summary>
             Note: Duplicated because the one in System.Collections.Generic is internal.
            
            ABOUT:
             Helps with operations that rely on bit marking to indicate whether an item in the
             collection should be added, removed, visited already, etc.
            
             BitHelper doesn't allocate the array; you must pass in an array or ints allocated on the
             stack or heap. ToIntArrayLength() tells you the int array size you must allocate.
            
             USAGE:
             Suppose you need to represent a bit array of length (i.e. logical bit array length)
             BIT_ARRAY_LENGTH. Then this is the suggested way to instantiate BitHelper:
             ***************************************************************************
             int intArrayLength = BitHelper.ToIntArrayLength(BIT_ARRAY_LENGTH);
             BitHelper bitHelper;
             if (intArrayLength less than stack alloc threshold)
                 int* m_arrayPtr = stackalloc int[intArrayLength];
                 bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
             else
                 int[] m_arrayPtr = new int[intArrayLength];
                 bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
             ***************************************************************************
            
             IMPORTANT:
             The second ctor args, length, should be specified as the length of the int array, not
             the logical bit array. Because length is used for bounds checking into the int array,
             it's especially important to get this correct for the stackalloc version. See the code
             samples above; this is the value gotten from ToIntArrayLength().
            
             The length ctor argument is the only exception; for other methods -- MarkBit and
             IsMarked -- pass in values as indices into the logical bit array, and it will be mapped
             to the position within the array of ints.
            
             </summary>
        </member>
        <member name="M:Mafi.Collections.BitHelper.#ctor(System.Int32*,System.Int32)">
            <summary>
            Instantiates a BitHelper with a heap alloc'd array of ints
            </summary>
            <param name="bitArray">int array to hold bits</param>
            <param name="length">length of int array</param>
        </member>
        <member name="M:Mafi.Collections.BitHelper.#ctor(System.Int32[],System.Int32)">
            <summary>
            Instantiates a BitHelper with a heap alloc'd array of ints
            </summary>
            <param name="bitArray">int array to hold bits</param>
            <param name="length">length of int array</param>
        </member>
        <member name="M:Mafi.Collections.BitHelper.MarkBit(System.Int32)">
            <summary>
            Mark bit at specified position
            </summary>
            <param name="bitPosition"></param>
        </member>
        <member name="M:Mafi.Collections.BitHelper.IsMarked(System.Int32)">
            <summary>
            Is bit at specified position marked?
            </summary>
            <param name="bitPosition"></param>
            <returns></returns>
        </member>
        <member name="M:Mafi.Collections.BitHelper.ToIntArrayLength(System.Int32)">
            <summary>
            How many ints must be allocated to represent n bits. Returns (n+31)/32, but avoids overflow
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:Mafi.Collections.BitMap">
             <summary>
             Efficient bit storage.
            
             Note that this class is a struct to avoid an extra pointer hop.
             </summary>
        </member>
        <member name="M:Mafi.Collections.BitMap.InvertBit(System.Int32)">
            <summary>
            More efficient than setter since it does not use an if.
            </summary>
        </member>
        <member name="P:Mafi.Collections.CircularBuffer`1.Item(System.Int32)">
            <summary>
            Returns last added item.
            </summary>
        </member>
        <member name="T:Mafi.Collections.Dict`2">
             <summary>
             Key-value hash-based storage.
            
             Taken and adopted from MIT-licensed C# reference source.
            
             Changes:
             * Added a custom serializer.
             * Asserts instead of some Exceptions and Debug/Contract calls.
             * Removed support for a custom comparer since we have no good way to save it for now.
             * Removed not useful interfaces: IDictionary (non-generic - trash), IDictionary{TKey,TValue} (this one requires
             mutable `.Keys` and `.Values` collections which is nonsense), ISerializable, and IDeserializationCallback.
             * Removed not useful interfaces from enumerators: IDictionaryEnumerator
             * Removed not useful interfaces from Keys and Values collections: ICollection{TValue}, ICollection.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Dict`2.#ctor">
            <summary>
            Ctor for loading.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Dict`2.GetRefValue(`0,System.Boolean@)">
            <summary>
            Returns ref to an existing element or adds a default value and returns ref for it.
            This method is advantageous in situations when we'd need to do <c>read-mutate-write</c> operations on structs
            and avoids one extra lookup since we can do just <c>getref-mutate</c>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Dict`2.FirstOrDefault">
            <summary>
            An efficient way to get the first value without creating an enumerator. Returned value is identical to the
            first value returned by the enumerator.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Dict`2.SampleRandomKeyOrDefault(Mafi.IRandom)">
            <summary>
            Allocation-free sampling of random key in O(n).
            </summary>
        </member>
        <member name="M:Mafi.Collections.Dict`2.SampleRandomValueOrDefault(Mafi.IRandom)">
            <summary>
            Allocation-free sampling of random value in O(n).
            </summary>
        </member>
        <member name="M:Mafi.Collections.DictExtensions.IncOrInsert1``1(Mafi.Collections.Dict{``0,System.Int32},``0)">
            <summary>
            Increments value at given key or adds value 1. Returns the new value.
            Together with <see cref="M:Mafi.Collections.DictExtensions.DecAndRemoveAtZero``1(Mafi.Collections.Dict{``0,System.Int32},``0)"/> can be used for counting using dictionaries.
            </summary>
        </member>
        <member name="M:Mafi.Collections.DictExtensions.DecAndRemoveAtZero``1(Mafi.Collections.Dict{``0,System.Int32},``0)">
            <summary>
            Decrements value and removes key when 0 is reached. Asserts that key exist. Returns the new value.
            Together with <see cref="M:Mafi.Collections.DictExtensions.IncOrInsert1``1(Mafi.Collections.Dict{``0,System.Int32},``0)"/> can be used for counting using dictionaries.
            </summary>
        </member>
        <member name="M:Mafi.Collections.DictExtensions.GetOrAdd``2(Mafi.Collections.Dict{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            DANGER: Make sure you use static lambdas (those use only the key as a dynamic argument) otherwise you will cause
            allocations of lambdas for each call of this method no matter what.
            </summary>
        </member>
        <member name="T:Mafi.Collections.IDictNonGeneric">
            <summary>
            Interface that allows access to non-generic data of any dict. DO NOT use in perf critical context, all value
            types are boxed during enumeration.
            </summary>
        </member>
        <member name="F:Mafi.Collections.Heap`1.m_heap">
            <summary>
            Array that contains heap. This array is one-based for easier indexing and arithmetic. Element on index 0 is
            never used.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Heap`1.Count">
            <summary>
            Number of nodes in this queue.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Heap`1.Clear">
            <summary>
            Clears the contents of Heap.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Heap`1.GetElements">
            <summary>
            Returns currently stored elements as an array slice.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Heap`1.IsInValidState">
            <summary>
            Whether this heap is in valid state and all nodes satisfy the heap condition.
            </summary>
        </member>
        <member name="T:Mafi.Collections.HybridSet`1">
            <summary>
            Immutable set that is optimized for small number of items (0-10). It is also optimized for repeated queries of
            the same item.
            </summary>
        </member>
        <member name="M:Mafi.Collections.HybridSet`1.Add(`0[])">
            <summary>
            Creates a new HybridSet as a union of current and new items.
            </summary>
        </member>
        <member name="M:Mafi.Collections.HybridSet`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new HybridSet as a union of current and new items.
            </summary>
        </member>
        <member name="T:Mafi.Collections.HybridSet`1.HybridSetMany">
            <summary>
            Used to store items in the HashSet.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ImmutableCollections.IImmutableArray">
            <summary>
            An internal non-generic interface implemented by <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> that allows for recognition of
            an <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> instance and access to its underlying array, without actually knowing the type
            of value stored in it.
            </summary>
            <remarks>
            Casting to this interface requires a boxed instance of the <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> struct, and as such
            should be avoided. This interface is useful, however, where the value is already boxed and we want to try to
            reuse immutable arrays instead of copying them.
            ** This interface is INTENTIONALLY INTERNAL, as it gives access to the inner array. **
            </remarks>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.IImmutableArray.Array">
            <summary>
            Gets an untyped reference to the array.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ImmutableCollections.ImmutableArray">
            <summary>
            A set of initialization methods for instances of <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.Create``1(``0)">
            <summary>
            Creates an <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> with the specified element as its only member.
            </summary>
            <typeparam name="T">The type of element stored in the array.</typeparam>
            <param name="item">The element to store in the array.</param>
            <returns>A 1-element array.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.Create``1(``0,``0)">
            <summary>
            Creates an <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> with the specified elements.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.Create``1(``0,``0,``0)">
            <summary>
            Creates an <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> with the specified elements.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.Create``1(``0,``0,``0,``0)">
            <summary>
            Creates an <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> with the specified elements.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> populated with the contents of the specified sequence.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.CreateRange``1(Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice{``0})">
            <summary>
            Creates an <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> populated with the contents of the specified sequence.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.Create``1(``0[])">
            <summary>
            Creates an <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> from given items.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.Create``1(``0[][])">
            <summary>
            Creates 2D <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> from given 2D array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.ToImmutableArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enumerates a sequence exactly once and produces an immutable array of its contents.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.ToImmutableArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates an immutable array from given collection.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.ToImmutableArray``2(System.Collections.Generic.IReadOnlyCollection{``0},System.Func{``0,``1})">
            <summary>
            Creates an immutable array from given read-only collection.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.ToImmutableArrayAndClear``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates an immutable array from given collection and clears the collection.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.CreateDefensiveCopy``1(``0[])">
            <summary>
            Initializes a new instance of the <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> struct.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray.CreateGeneric(System.Type,Mafi.Collections.ReadonlyCollections.IIndexable{System.Object})">
            <summary>
            Creates generic <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> with given types and values. It does create a defensive copy
            of values. It is callers responsibility to ensure that all given values can be assigned to the <paramref
            name="type"/>.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ImmutableCollections.ImmutableArray.EmptyArray">
            <summary>
            Allows tp type <c>ImmutableArray.Empty</c> instead of <c>ImmutableArray{T}.Empty</c>. This can in some cases
            improve readability of the code if <c>T</c> is very long.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ImmutableCollections.ImmutableArrayBuilder`1">
             <summary>
             Provides efficient copy-free construction of <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> when we know its size beforehand.
             </summary>
             <remarks>This is a struct to prevent unnecessary allocations.</remarks>
             <example>
             Intended use:
             <code>
             var builder = new ImmutableArrayBuilder&lt;int&gt;(count);
            
             for (...) {
             	builder[i] = ...;
             }
            
             return builder.GetImmutableArrayAndClear();
             </code>
             </example>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArrayBuilder`1.#ctor(System.Int32)">
            <summary>
            Creates new empty array of given size
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArrayBuilder`1.Item(System.Int32)">
            <summary>
            Gets or sets element on given index.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArrayBuilder`1.IsNotValid">
            <summary>
            Whether this struct has <c>null</c> as an array instance. We should never need to explicitly check this
            property in normal program flow. It is exposed only for asserts and tests. While ctor does not allow
            construction with null array it may happen when <c>default( <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArrayBuilder`1"/>)</c> is
            used.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArrayBuilder`1.GetImmutableArrayAndClear">
            <summary>
            Creates immutable array from the internal array and clear the builder. No further methods can be called on
            this builder.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1">
             <summary>
             An immutable array with O(1) indexable lookup time. It is guaranteed that length and elements of the underlying
             array will be not changed. However, if this array stores mutable objects they can be changed.
             </summary>
             <typeparam name="T">The type of element stored by the array.</typeparam>
             <devremarks>
             This type has a documented contract of being exactly one reference-type field in size.
            
             IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS: This type should be thread-safe. As a struct, it cannot protect
             its own fields from being changed from one thread while its members are executing on other threads because
             structs can change *in place* simply by reassigning the field containing this struct. Therefore it is extremely
             important that ** Every member should only dereference <c>this</c> ONCE. ** If a member needs to reference the
             array field, that counts as a dereference of <c>this</c>. Calling other instance members (properties or methods)
             also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more than once must instead
             assign <c>this</c> to a local variable and use that for the rest of the code instead. This effectively copies the
             one field in the struct to a local variable so that it is insulated from other threads.
             </devremarks>
        </member>
        <member name="F:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Empty">
            <summary>
            An empty (initialized) instance of <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/>.
            </summary>
        </member>
        <member name="F:Mafi.Collections.ImmutableCollections.ImmutableArray`1.m_items">
            <summary>
            The backing field for this instance. References to this value should never be shared with outside code.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> struct *without making a defensive copy*.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index in the read-only list.
            </summary>
            <remarks>
            We intentionally do not check this.array != null, and throw NullReferenceException if this is called while
            uninitialized. The reason for this is perf. Length and the indexer must be absolutely trivially implemented
            for the JIT optimization of removing array bounds checking to work.
            </remarks>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Item(Mafi.IRandom)">
            <summary>
            Gets random element.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Length">
            <summary>
            Gets the length of array in the collection.
            </summary>
            <remarks>
            We intentionally do not check this.array != null, and throw NullReferenceException if this is called while
            uninitialized. The reason for this is perf. Length and the indexer must be absolutely trivially implemented
            for the JIT optimization of removing array bounds checking to work.
            </remarks>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.LastIndex">
            <summary>
            Index of the last element.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.IsEmpty">
            <summary>
            Whether this array is empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.IsNotEmpty">
            <summary>
            Whether this array is NOT empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.First">
            <summary>
            Gets the first element of the array. Throws exception if the array is null or empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Second">
            <summary>
            Gets the second element of the array. Throws exception if the array is null or length is not greater than
            one.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Last">
            <summary>
            Gets the last element of the array. Throws exception if the array is null or empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.PreLast">
            <summary>
            Gets the element before the last element of the array. Throws exception if the array is null or length is not
            greater than one.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.AsReadOnlyArray">
            <summary>
            Returns this array as readonly array. This weakens the guarantees but it is safe as it is impossible to
            mutate the underlying array from <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/>.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.AsIndexable">
            <summary>
            Returns this array as indexable. This creates a new class instance to prevent boxing.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.IsValid">
            <summary>
            Whether this structs is valid and underlying array is not null. This should be always the case except when
            <c>default( <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/>)</c> is used or new array of <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> is
            created.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Mafi#Collections#ImmutableCollections#IImmutableArray#Array">
            <summary>
            Gets an untyped boxed reference to the array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.op_Equality(Mafi.Collections.ImmutableCollections.ImmutableArray{`0},Mafi.Collections.ImmutableCollections.ImmutableArray{`0})">
            <summary>
            Checks equality between two instances based on the internal array. Does NOT compare elements!
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.op_Inequality(Mafi.Collections.ImmutableCollections.ImmutableArray{`0},Mafi.Collections.ImmutableCollections.ImmutableArray{`0})">
            <summary>
            Checks inequality between two instances based on the internal array. Does NOT compare elements!
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.op_Equality(System.Nullable{Mafi.Collections.ImmutableCollections.ImmutableArray{`0}},System.Nullable{Mafi.Collections.ImmutableCollections.ImmutableArray{`0}})">
            <summary>
            Checks equality between two instances based on the internal array. Does NOT compare elements!
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.op_Inequality(System.Nullable{Mafi.Collections.ImmutableCollections.ImmutableArray{`0}},System.Nullable{Mafi.Collections.ImmutableCollections.ImmutableArray{`0}})">
            <summary>
            Checks inequality between two instances based on the internal array. Does NOT compare elements!
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.IndexOf(`0)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.IndexOf(`0,System.Int32)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.LastIndexOf(`0)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Contains(`0)">
            <summary>
            Determines whether the specified item exists in the array.
            </summary>
            <param name="item">The item to search for.</param>
            <returns><c>true</c> if an equal value was found in the array; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.ToArray">
            <summary>
            Returns a copy of this immutable array as plain mutable array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.ToArray``1(System.Func{`0,``0})">
            <summary>
            Returns a copy of this array mapped with given <paramref name="selector"/> function.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the contents of this array to the specified array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Insert(System.Int32,`0)">
            <summary>
            Returns a new array with the specified value inserted at the specified position.
            </summary>
            <param name="index">The 0-based index into the array at which the new item should be added.</param>
            <param name="item">The item to insert at the start of the array.</param>
            <returns>A new array.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts the specified values at the specified index.
            </summary>
            <param name="index">The index at which to insert the value.</param>
            <param name="items">The elements to insert.</param>
            <returns>The new immutable collection.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.InsertRange(System.Int32,Mafi.Collections.ImmutableCollections.ImmutableArray{`0})">
            <summary>
            Inserts the specified values at the specified index.
            </summary>
            <param name="index">The index at which to insert the value.</param>
            <param name="items">The elements to insert.</param>
            <returns>The new immutable collection.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Add(`0)">
            <summary>
            Returns a new array with the specified value inserted at the end.
            </summary>
            <param name="item">The item to insert at the end of the array.</param>
            <returns>A new array.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the specified values to this list.
            </summary>
            <param name="items">The values to add.</param>
            <returns>A new list with the elements added.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.SetItem(System.Int32,`0)">
            <summary>
            Returns an array with the item at the specified position replaced.
            </summary>
            <param name="index">The index of the item to replace.</param>
            <param name="item">The new item.</param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.RemoveAt(System.Int32)">
            <summary>
            Returns an array with the element at the specified position removed.
            </summary>
            <param name="index">The 0-based index into the array for the element to omit from the returned array.</param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Returns an array with the elements at the specified position removed.
            </summary>
            <param name="index">The 0-based index into the array for the element to omit from the returned array.</param>
            <param name="length">The number of elements to remove.</param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.RemoveRangeAndAdd(System.Int32,System.Int32,`0)">
            <summary>
            Returns an array with the elements at the specified position removed and <paramref name="value"/> added
            instead of them. See <see cref="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.RemoveRange(System.Int32,System.Int32)"/> for more information.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all the elements that match the conditions defined by the specified predicate.
            Returns self if no elements were removed.
            </summary>
            <param name="match">
            The <see cref="T:System.Predicate`1"/> delegate that defines the conditions of the elements to remove.
            </param>
            <returns>The new list.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.RemoveAll``1(``0,System.Func{`0,``0,System.Boolean})">
            <summary>
            Similar to <see cref="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.RemoveAll(System.Predicate{`0})"/> but with extra argument passed to the predicate to avoid allocations.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.GetIndices(System.Predicate{`0})">
            <summary>
            Returns indices of values that matched with the given predicate.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Returns a sorted instance of this array. Returns self if it is already sorted.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Returns a sorted instance of this array. Returns self if it is already sorted.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Sort(System.Comparison{`0})">
            <summary>
            Returns a sorted instance of this array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.BinarySearch(`0)">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> for a specific element, using the
            <see cref="T:System.IComparable`1"/> generic interface implemented by each element of the <see
            cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> and by the specified object.
            </summary>
            <param name="value">The object to search for.</param>
            <returns>
            The index of the specified <paramref name="value"/> in the specified array, if <paramref name="value"/> is
            found. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more
            elements in array, a negative number which is the bitwise complement of the index of the first element that
            is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref
            name="value"/> is greater than any of the elements in array, a negative number which is the bitwise
            complement of (the index of the last element plus 1).
            </returns>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="value"/> does not implement the <see cref="T:System.IComparable`1"/> generic interface, and the
            search encounters an element that does not implement the <see cref="T:System.IComparable`1"/> generic interface.
            </exception>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.GetEnumerator">
            <summary>
            Returns an enumerator for the contents of the array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Equals(Mafi.Collections.ImmutableCollections.ImmutableArray{`0})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.ValuesEquals(Mafi.Collections.ImmutableCollections.ImmutableArray{`0})">
            <summary>
            Whether all values of this and given array are equal according to the default equality.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.CastUp``1(Mafi.Collections.ImmutableCollections.ImmutableArray{``0})">
            <summary>
            Initializes a new instance of the <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> struct based on the contents of an existing
            instance, allowing a covariant static cast to efficiently reuse the existing array.
            </summary>
            <param name="items">The array to initialize the array with. No copy is made.</param>
            <remarks>
            Covariant up-casts from this method may be reversed by calling the <see cref="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.As``1"/>
            or <see cref="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.CastArray``1"/> method.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.CastArray``1">
            <summary>
            Initializes a new instance of the <see cref="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1"/> struct by casting the underlying array to
            an array of type <typeparam name="TOther"/> .
            </summary>
            <exception cref="T:System.InvalidCastException">Thrown if the cast is illegal.</exception>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.As``1">
            <summary>
            Creates an immutable array for this array, cast to a different element type.
            </summary>
            <typeparam name="TOther">The type of array element to return.</typeparam>
            <returns>
            A struct typed for the base element type. If the cast fails, an instance is returned whose <see
            cref="P:Mafi.Collections.ImmutableCollections.ImmutableArray`1.IsValid"/> property returns <c>false</c>.
            </returns>
            <remarks>
            Arrays of derived elements types can be cast to arrays of base element types without reallocating the array.
            These up-casts can be reversed via this same method, casting an array of base element types to their derived
            types. However, down-casting is only successful when it reverses a prior up-casting operation.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.OfType``1">
            <summary>
            Filters the elements of this array to those assignable to the specified type. If you need just a cast use
            <see cref="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.CastArray``1"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Reversed">
            <summary>
            Returns new array that is reversed.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Concat(Mafi.Collections.ImmutableCollections.ImmutableArray{`0})">
            <summary>
            Returns new array that is concatenation of this and given arrays.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Concat(Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice{`0})">
            <summary>
            Returns new array that is concatenation of this and given arrays.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.AsEnumerable">
            <summary>
            Returns this array as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.FirstOrDefault(System.Func{`0,System.Boolean})">
            <summary>
            Returns the first element of the sequence that satisfies a condition or a default value if no such element is
            found.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Single(System.Func{`0,System.Boolean})">
            <summary>
            Returns the only element of a sequence that satisfies a specified condition, and throws an exception if more
            than one such element exists.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Skip(System.Int32)">
            <summary>
            Bypasses a specified number of elements in a sequence and then returns the remaining elements.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Map``1(System.Func{`0,``0})">
            <summary>
            Maps this immutable array using given function. This operation is not lazy like LINQ methods but is very
            efficient.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.MapArray``1(System.Func{`0,``0})">
            <summary>
            Maps this immutable array using given function. This operation is not lazy like LINQ methods but is very
            efficient.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.ForEach(System.Action{`0})">
            <summary>
            Calls given action on all elements of this array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Select``1(System.Func{`0,``0})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.SelectValues``1(System.Func{`0,Mafi.Option{``0}})">
            <summary>
            Selects all non-None values.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.SelectMany``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Where(System.Func{`0,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.All(System.Func{`0,System.Boolean})">
            <summary>
            Determines whether all elements of a sequence satisfy given predicate (without allocations).
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Any(System.Func{`0,System.Boolean})">
            <summary>
            Determines whether any element of a sequence satisfy given predicate (without allocations).
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Aggregate(System.Func{`0,`0,`0})">
            <summary>
            Applies an accumulator function over a sequence.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Sorts the elements of a sequence in ascending order according to a key.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.removeAtRange(System.Collections.Generic.ICollection{System.Int32})">
            <summary>
            Returns an array with items at the specified indexes removed.
            </summary>
            <param name="indexesToRemove">
            A **sorted set** of indexes to elements that should be omitted from the returned array.
            </param>
            <returns>The new array.</returns>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArray`1.op_Implicit(Mafi.Collections.ImmutableCollections.ImmutableArray.EmptyArray)~Mafi.Collections.ImmutableCollections.ImmutableArray{`0}">
            <summary>
            Allows tp type <c>ImmutableArray.Empty</c> instead of <c>ImmutableArray{T}.Empty</c>. This can in some cases
            improve readability of the code if <c>T</c> is very long.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ImmutableCollections.ImmutableArray`1.Enumerator">
            <summary>
            An array enumerator.
            </summary>
            <remarks>
            It is important that this enumerator does NOT implement <see cref="T:System.IDisposable"/>. We want the iterator to
            inline when we do foreach and to not result in a try/finally frame in the client.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.ImmutableArrayExtensions.LastOrNone``1(Mafi.Collections.ImmutableCollections.ImmutableArray{``0})">
            <summary>
            Returns last element or <see cref="F:Mafi.Option`1.None"/> if the array is empty.
            </summary>
            <remarks>
            This needs to be an extension method because we need to make sure that the generic argument is a class.
            </remarks>
        </member>
        <member name="T:Mafi.Collections.ImmutableCollections.SmallImmutableArray`1">
            <summary>
            Immutable container optimized for having a single element without need for any allocations.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.SmallImmutableArray`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the contents of this array to the specified array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.SmallImmutableArray`1.Map``1(System.Func{`0,``0})">
            <summary>
            Maps this immutable array using given function. This operation is not lazy like LINQ methods but is very
            efficient.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.SmallImmutableArray`1.IndexOf(`0)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="T:Mafi.Collections.ImmutableCollections.SmallImmutableArray`1.Enumerator">
            <summary>
            Enumerator specific for this container.
            </summary>
            <remarks>
            It is important that this enumerator does NOT implement <see cref="T:System.IDisposable"/>. We want the iterator to
            inline when we do foreach and to not result in a try/finally frame in the client.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.ImmutableCollections.SmallImmutableArrayBuilder`1.GetImmutableArrayAndClear">
            <summary>
            Creates immutable array from the internal array and clear the builder. No further methods can be called on
            this builder.
            </summary>
        </member>
        <member name="M:Mafi.Collections.IReadSwapLyst`1.ForEach(System.Action{`0})">
            <summary>
            Performs given action on every item in the read list.
            </summary>
        </member>
        <member name="T:Mafi.Collections.LystMutableDuringIter`1">
            <summary>
            A simple dynamic list that can be mutated during iteration. New members added during iteration will not be
            iterated over and removed items that were not yet processed will be skipped.
            </summary>
        </member>
        <member name="P:Mafi.Collections.LystMutableDuringIter`1.Item(System.Int32)">
            <summary>
            Gets or sets an element at given index. Ongoing enumeration will see results of setting a new element.
            </summary>
        </member>
        <member name="M:Mafi.Collections.LystMutableDuringIter`1.Clear">
            <summary>
            Clears the contents of List.
            </summary>
        </member>
        <member name="T:Mafi.Collections.LystStruct`1">
             <summary>
             Version of <see cref="T:Mafi.Collections.Lyst`1"/> that is struct.
             It should be used for private lists that do not need to be passed around as references.
             WARNING: This is mutable struct, be careful to mutate the right copy.
            
             It has following advantages:
             * Saves one object and a pointer-hop on every access.
             * Is equivalent of array (8 B) and size (4 B) in memory (it needs 8 B alignment though). Extra 4 B are added in debug mode for version checking.
            
             However, there are also some disadvantages:
             * Cannot be passed via interfaces like <see cref="T:Mafi.Collections.ReadonlyCollections.IIndexable`1"/> to avoid boxing.
             * Mutable struct has always dangers of mutating a copy instead of the stored value.
             * No version checking during enumeration.
             </summary>
        </member>
        <member name="F:Mafi.Collections.LystStruct`1.DEFAULT_CAPACITY">
            <summary>
            Default capacity when the first item is added to an empty list.
            </summary>
        </member>
        <member name="F:Mafi.Collections.LystStruct`1.m_items">
            <summary>
            Storage for the items.
            </summary>
        </member>
        <member name="P:Mafi.Collections.LystStruct`1.Count">
            <summary>
            Number of currently stored items.
            </summary>
        </member>
        <member name="P:Mafi.Collections.LystStruct`1.Item(System.Int32)">
            <summary>
            Indexer with unchecked array access (for performance).
            </summary>
        </member>
        <member name="P:Mafi.Collections.LystStruct`1.First">
            <summary>
            Gets or sets the first element at index 0.
            </summary>
        </member>
        <member name="P:Mafi.Collections.LystStruct`1.Last">
            <summary>
            Gets or sets the last element at index <c>Count - 1</c>.
            If the list is empty the <see cref="T:System.IndexOutOfRangeException"/> will be thrown.
            </summary>
        </member>
        <member name="M:Mafi.Collections.LystStruct`1.AddIfNotPresent(`0)">
            <summary>
            Adds item to the list if it is not already present. This is O(n) operation.
            </summary>
            <returns>True if given item was added, false when it is already in the list.</returns>
        </member>
        <member name="M:Mafi.Collections.LystStruct`1.IndexOf(`0)">
             <summary>
             Returns the index of the first occurrence of a given value in a range of this list. The list is searched
             forwards from beginning to end. The elements of the list are compared to the given value using the
             Object.Equals method.
            
             This method uses the Array.IndexOf method to perform the search.
             </summary>
        </member>
        <member name="M:Mafi.Collections.LystStruct`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the given index. The size of the list is decreased by one. This is O(n) operation.
            </summary>
        </member>
        <member name="M:Mafi.Collections.LystStruct`1.Remove(`0)">
            <summary>
            Tries to remove given element from the list and returns true if the element was removed. Otherwise, returns
            false and the collection was not changed.
            </summary>
        </member>
        <member name="M:Mafi.Collections.LystStruct`1.FreeUpBackingArrayIfEmpty">
            <summary>
            Useful when this array is used rarely and keeping it in memory is more expensive than allocating it again.
            </summary>
        </member>
        <member name="F:Mafi.Collections.Lyst`1.DEFAULT_CAPACITY">
            <summary>
            Default capacity when the first item is added to an empty list.
            </summary>
        </member>
        <member name="F:Mafi.Collections.Lyst`1.m_items">
            <summary>
            Storage for the items.
            </summary>
        </member>
        <member name="F:Mafi.Collections.Lyst`1.m_size">
            <summary>
            Number of currently stored items.
            </summary>
        </member>
        <member name="F:Mafi.Collections.Lyst`1.m_canOmitClearing">
            <summary>
            Whether zeroing-out of the array can be omitted.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.#ctor">
            <summary>
            Constructs a new List. The list is initially empty and has a capacity of zero. Upon adding the first element
            to the list the capacity is increased to 4, and then increased in multiples of two as required.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.#ctor(System.Boolean)">
            <param name="canOmitClearing">
            Whether this list can omit clearing of internal array when <see cref="M:Mafi.Collections.Lyst`1.Clear"/> is called or items are removed
            from the list. If this is set to true please keep in mind that any references inserted into the list may be
            referenced until this list is referenced and prevent them from being garbage collected.
            </param>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs a List with a given initial <paramref name="capacity"/>. The list is initially empty, but will
            have room for the given number of elements before any reallocations are required.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs a new List that contains all the elements in given sequence.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.Capacity">
            <summary>
            Gets or sets the capacity of this list. The capacity is the size of the internal array used to hold items.
            When set, the internal array of the list is reallocated to the given capacity.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.Count">
            <summary>
            Gets or sets number of stored elements.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.IsEmpty">
            <summary>
            Returns whether this Lyst is empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.IsNotEmpty">
            <summary>
            Returns whether this Lyst is NOT empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.First">
            <summary>
            Gets or sets the first element at index 0 of this Lyst.
            It is callers responsibility to check whether this Lyst is not empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.Last">
            <summary>
            Gets or sets the last element at index <c>Count - 1</c> of this Lyst.
            It is callers responsibility to check whether this Lyst is not empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.PreLast">
            <summary>
            Returns second to the last element at index <c>Count - 2</c> of this Lyst. It is callers responsibility to
            check whether this Lyst is not empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the given index.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.Item(Mafi.IRandom)">
            <summary>
            Gets or sets random element.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Lyst`1.BackingArrayAsSlice">
            <summary>
            Returns slice from the internal backing array. Be extremely careful as any changes to the list may also
            propagate to the returned array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Add(`0)">
            <summary>
            Adds the given object to the end of this list. The size of the list is increased by one. If required, the
            capacity of the list is doubled before adding the new element.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Add(`0,`0)">
            <summary>
            Adds two items to the en of this list. TODO: Rename to AddRange. This overload can cause subtle bugs.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Add(`0,`0,`0)">
            <summary>
            Adds three items to the en of this list.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Add(`0,`0,`0,`0)">
            <summary>
            Adds four items to the en of this list.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddIfNotPresent(`0)">
            <summary>
            Adds item to the list if it is not already present. This is O(n) operation.
            </summary>
            <returns>True if given item was added, false when it is already in the list.</returns>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements of the given collection to the end of this list. If required, the capacity of the list is
            increased to twice the previous capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddRange(`0[])">
            <summary>
            Adds the elements of the given array to the end of this list. If required, the capacity of the list is
            increased to twice the previous capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddRange(Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice{`0})">
            <summary>
            Adds the elements of the given array to the end of this list. If required, the capacity of the list is
            increased to twice the previous capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddRange(Mafi.Collections.ImmutableCollections.ImmutableArray{`0})">
            <summary>
            Adds the elements of the given array to the end of this list. If required, the capacity of the list is
            increased to twice the previous capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddRange(Mafi.Collections.ImmutableCollections.SmallImmutableArray{`0})">
            <summary>
            <see cref="M:Mafi.Collections.Lyst`1.AddRange(Mafi.Collections.ImmutableCollections.ImmutableArray{`0})"/>
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddRange(Mafi.Collections.Lyst{`0})">
            <summary>
            Adds the elements of the given list to the end of this list. If required, the capacity of the list is
            increased to twice the previous capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddRange(System.Collections.Generic.IList{`0})">
            <summary>
            Adds the elements of the given list to the end of this list. If required, the capacity of the list is
            increased to twice the previous capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddRange(Mafi.Collections.ReadonlyCollections.IIndexable{`0})">
            <summary>
            Adds the elements of the given indexable to the end of this list. If required, the capacity of the list is
            increased to twice the previous capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.AddRepeated(`0,System.Int32)">
            <summary>
            Adds given <paramref name="item"/> to the list <paramref name="count"/> times.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
             <summary>
             Searches a section of the list for a given element using a binary search algorithm. Elements of the list are
             compared to the search value using the given IComparer interface. If comparer is null, elements of the list
             are compared to the search value using the IComparable interface, which in that case must be implemented by
             all elements of the list and the given search value. This method assumes that the given section of the list
             is already sorted; if this is not the case, the result will be incorrect.
            
             The method returns the index of the given value in the list. If the list does not contain the given value,
             the method returns a negative integer. The bitwise complement operator (~) can be applied to a negative
             result to produce the index of the first element (if any) that is larger than the given search value. This is
             also the index at which the search value should be inserted into the list in order for the list to remain
             sorted.
            
             Note that if there are repeated elements, index of any element from the repeated sequence is returned.
            
             The method uses the Array.BinarySearch method to perform the search.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Clear">
            <summary>
            Clears the contents of List.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the capacity of this list is at least the given minimum value. If the current capacity of the
            list is less than min, the capacity is increased to twice the current capacity or to min, whichever is
            larger.
            </summary>
            <remarks>
            This method is intentionally split to two which allows in-lining of the fast and common scenario when no
            extension is needed. This also allows to perform the extension of the capacity directly when we already know
            that it is needed.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Contains(`0)">
            <summary>
            Contains returns true if the specified element is in the List. It does a linear, O(n) search. Equality is
            determined by calling item.Equals().
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Exists(System.Predicate{`0})">
            <summary>
            Whether given predicate returns true on any item in the list. Returns false if the list is empty.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.FindIndex``1(``0,System.Func{`0,``0,System.Boolean})">
            <summary>
            Overload with an extra parameter that can be used in the <paramref name="match"/> function
            to avoid allocating lambda.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.ForEach(System.Action{`0})">
            <summary>
            Calls given action on every element.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.ForEach``1(System.Func{`0,``0})">
            <summary>
            Calls function on every element and ignores its return value.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.ForEachAndClear(System.Action{`0})">
            <summary>
            Calls given action on every element and clears the list.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.ForEachAndClear``1(System.Func{`0,``0})">
            <summary>
            Calls given action on every element while ignoring return value from the function. Clears the list after the
            iteration.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.IndexOf(`0)">
             <summary>
             Returns the index of the first occurrence of a given value in a range of this list. The list is searched
             forwards from beginning to end. The elements of the list are compared to the given value using the
             Object.Equals method.
            
             This method uses the Array.IndexOf method to perform the search.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.IndexOf(`0,System.Int32)">
             <summary>
             Returns the index of the first occurrence of a given value in a range of this list. The list is searched
             forwards, starting at index and ending at count number of elements. The elements of the list are compared to
             the given value using the Object.Equals method.
            
             This method uses the Array.IndexOf method to perform the search.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.IndexOf(`0,System.Int32,System.Int32)">
             <summary>
             Returns the index of the first occurrence of a given value in a range of this list. The list is searched
             forwards, starting at index and up to count number of elements. The elements of the list are compared to the
             given value using the Object.Equals method.
            
             This method uses the Array.IndexOf method to perform the search.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element into this list at a given index. The size of the list is increased by one. If required,
            the capacity of the list is doubled before inserting the new element.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.LastIndexOf(`0)">
             <summary>
             Returns the index of the last occurrence of a given value in a range of this list. The list is searched
             backwards, starting at the end and ending at the first element in the list. The elements of the list are
             compared to the given value using the Object.Equals method.
            
             This method uses the Array.LastIndexOf method to perform the search.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.LastIndexOf(`0,System.Int32)">
             <summary>
             Returns the index of the last occurrence of a given value in a range of this list. The list is searched
             backwards, starting at index and ending at the first element in the list. The elements of the list are
             compared to the given value using the Object.Equals method.
            
             This method uses the Array.LastIndexOf method to perform the search.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.LastIndexOf(`0,System.Int32,System.Int32)">
             <summary>
             Returns the index of the last occurrence of a given value in a range of this list. The list is searched
             backwards, starting at index and up to count elements. The elements of the list are compared to the given
             value using the Object.Equals method.
            
             This method uses the Array.LastIndexOf method to perform the search.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.MoveToStart(System.Int32)">
            <summary>
            Moves item at given index to the start and shuffles all the items in between keeping their order.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Remove(`0)">
            <summary>
            Tries to remove given element from the list and returns true if the element was removed. Otherwise, returns
            false and the collection was not changed.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.RemoveAll(System.Predicate{`0})">
            <summary>
            This method removes all items which matches the predicate. The complexity is O(n).
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.RemoveFirst(System.Predicate{`0})">
            <summary>
            This method removes the first item which matches the predicate. The complexity is O(n).
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the given index. The size of the list is decreased by one. This is O(n) operation. If
            order of the items is not significant consider using more efficient <see cref="M:Mafi.Collections.Lyst`1.RemoveAtReplaceWithLast(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.RemoveAtReplaceWithLast(System.Int32)">
            <summary>
            Removes the element at the given index and replaces it with the last item. The size of the list is decreased
            by one. This is O(1) operation.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.TryRemoveReplaceLast(`0)">
            <summary>
            Tries to remove given element. Returns whether the element was removed. If removed, its place is replaced
            with the last item. This is more efficient that <see cref="M:Mafi.Collections.Lyst`1.Remove(`0)"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.PopLast">
            <summary>
            Returns and removes last item. This is O(1) operation.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes a range of elements from this list.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.RemoveWhere(System.Predicate{`0})">
            <summary>
            Removes all items for which given predicate is true. Order of remaining elements is preserved.
            Returns the number of removed elements.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.RemoveWhere``1(``0,System.Func{`0,``0,System.Boolean})">
            <summary>
            Similar to <see cref="M:Mafi.Collections.Lyst`1.RemoveWhere(System.Predicate{`0})"/> but also allows passing a value to the predicate
            to avoid allocations.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Reverse">
            <summary>
            Reverses all elements in this list.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the elements in a range of this list. Following a call to this method, an element in the range given
            by index and count which was previously located at index i will now be located at index index + (index
            + count - i - 1).
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Sort">
            <summary>
            Sorts the elements in this list. Uses the default comparer and Array.Sort.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in this list. Uses Array.Sort with the provided comparer.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
             <summary>
             Sorts the elements in a section of this list. The sort compares the elements to each other using the given
             IComparer interface. If comparer is null, the elements are compared to each other using the IComparable
             interface, which in that case must be implemented by all elements of the list.
            
             This method uses the Array.Sort method to sort the elements.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.SwapDataWith(Mafi.Collections.Lyst{`0})">
            <summary>
            Swaps internal data and size with other Lyst. This is handy when swapping whole references of lysts is not
            possible.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.ToArray(System.Int32)">
            <summary>
            Returns an array containing the contents of the List. This requires copying the List, which is an O(n)
            operation.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.ToArrayAndClear">
            <summary>
            Returns an array containing the contents of the List. This requires copying the List, which is an O(n)
            operation. If the Lyst is full ( <see cref="P:Mafi.Collections.Lyst`1.Count"/> == <see cref="P:Mafi.Collections.Lyst`1.Capacity"/>) then this operation is O(1)
            and does not involve any copying.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.ToLyst``1(System.Func{`0,``0})">
            <summary>
            Maps this list using given function. This operation is not lazy like LINQ methods but is more efficient.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.TrimExcess">
             <summary>
             Sets the capacity of this list to the size of the list. This method can be used to minimize a list's memory
             overhead once it is known that no new elements will be added to the list. To completely clear a list and
             release all memory referenced by the list, execute the following statements:
            
             list.Clear(); list.TrimExcess();
             </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.ToImmutableArray">
            <summary>
            Returns immutable array representation of this lyst by making a copy.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Lyst`1.ToImmutableArrayAndClear">
            <summary>
            Returns immutable array representation and clears this Lyst. If the Lyst is full ( <see cref="P:Mafi.Collections.Lyst`1.Count"/> ==
            <see cref="P:Mafi.Collections.Lyst`1.Capacity"/>) then this operation is O(1) and does not involve any copying.
            </summary>
        </member>
        <member name="T:Mafi.Collections.Lyst`1.Enumerator">
            <summary>
            Struct enumerator that is optimized for fast and allocation-free iteration through the Lyst.
            </summary>
            <remarks>
            Due to optimizations this iterator does not behave the same as <see cref="T:System.Collections.Generic.List`1.Enumerator"/>, namely:
            1. Throws an exception when <see cref="P:Mafi.Collections.Lyst`1.Enumerator.Current"/> is called before <see cref="M:Mafi.Collections.Lyst`1.Enumerator.MoveNext"/> or when <see
               cref="M:Mafi.Collections.Lyst`1.Enumerator.MoveNext"/> returned false. This is not limiting any valid usage since iterator should not be even
            called in those cases.
            2. Value of <see cref="P:Mafi.Collections.Lyst`1.Enumerator.Current"/> is not cached but it is directly returned using index. Typical
            implementation will call the <see cref="P:Mafi.Collections.Lyst`1.Enumerator.Current"/> only once after <see cref="M:Mafi.Collections.Lyst`1.Enumerator.MoveNext"/> returned true so
            caching is waste of resources and memory. This makes the iterator struct significantly smaller.
            3. Does not implement <see cref="T:System.Collections.IEnumerator"/> so it is never boxed and it does NOT implement <see
               cref="T:System.IDisposable"/>. We want the iterator to inline when we do foreach and to not result in a try/finally
            frame in the client.
            </remarks>
        </member>
        <member name="T:Mafi.Collections.Lyst`1.EnumeratorClass">
            <summary>
            Separate enumerator class that implements <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>
            By implementing this enumerator as a class we avoid boxing. Has the same properties as <see
            cref="T:Mafi.Collections.Lyst`1.Enumerator"/>.
            </remarks>
        </member>
        <member name="T:Mafi.Collections.LystExtensions">
            <summary>
            Extensions that use type constraints that cannot be used on <see cref="T:Mafi.Collections.Lyst`1"/> directly.
            </summary>
        </member>
        <member name="M:Mafi.Collections.LystExtensions.AtOrNone``1(Mafi.Collections.Lyst{``0},System.Int32)">
            <summary>
            Returns value at requested index or None if index is invalid.
            </summary>
        </member>
        <member name="T:Mafi.Collections.Queueue`1">
            <summary>
            A simple Queue of generic objects. Internally it is implemented as a circular buffer, so Enqueue is amortized
            O(1) but can be O(n). Dequeue is always O(1).
            </summary>
            <remarks>
            Compared to original <see cref="T:System.Collections.Generic.Queue`1"/> there are following changes:
            * Constructor <see cref="M:Mafi.Collections.Queueue`1.#ctor(System.Boolean,System.Int32)"/> that sets <see cref="F:Mafi.Collections.Queueue`1.OmitClearing"/>. When set, clearing and
            popping do not zero-out internal array and is O(1). This is beneficial when structs are stored or stored
            references are not needed to be GCed. Use with care.
            * Is sealed.
            * Implements <see cref="T:Mafi.Collections.ReadonlyCollections.IIndexable`1"/>.
            * Indexer <see cref="P:Mafi.Collections.Queueue`1.Item(System.Int32)"/> that indexes from the front of the queue (index 0 == peek).
            * Member <see cref="P:Mafi.Collections.Queueue`1.IsEmpty"/>.
            * Read/write <see cref="P:Mafi.Collections.Queueue`1.Capacity"/>.
            * Method <see cref="M:Mafi.Collections.Queueue`1.EnsureCapacity(System.Int32)"/>.
            * Method <see cref="M:Mafi.Collections.Queueue`1.Reverse"/> that reverses the queue in-place without allocations.
            * Method <see cref="M:Mafi.Collections.Queueue`1.TryRemove(`0)"/> that cab remove arbitrary element.
            * Efficient struct and class based Enumerators with condition-less access to Current no Dispose.
            </remarks>
        </member>
        <member name="F:Mafi.Collections.Queueue`1.m_count">
            <summary>
            Number of elements if the Queue.
            </summary>
        </member>
        <member name="F:Mafi.Collections.Queueue`1.m_head">
            <summary>
            The index from which to dequeue if the queue isn't empty.
            </summary>
        </member>
        <member name="F:Mafi.Collections.Queueue`1.m_tail">
            <summary>
            The index at which to enqueue if the queue isn't full.
            </summary>
        </member>
        <member name="F:Mafi.Collections.Queueue`1.OmitClearing">
            <summary>
            Whether zeroing-out of elements can be omitted when removing or clearing.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.#ctor(System.Int32)">
            <summary>
            Creates a queue with a specific initial <paramref name="capacity"/>. The initial <paramref name="capacity"/>
            must be a non-negative number. By default an empty queue is created.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.#ctor(System.Boolean,System.Int32)">
            <param name="omitClearing">
            Whether this queue can omit clearing of internal array when <see cref="M:Mafi.Collections.Queueue`1.Clear"/> is called or items are
            removed from the queue. If this is set to true please keep in mind that any references inserted into the
            queue may be referenced until this queue is referenced and prevent them from being garbage collected.
            </param>
            <param name="capacity">Initial capacity</param>
        </member>
        <member name="P:Mafi.Collections.Queueue`1.Item(System.Int32)">
            <summary>
            Returns i-th element from the front of the queue.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Queueue`1.Count">
            <summary>
            Number of elements in the Queue.
            </summary>
            <remarks>
            Do not implement as auto-property since this member is virtual due to IIndexable interface.
            </remarks>
        </member>
        <member name="P:Mafi.Collections.Queueue`1.IsEmpty">
            <summary>
            Whether the queue is empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Queueue`1.IsNotEmpty">
            <summary>
            Whether the queue is not empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.Queueue`1.IsStoredConsecutively">
             <summary>
             Whether the queue storage is stored on one consecutive place (is not split across the array's boundary).
             WARNING: For perf reasons this returns false for en empty queue.
             </summary>
             <remarks>
             If this is true, the <c>m_count</c> starts at <c>m_head</c>.
            
             Otherwise, there are <c>m_array.Length - m_head</c> elements starting at <c>m_head</c> and then <c>m_tail</c>
             elements starting from <c>0</c>.
             </remarks>
        </member>
        <member name="P:Mafi.Collections.Queueue`1.First">
            <summary>
            Returns the first element of the queue (the same as <see cref="M:Mafi.Collections.Queueue`1.Peek"/>).
            </summary>
            <exception cref="T:System.InvalidOperationException">When the queue is empty.</exception>
        </member>
        <member name="P:Mafi.Collections.Queueue`1.Last">
            <summary>
            Returns the last element at index <c>Count - 1</c> of this Queue.
            </summary>
            <exception cref="T:System.InvalidOperationException">When the queue is empty.</exception>
        </member>
        <member name="P:Mafi.Collections.Queueue`1.Capacity">
            <summary>
            Sets capacity to requested value. This value must be greater or equal to <see cref="P:Mafi.Collections.Queueue`1.Count"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.Peek">
            <summary>
            Returns the object at the head of the queue. The object remains in the queue. If the queue is empty, this
            method throws an InvalidOperationException.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.Enqueue(`0)">
            <summary>
            Adds given item to the end of this queue.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.EnqueueRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds given items to the end of this queue. This is equal as calling <see cref="M:Mafi.Collections.Queueue`1.Enqueue(`0)"/> in on each element
            in order.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.EnqueueFirst(`0)">
            <summary>
            Adds given item to the start of this queue.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.Dequeue">
            <summary>
            Removes the object at the head of the queue and returns it.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.Clear">
            <summary>
            Removes all Objects from the queue. Internal array stays the same size.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.indexOf(`0)">
            <summary>
            Returns actual index of an element in the Queue. Note that this index should be used directly at <see
            cref="F:Mafi.Collections.Queueue`1.m_array"/>. It is invalid to use indexer with this index.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.Contains(`0)">
            <summary>
            Whether queue contains at least one object equal to item.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.ToArray">
            <summary>
            Iterates over the objects in the queue, returning an array of the objects in the Queue, or an empty array if
            the queue is empty. The order of elements in the array is first in to last in, the same order produced by
            successive calls to Dequeue.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the capacity is at least <paramref name="minCapacity"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.moveNext(System.Int32@)">
            <summary>
            Increments the index wrapping it if necessary. Inverse operation to <see cref="M:Mafi.Collections.Queueue`1.moveBack(System.Int32@)"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.moveBack(System.Int32@)">
            <summary>
            Decrements the index wrapping it if necessary. Inverse operation to <see cref="M:Mafi.Collections.Queueue`1.moveNext(System.Int32@)"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.TrimExcess">
            <summary>
            Removes excess allocated memory.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.PopAt(System.Int32)">
            <summary>
            Removes and returns element at given index. Elements are indexed from the head of the queue (oldest first).
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.TryRemove(`0)">
            <summary>
            Tries to remove given element from the queue. Returns true if element was removed.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.removeAt(System.Int32)">
            <summary>
            Removes element at given raw index. This assumes non-empty queue.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Queueue`1.Reverse">
            <summary>
            Reverses the queue in-place in O(n) with no extra allocations.
            </summary>
            <remarks>
            Reverse could be done in O(1) if we allowed reversing direction of the internal representation. Unfortunately
            that would complicate all other operations.
            </remarks>
        </member>
        <member name="T:Mafi.Collections.Queueue`1.Enumerator">
            <summary>
            Struct enumerator that is optimized for fast and allocation-free iteration through the Lyst.
            </summary>
        </member>
        <member name="T:Mafi.Collections.Queueue`1.EnumeratorClass">
            <summary>
            Separate enumerator class that implements <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <remarks>By implementing this enumerator as a class we avoid boxing.</remarks>
        </member>
        <member name="M:Mafi.Collections.QueueueExtensions.FirstOrNone``1(Mafi.Collections.Queueue{``0})">
            <summary>
            Returns first element or <see cref="F:Mafi.Option`1.None"/> if the queue is empty.
            </summary>
            <remarks>
            This needs to be an extension method because we need to make sure that the generic argument is a class.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.QueueueExtensions.LastOrNone``1(Mafi.Collections.Queueue{``0})">
            <summary>
            Returns last element or <see cref="F:Mafi.Option`1.None"/> if the queue is empty.
            </summary>
            <remarks>
            This needs to be an extension method because we need to make sure that the generic argument is a class.
            </remarks>
        </member>
        <member name="T:Mafi.Collections.ReadonlyCollections.IIndexable`1">
            <summary>
            Read-only collection that can be indexed.
            </summary>
            <remarks>Please use only on classes to prevent boxing.</remarks>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.IIndexable`1.GetEnumerator">
            <summary>
            Returns struct-based enumerator for allocation-free iteration through indexable.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ReadonlyCollections.IndexableAdapter`2">
            <summary>
            Presents mapped IIndexable as IIndexable.
            </summary>
        </member>
        <member name="F:Mafi.Collections.ReadonlyCollections.IndexableAdapter`2.m_source">
            <summary>
            Source data.
            </summary>
        </member>
        <member name="F:Mafi.Collections.ReadonlyCollections.IndexableAdapter`2.m_adapter">
            <summary>
            Used to transform items in source to destination type.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ReadonlyCollections.IndexableIenumerator`1">
            <summary>
            Enumerator that can be used to implement AsEnumerable on any class implementing <see cref="T:Mafi.Collections.ReadonlyCollections.IIndexable`1"/>.
            The class can then implement <see cref="T:System.Collections.Generic.IEnumerable`1"/> too and its GetEnumerator implementation for
            IEnumerable then returns this enumerator. The enumerator is implemented as class because it is used through the
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> interface anyway.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ReadonlyCollections.IReadOnlyArray">
            <summary>
            An internal non-generic interface implemented by <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/> that allows for recognition of an
            <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/> instance and access to its underlying array, without actually knowing the type of
            value stored in it.
            </summary>
            <remarks>
            Casting to this interface requires a boxed instance of the <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/> struct, and as such
            should be avoided. This interface is useful, however, where the value is already boxed and we want to try to
            reuse immutable arrays instead of copying them.
            ** This interface is INTENTIONALLY INTERNAL, as it gives access to the inner array. **
            </remarks>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.IReadOnlyArray.Array">
            <summary>
            Gets an untyped reference to the array.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray">
            <summary>
            A set of initialization methods for instances of <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray.AsReadOnlyArray``1(``0[])">
            <summary>
            Returns read-only reference to this array. Note that this does not do defensive copy and underlying array can
            be mutated. Use <see cref="M:Mafi.Collections.ImmutableCollections.ImmutableArray.ToImmutableArray``1(System.Collections.Generic.IEnumerable{``0})"/> for truly
            immutable array.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1">
            <summary>
            A readonly array slice (a sub-range of another array) with O(1) indexable lookup time.
            </summary>
            <devremarks>
            IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS: This type should be thread-safe. As a struct, it cannot protect
            its own fields from being changed from one thread while its members are executing on other threads because
            structs can change *in place* simply by reassigning the field containing this struct. Therefore it is extremely
            important that ** Every member should only dereference <c>this</c> ONCE. ** If a member needs to reference the
            array field, that counts as a dereference of <c>this</c>. Calling other instance members (properties or methods)
            also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more than once must instead
            assign <c>this</c> to a local variable and use that for the rest of the code instead. This effectively copies the
            one field in the struct to a local variable so that it is insulated from other threads.
            </devremarks>
        </member>
        <member name="F:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.Empty">
            <summary>
            An empty (initialized) instance of <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1"/>.
            </summary>
        </member>
        <member name="F:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.m_array">
            <summary>
            The underlying array.
            </summary>
        </member>
        <member name="F:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.m_startIndex">
            <summary>
            Start index of this slice.
            </summary>
        </member>
        <member name="F:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.m_count">
            <summary>
            Number of elements of this slice.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index in the array slice.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.Length">
            <summary>
            Gets the length of array in the collection.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.IsEmpty">
            <summary>
            Whether this array is empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.IsNull">
            <summary>
            Whether this struct was initialized without an actual array instance.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.IsNullOrEmpty">
            <summary>
            Whether this struct is empty or uninitialized.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.First">
            <summary>
            Gets the first element of the array. Throws exception if the array is null or empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.Last">
            <summary>
            Gets the last element of the array. Throws exception if the array is null or empty.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.GetEnumerator">
            <summary>
            Returns an enumerator for the contents of the array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.Reversed">
            <summary>
            Returns new array that is reversed.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.Select``1(System.Func{`0,``0})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.Enumerator">
            <summary>
            An array enumerator.
            </summary>
            <remarks>
            It is important that this enumerator does NOT implement <see cref="T:System.IDisposable"/>. We want the iterator to
            inline when we do foreach and to not result in a try/finally frame in the client.
            </remarks>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.Enumerator.Current">
            <summary>
            Gets the currently enumerated value.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArraySlice`1.Enumerator.MoveNext">
            <summary>
            Advances to the next value to be enumerated.
            </summary>
            <returns><c>true</c> if another item exists in the array; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1">
             <summary>
             A readonly array with O(1) indexable lookup time. This provides weaker guarantee than <see
             cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/> since this array's elements are allowed to be mutated by classes that have a reference
             to the underlying array.
             </summary>
             <typeparam name="T">The type of element stored by the array.</typeparam>
             <example>
             A typical example of usage is providing public read-only view of a private array.
             <code>
             class Example {
             private readonly int[] m_numbers = new int[10];
            
             public readonly ReadOnlyArray&lt;int&gt; Numbers =&gt; m_numbers.AsReadOnlyArray();
            
             public void DoWork() {
             m_numbers[5] += 42; // This change will be propagated to all owners of ReadOnlyArray.
             }
             }
             </code>
             </example>
             <devremarks>
             This type has a documented contract of being exactly one reference-type field in size.
            
             IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS: This type should be thread-safe. As a struct, it cannot protect
             its own fields from being changed from one thread while its members are executing on other threads because
             structs can change *in place* simply by reassigning the field containing this struct. Therefore it is extremely
             important that ** Every member should only dereference <c>this</c> ONCE. ** If a member needs to reference the
             array field, that counts as a dereference of <c>this</c>. Calling other instance members (properties or methods)
             also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more than once must instead
             assign <c>this</c> to a local variable and use that for the rest of the code instead. This effectively copies the
             one field in the struct to a local variable so that it is insulated from other threads.
             </devremarks>
        </member>
        <member name="F:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Empty">
            <summary>
            An empty (initialized) instance of <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/>.
            </summary>
        </member>
        <member name="F:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.m_array">
            <summary>
            The backing field for this instance. References to this value should never be shared with outside code.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/> struct *without making a defensive copy*.
            </summary>
            <param name="items">The array to use. May be null for "default" arrays.</param>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index in the read-only list.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index in the read-only list.</returns>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Length">
            <summary>
            Gets the length of array in the collection.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.IsEmpty">
            <summary>
            Whether this array is empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.IsNotValid">
            <summary>
            Whether this struct was initialized without an actual array instance.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.IsNullOrEmpty">
            <summary>
            Whether this struct is empty or uninitialized.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.First">
            <summary>
            Gets the first element of the array. Throws exception if the array is null or empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Last">
            <summary>
            Gets the last element of the array. Throws exception if the array is null or empty.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.AsIndexable">
            <summary>
            Returns this array as indexable. This creates a new class instance to prevent boxing.
            </summary>
        </member>
        <member name="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Mafi#Collections#ReadonlyCollections#IReadOnlyArray#Array">
            <summary>
            Gets an untyped boxed reference to the array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.op_Equality(Mafi.Collections.ReadonlyCollections.ReadOnlyArray{`0},Mafi.Collections.ReadonlyCollections.ReadOnlyArray{`0})">
            <summary>
            Checks equality between two instances.
            </summary>
            <param name="left">The instance to the left of the operator.</param>
            <param name="right">The instance to the right of the operator.</param>
            <returns><c>true</c> if the values' underlying arrays are reference equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.op_Inequality(Mafi.Collections.ReadonlyCollections.ReadOnlyArray{`0},Mafi.Collections.ReadonlyCollections.ReadOnlyArray{`0})">
            <summary>
            Checks inequality between two instances.
            </summary>
            <param name="left">The instance to the left of the operator.</param>
            <param name="right">The instance to the right of the operator.</param>
            <returns>
            <c>true</c> if the values' underlying arrays are reference not equal; <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.op_Equality(System.Nullable{Mafi.Collections.ReadonlyCollections.ReadOnlyArray{`0}},System.Nullable{Mafi.Collections.ReadonlyCollections.ReadOnlyArray{`0}})">
            <summary>
            Checks equality between two instances.
            </summary>
            <param name="left">The instance to the left of the operator.</param>
            <param name="right">The instance to the right of the operator.</param>
            <returns><c>true</c> if the values' underlying arrays are reference equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.op_Inequality(System.Nullable{Mafi.Collections.ReadonlyCollections.ReadOnlyArray{`0}},System.Nullable{Mafi.Collections.ReadonlyCollections.ReadOnlyArray{`0}})">
            <summary>
            Checks inequality between two instances.
            </summary>
            <param name="left">The instance to the left of the operator.</param>
            <param name="right">The instance to the right of the operator.</param>
            <returns>
            <c>true</c> if the values' underlying arrays are reference not equal; <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.IndexOf(`0)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.IndexOf(`0,System.Int32)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches the array for the specified item.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.LastIndexOf(`0)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Searches the array for the specified item in reverse.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Contains(`0)">
            <summary>
            Determines whether the specified item exists in the array.
            </summary>
            <param name="item">The item to search for.</param>
            <returns><c>true</c> if an equal value was found in the array; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.CopyTo(`0[])">
            <summary>
            Copies the contents of this array to the specified array.
            </summary>
            <param name="destination">The array to copy to.</param>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.BinarySearch(`0)">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/> for a specific element, using the
            <see cref="T:System.IComparable`1"/> generic interface implemented by each element of the <see
            cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/> and by the specified object.
            </summary>
            <param name="value">The object to search for.</param>
            <returns>
            The index of the specified <paramref name="value"/> in the specified array, if <paramref name="value"/> is
            found. If <paramref name="value"/> is not found and <paramref name="value"/> is less than one or more
            elements in array, a negative number which is the bitwise complement of the index of the first element that
            is larger than <paramref name="value"/>. If <paramref name="value"/> is not found and <paramref
            name="value"/> is greater than any of the elements in array, a negative number which is the bitwise
            complement of (the index of the last element plus 1).
            </returns>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="value"/> does not implement the <see cref="T:System.IComparable`1"/> generic interface, and the
            search encounters an element that does not implement the <see cref="T:System.IComparable`1"/> generic interface.
            </exception>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.GetEnumerator">
            <summary>
            Returns an enumerator for the contents of the array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Equals(Mafi.Collections.ReadonlyCollections.ReadOnlyArray{`0})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.CastUp``1(Mafi.Collections.ReadonlyCollections.ReadOnlyArray{``0})">
            <summary>
            Initializes a new instance of the <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/> struct based on the contents of an existing
            instance, allowing a covariant static cast to efficiently reuse the existing array.
            </summary>
            <param name="items">The array to initialize the array with. No copy is made.</param>
            <remarks>
            Covariant up-casts from this method may be reversed by calling the <see cref="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.As``1"/>
            or <see cref="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.CastArray``1"/> method.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.CastArray``1">
            <summary>
            Initializes a new instance of the <see cref="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1"/> struct by casting the underlying array to an
            array of type <typeparam name="TOther"/> .
            </summary>
            <exception cref="T:System.InvalidCastException">Thrown if the cast is illegal.</exception>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.As``1">
            <summary>
            Creates an immutable array for this array, cast to a different element type.
            </summary>
            <typeparam name="TOther">The type of array element to return.</typeparam>
            <returns>
            A struct typed for the base element type. If the cast fails, an instance is returned whose <see
            cref="P:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.IsNotValid"/> property returns <c>true</c>.
            </returns>
            <remarks>
            Arrays of derived elements types can be cast to arrays of base element types without reallocating the array.
            These up-casts can be reversed via this same method, casting an array of base element types to their derived
            types. However, down-casting is only successful when it reverses a prior up-casting operation.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.OfType``1">
            <summary>
            Filters the elements of this array to those assignable to the specified type.
            </summary>
            <typeparam name="TResult">The type to filter the elements of the sequence on.</typeparam>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains elements from the input sequence of type <typeparamref
            name="TResult"/>.
            </returns>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.AsEnumerable">
            <summary>
            Returns this array as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.FirstOrDefault(System.Func{`0,System.Boolean})">
            <summary>
            Returns the first element of the sequence that satisfies a condition or a default value if no such element is
            found.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Skip(System.Int32)">
            <summary>
            Bypasses a specified number of elements in a sequence and then returns the remaining elements.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Map``1(System.Func{`0,``0})">
            <summary>
            Map this array to a new read-only array using a mapper function.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.MapArray``1(System.Func{`0,``0})">
            <summary>
            Map this array to a new mutable array using a mapper function.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Select``1(System.Func{`0,``0})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Where(System.Func{`0,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Aggregate(System.Func{`0,`0,`0})">
            <summary>
            Applies an accumulator function over a sequence.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Sorts the elements of a sequence in ascending order according to a key.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.throwNullRefIfNotInitialized">
            <summary>
            Throws a null reference exception if the array field is null.
            </summary>
        </member>
        <member name="T:Mafi.Collections.ReadonlyCollections.ReadOnlyArray`1.Enumerator">
            <summary>
            An array enumerator.
            </summary>
            <remarks>
            It is important that this enumerator does NOT implement <see cref="T:System.IDisposable"/>. We want the iterator to
            inline when we do foreach and to not result in a try/finally frame in the client.
            </remarks>
        </member>
        <member name="T:Mafi.Collections.ReadWriteSwapLyst`1">
             <summary>
             Writes to one list and reads from other one. Swap them on demand.
             </summary>
             <remarks>
             This data structure is very handy where sim thread is working on some things and writing them to one list while
             vis thread is reading changes from the last sim step. It also makes reads thread-safe and separated from writes,
             however, multiple writes are not thread safe!
            
             This class should be exposed through <see cref="T:Mafi.Collections.IReadSwapLyst`1"/> interface.
             </remarks>
        </member>
        <member name="P:Mafi.Collections.ReadWriteSwapLyst`1.Count">
            <summary>
            Returns items count in current read list.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadWriteSwapLyst`1.Add(`0)">
            <summary>
            Adds an item to the write list.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadWriteSwapLyst`1.Remove(`0)">
            <summary>
            Tries to remove an item from the write list (the one that is not exposed for reading). Returns true if the
            element was removed.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadWriteSwapLyst`1.SwapAndClear">
            <summary>
            Swaps read and write lists and clears the new write list.
            </summary>
        </member>
        <member name="M:Mafi.Collections.ReadWriteSwapLyst`1.ForEach(System.Action{`0})">
            <summary>
            Performs given action on every item in the read list.
            </summary>
        </member>
        <member name="T:Mafi.Collections.Set`1">
             <summary>
             Hash-based set of unique elements.
            
             Mafi changes and additions:
             * Implements IReadOnlySet.
             * Added methods: AddAndAssertNew, AddRange, ForEach, ForEachAndClear
             * Asserts instead of some Exceptions and Debug/Contract calls.
             * Removed support for a custom comparer since we have no good way to save it for now.
            
             Not: Based on MIT-licensed implementation from .NET core:
             https://github.com/microsoft/referencesource/blob/master/System.Core/System/Collections/Generic/HashSet.cs
            
             Implementation notes: This uses an array-based implementation similar to Dictionary{T}, using a buckets array to
             map hash values to the Slots array. Items in the Slots array that hash to the same value are chained together
             through the "next" indices.
            
             The capacity is always prime; so during resizing, the capacity is chosen as the next prime greater than double
             the last capacity.
            
             The underlying data structures are lazily initialized. Because of the observation that, in practice, hashtables
             tend to contain only a few elements, the initial capacity is set very small (3 elements) unless the ctor with a
             collection is used.
            
             The +/- 1 modifications in methods that add, check for containment, etc allow us to distinguish a hash code of 0
             from an uninitialized bucket. This saves us from having to reset each bucket to -1 when resizing. See Contains,
             for example.
            
             Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify this set.
            
             Some operations can perform faster if we can assume "other" contains unique elements according to this equality
             comparer. The only times this is efficient to check is if other is a hashset. Note that checking that it's a
             hashset alone doesn't suffice; we also have to check that the hashset is using the same equality comparer. If
             other has a different equality comparer, it will have unique elements according to its own equality comparer, but
             not necessarily according to ours. Therefore, to go these optimized routes we check that other is a hashset using
             the same equality comparer.
            
             A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for special empty set
             checks.)
            
             A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). If we didn't have these
             checks, we could be iterating over the set and modifying at the same time.
             </summary>
        </member>
        <member name="P:Mafi.Collections.Set`1.Count">
            <summary>
            Number of elements in this hashset
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Implementation Notes: Since resizes are relatively expensive (require rehashing), this attempts to minimize
            the need to resize by setting the initial capacity based on size of collection.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add item to this hashset. This is the explicit implementation of the ICollection{T} interface. The other Add
            method returns bool indicating whether item was added.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.Clear">
            <summary>
            Remove all items from this set. This clears the elements but not the underlying buckets and slots array.
            Follow this call by TrimExcess to release these.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.Contains(`0)">
            <summary>
            Returns whether this hashset contains the given item.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy items in this hashset to array, starting at arrayIndex
            </summary>
            <param name="array">array to add items to</param>
            <param name="arrayIndex">index to start at</param>
        </member>
        <member name="M:Mafi.Collections.Set`1.Remove(`0)">
            <summary>
            Remove item from this hashset
            </summary>
            <param name="item">item to remove</param>
            <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
        </member>
        <member name="P:Mafi.Collections.Set`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Whether this is readonly
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.Add(`0)">
            <summary>
            Add item to this HashSet. Returns bool indicating whether item was added (won't be added if already present)
            </summary>
            <returns>true if added, false if already present</returns>
        </member>
        <member name="M:Mafi.Collections.Set`1.TryGetValue(`0,`0@)">
            <summary>
            Searches the set for a given value and returns the equal value it finds, if any.
            </summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">
            The value from the set that the search found, or the default value of <typeparamref name="T"/> when the
            search yielded no match.
            </param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of a newly constructed one
            (so that more sharing of references can occur) or to look up a value that has more complete data than the
            value you currently have, although their comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.Set`1.ForEach(System.Action{`0})">
             <summary>
             Calls function on every element.
            
             PERF: Avoid this with capturing lambdas in perf sensitive code.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.ForEach``1(System.Func{`0,``0})">
             <summary>
             Calls function on every element and ignores its return value.
            
             PERF: Avoid this with capturing lambdas in perf sensitive code.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.ForEachAndClear(System.Action{`0})">
             <summary>
             Calls given action on every element and clears the list.
            
             PERF: Avoid this with capturing lambdas in perf sensitive code.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.ForEachAndClear``1(System.Func{`0,``0})">
             <summary>
             Calls given action on every element while ignoring return value from the function. Clears the list after the
             iteration.
            
             PERF: Avoid this with capturing lambdas in perf sensitive code.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Take the union of this HashSet with other. Modifies this set.
            
             Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding multiple resizes ended up
             not being useful in practice; quickly gets to the point where it's a wasteful check.
             </summary>
             <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:Mafi.Collections.Set`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Takes the intersection of this set with other. Modifies this set.
            
             Implementation Notes: We get better perf if other is a hashset using same equality comparer, because we get
             constant contains check in other. Resulting cost is O(n1) to iterate over this.
            
             If we can't go above route, iterate over the other and mark intersection by checking contains in this. Then
             loop over and delete any unmarked elements. Total cost is n2+n1.
            
             Attempts to return early based on counts alone, using the property that the intersection of anything with the
             empty set is the empty set.
             </summary>
             <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:Mafi.Collections.Set`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:Mafi.Collections.Set`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to XOR</param>
        </member>
        <member name="M:Mafi.Collections.Set`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Checks if this is a subset of other.
            
             Implementation Notes: The following properties are used up-front to avoid element-wise checks:
             1. If this is the empty set, then it's a subset of anything, including the empty set
             2. If other has unique elements according to this equality comparer, and this has more elements than other,
             then it can't be a subset.
            
             Furthermore, if other is a hashset using the same equality comparer, we can use a faster element-wise check.
             </summary>
             <param name="other"></param>
             <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:Mafi.Collections.Set`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Checks if this is a proper subset of other (i.e. strictly contained in)
            
             Implementation Notes: The following properties are used up-front to avoid element-wise checks:
             1. If this is the empty set, then it's a proper subset of a set that contains at least one element, but it's
             not a proper subset of the empty set.
             2. If other has unique elements according to this equality comparer, and this has &gt;= the number of
             elements in other, then this can't be a proper subset.
            
             Furthermore, if other is a hashset using the same equality comparer, we can use a faster element-wise check.
             </summary>
             <param name="other"></param>
             <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:Mafi.Collections.Set`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Checks if this is a superset of other
            
             Implementation Notes: The following properties are used up-front to avoid element-wise checks:
             1. If other has no elements (it's the empty set), then this is a superset, even if this is also the empty
             set.
             2. If other has unique elements according to this equality comparer, and this has less than the number of
             elements in other, then this can't be a superset
             </summary>
             <param name="other"></param>
             <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:Mafi.Collections.Set`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Checks if this is a proper superset of other (i.e. other strictly contained in this)
            
             Implementation Notes: This is slightly more complicated than above because we have to keep track if there was
             at least one element not contained in other.
            
             The following properties are used up-front to avoid element-wise checks:
             1. If this is the empty set, then it can't be a proper superset of any set, even if other is the empty set.
             2. If other is an empty set and this contains at least 1 element, then this is a proper superset.
             3. If other has unique elements according to this equality comparer, and other's count is greater than or
             equal to this count, then this can't be a proper superset
            
             Furthermore, if other has unique elements according to this equality comparer, we can use a faster
             element-wise check.
             </summary>
             <param name="other"></param>
             <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:Mafi.Collections.Set`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:Mafi.Collections.Set`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this and other contain the same elements. This is set equality: duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Mafi.Collections.Set`1.RemoveWhere(System.Predicate{`0},System.Action{`0})">
            <summary>
            Remove elements that match specified predicate. Returns the number of elements removed
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.SampleRandomKeyOrDefault(Mafi.IRandom)">
            <summary>
            Allocation-free sampling of random set element in O(n).
            </summary>
        </member>
        <member name="P:Mafi.Collections.Set`1.Comparer">
            <summary>
            Gets the IEqualityComparer that is used to determine equality of keys for the HashSet.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.TrimExcess">
             <summary>
             Sets the capacity of this set to the size of the set (rounded up to nearest prime), unless count is 0, in
             which case we release references.
            
             This method can be used to minimize a set's memory overhead once it is known that no new elements will be
             added to the set. To completely clear a set and release all memory referenced by the set, execute the
             following statements:
            
             set.Clear(); set.TrimExcess();
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime greater than or equal to
            capacity.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.increaseCapacity">
            <summary>
            Expand to new capacity. New capacity is next prime greater than or equal to suggested size. This is called
            when the underlying array is filled. This performs no defragmentation, allowing faster execution; note that
            this is reasonable since AddIfNotPresent attempts to insert new elements in re-opened spots.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.setCapacity(System.Int32,System.Boolean)">
            <summary>
            Set the underlying buckets array to size newSize and rehash. Note that newSize
            *must* be a prime. It is very likely that you want to call IncreaseCapacity() instead of this method.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.addIfNotPresent(`0)">
            <summary>
            Adds value to HashSet if not contained already Returns true if added and false if already present
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.containsAllElements(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and returns false as soon as it
            finds an element in other that's not in this. Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.isSubsetOfHashSetWithSameEc(Mafi.Collections.Set{`0})">
             <summary>
             Implementation Notes: If other is a hashset and is using same equality comparer, then checking subset is
             faster. Simply check that each element in this is in other.
            
             Note: if other doesn't use same equality comparer, then Contains check is invalid, which is why callers must
             take are of this.
            
             If callers are concerned about whether this is a proper subset, they take care of that.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.intersectWithHashSetWithSameEc(Mafi.Collections.Set{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster because we can use other's
            Contains
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.intersectWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Iterate over other. If contained in this, mark an element in bit array corresponding to its position in
             m_slots. If anything is unmarked (in bit array), remove it.
            
             This attempts to allocate on the stack, if below StackAllocThreshold.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.internalIndexOf(`0)">
            <summary>
            Used internally by set operations which have to rely on bit array marking. This is like Contains but returns
            index in slots array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.symmetricExceptWithUniqueHashSet(Mafi.Collections.Set{`0})">
             <summary>
             if other is a set, we can assume it doesn't have duplicate elements, so use this
             technique: if can't remove, then it wasn't present in this set, so add.
            
             As with other methods, callers take care of ensuring that other is a hashset using the same equality
             comparer.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.symmetricExceptWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Implementation notes:
            
             Used for symmetric except when other isn't a HashSet. This is more tedious because other may contain
             duplicates. HashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: HashSet technique would add then remove it.
             2. Other has a duplicate that's in this: HashSet technique would remove then add it back. In general, its
             presence would be toggled each time it appears in other.
            
             This technique uses bit marking to indicate whether to add/remove the item. If already present in collection,
             it will get marked for deletion. If added from other, it will get marked as something not to remove.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.addOrGetLocation(`0,System.Int32@)">
            <summary>
            Add if not already in hashset. Returns an out param indicating index where added. This is used by
            SymmetricExcept because it needs to know the following things:
            - whether the item was already present in the collection or added from other
            - where it's located (if already present, it will get marked for removal, otherwise marked for keeping)
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.checkUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
             <summary>
             Determines counts that can be used to determine equality, subset, and superset. This is only used when other
             is an IEnumerable and not a HashSet. If other is a HashSet these properties can be checked faster without use
             of marking because we can assume other has no duplicates.
            
             The following count checks are performed by callers:
             1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = m_count; i.e. everything in other is in this and
             everything in this is in other
             2. Subset: checks if unfoundCount &gt;= 0 and uniqueFoundCount = m_count; i.e. other may have elements not in
             this and everything in this is in other
             3. Proper subset: checks if unfoundCount &gt; 0 and uniqueFoundCount = m_count; i.e other must have at least
             one element not in this and everything in this is in other
             4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less than m_count; i.e.
             everything in other was in this and this had at least one element not contained in other.
            
             An earlier implementation used delegates to perform these checks rather than returning an ElementCount
             struct; however this was changed due to the perf overhead of delegates.
             </summary>
             <param name="other"></param>
             <param name="returnIfUnfound">
             Allows us to finish faster for equals and proper superset because unfoundCount must be 0.
             </param>
             <returns></returns>
        </member>
        <member name="M:Mafi.Collections.Set`1.ToArray">
            <summary>
            Copies this to an array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.HashSetEquals(Mafi.Collections.Set{`0},Mafi.Collections.Set{`0},System.Collections.Generic.IEqualityComparer{`0})">
             <summary>
             Internal method used for HashSetEqualityComparer. Compares set1 and set2 according to specified comparer.
            
             Because items are hashed according to a specific equality comparer, we have to resort to n^2 search if
             they're using different equality comparers.
             </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.areEqualityComparersEqual(Mafi.Collections.Set{`0},Mafi.Collections.Set{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can speed up if it knows the other
            item has unique elements. I.e. if they're using different equality comparers, then uniqueness assumption
            between sets break.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Set`1.internalGetHashCode(`0)">
            <summary>
            Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="T:Mafi.Collections.Stak`1">
            <summary>
            A simple stack of objects. Internally it is implemented as an array, so Push is amortized O(1) but can be O(n).
            Pop is O(1).
            </summary>
            <remarks>
            Compared to original <see cref="T:System.Collections.Generic.Stack`1"/> there are following changes:
            * Constructor <see cref="M:Mafi.Collections.Stak`1.#ctor(System.Boolean,System.Int32)"/> that sets <see cref="F:Mafi.Collections.Stak`1.OmitClearing"/>. When set, clearing and
            popping do not zero-out internal array and is O(1). This is beneficial when structs are stored or stored
            references are not needed to be GCed. Use with care.
            * Is sealed.
            * Implements <see cref="T:Mafi.Collections.ReadonlyCollections.IIndexable`1"/>.
            * Indexer <see cref="P:Mafi.Collections.Stak`1.Item(System.Int32)"/> that indexes from the top of the stack.
            * Member <see cref="P:Mafi.Collections.Stak`1.IsEmpty"/>.
            * Read/write <see cref="P:Mafi.Collections.Stak`1.Capacity"/>.
            * Method <see cref="M:Mafi.Collections.Stak`1.EnsureCapacity(System.Int32)"/>.
            * Methods <see cref="M:Mafi.Collections.Stak`1.PushRange(Mafi.Collections.ReadonlyCollections.IIndexable{`0})"/> and <see cref="M:Mafi.Collections.Stak`1.PushRangeReversed(Mafi.Collections.ReadonlyCollections.IIndexable{`0})"/> for convenient adding of multiple objects.
            * Enumerator with condition-less access to Current and without Dispose method to allow optimizations in foreach
            cycles.
            TODO: Cleanup and document the code, write tests.
            </remarks>
        </member>
        <member name="M:Mafi.Collections.Stak`1.#ctor(System.Int32)">
            <summary>
            Creates a stack with a specific initial <paramref name="capacity"/>. The initial <paramref name="capacity"/>
            must be a non-negative number. By default an empty stack is created.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Stak`1.#ctor(System.Boolean,System.Int32)">
            <param name="omitClearing">
            Whether this stack can omit clearing of internal array when <see cref="M:Mafi.Collections.Stak`1.Clear"/> is called or items are
            removed from the stack. If this is set to true please keep in mind that any references inserted into the
            stack may be referenced until this stack is referenced and prevent them from being garbage collected.
            </param>
            <param name="capacity">Initial capacity</param>
        </member>
        <member name="P:Mafi.Collections.Stak`1.Capacity">
            <summary>
            Gets or sets capacity of this stack.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            When setting capacity to the smaller value than <see cref="P:Mafi.Collections.Stak`1.Count"/>.
            </exception>
        </member>
        <member name="P:Mafi.Collections.Stak`1.First">
            <summary>
            Returns the first element of this stack. This is equivalent to <see cref="M:Mafi.Collections.Stak`1.Peek"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">When the stack is empty.</exception>
        </member>
        <member name="P:Mafi.Collections.Stak`1.Last">
            <summary>
            Returns the last element of the stack (the one that would be popped last).
            </summary>
            <exception cref="T:System.InvalidOperationException">When the stack is empty.</exception>
        </member>
        <member name="M:Mafi.Collections.Stak`1.Clear">
            <summary>
            Removes all items from this Stack. Capacity remains unchanged.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Stak`1.Peek">
            <summary>
            Returns the top object on the stack without removing it.
            </summary>
            <exception cref="T:System.InvalidOperationException">When the stack is empty.</exception>
        </member>
        <member name="M:Mafi.Collections.Stak`1.Pop">
            <summary>
            Pops an item from the top of the stack. If the stack is empty, Pop throws an InvalidOperationException.
            </summary>
            <exception cref="T:System.InvalidOperationException">When the stack is empty.</exception>
        </member>
        <member name="M:Mafi.Collections.Stak`1.Push(`0)">
            <summary>
            Pushes an item to the top of the stack.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Stak`1.PushRange(Mafi.Collections.ReadonlyCollections.IIndexable{`0})">
            <summary>
            Pushes given values on the stack so that the last element will be on top of the stack. This is semantically
            equivalent to call of <see cref="M:Mafi.Collections.Stak`1.Push(`0)"/> on all values in order (first to last), but more effective.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Stak`1.PushRangeReversed(Mafi.Collections.ReadonlyCollections.IIndexable{`0})">
            <summary>
            Pushes given values on the stack so that the first element will be on top of the stack. This is semantically
            equivalent to call of <see cref="M:Mafi.Collections.Stak`1.Push(`0)"/> on all values in reversed order (last to first), but more effective.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Stak`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the stack into an array.
            </summary>
        </member>
        <member name="M:Mafi.Collections.Stak`1.ToArray">
            <summary>
            Copies the Stack to an array, in the same order Pop would return the items.
            </summary>
        </member>
        <member name="T:Mafi.Indexable`1">
            <summary>
            Helper class that offers empty indexable instance for convenience.
            </summary>
        </member>
        <member name="F:Mafi.Indexable`1.Empty">
            <summary>
            Empty indexable instance for convenience.
            </summary>
        </member>
        <member name="T:Mafi.IndexableArray`1">
            <summary>
            Helper class that wraps array as indexable.
            </summary>
        </member>
        <member name="M:Mafi.IIndexableExtensions.IsEmpty``1(Mafi.Collections.ReadonlyCollections.IIndexable{``0})">
            <summary>
            Returns whether this indexable is empty. I know, very surprising.
            </summary>
        </member>
        <member name="M:Mafi.IIndexableExtensions.IsNotEmpty``1(Mafi.Collections.ReadonlyCollections.IIndexable{``0})">
            <summary>
            Returns whether this indexable is not empty.
            </summary>
        </member>
        <member name="M:Mafi.IIndexableExtensions.First``1(Mafi.Collections.ReadonlyCollections.IIndexable{``0})">
            <summary>
            Returns the first element at index 0 of this indexable. It is callers responsibility to check whether this
            indexable is not empty.
            </summary>
        </member>
        <member name="M:Mafi.IIndexableExtensions.Last``1(Mafi.Collections.ReadonlyCollections.IIndexable{``0})">
            <summary>
            Returns the last element at index <c>Count - 1</c> of this indexable. It is callers responsibility to check
            whether this indexable is not empty.
            </summary>
        </member>
        <member name="M:Mafi.IIndexableExtensions.IndexOf``2(Mafi.Collections.ReadonlyCollections.IIndexable{``0},``1,System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Finds an index of given item, using a selector to select value from list first.
            Perf: We do not take a predicate to avoid capturing lambdas.
            </summary>
        </member>
        <member name="M:Mafi.IIndexableExtensions.ToImmutableArray``1(Mafi.Collections.ReadonlyCollections.IIndexable{``0})">
            <summary>
            Creates new immutable array from this indexable.
            </summary>
        </member>
        <member name="P:Mafi.Curves.CubicBezierCurve3f.ControlPointsCount">
            <summary>
            Number of control points of this curve. It is always 1 + 3 * <see cref="P:Mafi.Curves.CubicBezierCurve3f.SegmentsCount"/>. Curve with only one
            initial control point is considered empty.
            </summary>
        </member>
        <member name="P:Mafi.Curves.CubicBezierCurve3f.SegmentsCount">
            <summary>
            Number of Cubic Bezier segments.
            </summary>
        </member>
        <member name="P:Mafi.Curves.CubicBezierCurve3f.IsEmpty">
            <summary>
            Whether curve is empty, that's when <see cref="P:Mafi.Curves.CubicBezierCurve3f.SegmentsCount"/> is zero. Note that a curve with only one
            initial control point is considered empty.
            </summary>
        </member>
        <member name="P:Mafi.Curves.CubicBezierCurve3f.LastControlPoint">
            <summary>
            Returns last control point of the curve. Every curve should have at least one point.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurve3f.Sample(Mafi.Percent)">
            <summary>
            Returns position on the curve at given <paramref name="t"/>.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurve3f.SampleSegment(System.Int32,Mafi.Percent)">
            <summary>
            Returns position on the curve within segment <paramref name="segmentIndex"/> at given <paramref name="t"/>.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurve3f.sampleSegment(System.Int32,Mafi.Percent)">
            <summary>
            http://en.wikipedia.org/wiki/Bezier_curve
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurve3f.SampleDerivative(Mafi.Percent)">
            <summary>
            Returns derivative (tangent) of the curve at given <paramref name="t"/>.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurve3f.SampleSegmentDerivative(System.Int32,Mafi.Percent)">
            <summary>
            Returns derivative (tangent) of the curve within segment <paramref name="segmentIndex"/> at given <paramref
            name="t"/>.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurve3f.sampleSegmentDerivative(System.Int32,Mafi.Percent)">
            <summary>
            http://en.wikipedia.org/wiki/Bezier_curve#Derivative
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurve3f.IsStraightSegment(System.Int32)">
            <summary>
            Whether given <paramref name="segmentIndex"/> is just a straight line.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurve3f.getSegmentIndex(Mafi.Percent@)">
            <summary>
            Returns segment number based on given parameter <paramref name="t"/> and transforms to a parameter of
            position within th segment. Segments are assumed to be uniformly distributed with regards to <paramref
            name="t"/>.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurve3f.Optimize">
            <summary>
            Optimizes the curve by merging consecutive straight segments.
            </summary>
        </member>
        <member name="T:Mafi.Curves.CubicBezierCurveSegment3f">
            <summary>
            Single segment of cubic bezier curve specified by 4 points.
            </summary>
            <remarks>http://en.wikipedia.org/wiki/Bezier_curve</remarks>
        </member>
        <member name="F:Mafi.Curves.CubicBezierCurveSegment3f.P0">
            <summary>
            Start point of the curve.
            </summary>
        </member>
        <member name="F:Mafi.Curves.CubicBezierCurveSegment3f.P1">
            <summary>
            Start control point that specifies tangent and "speed" at the start point.
            </summary>
        </member>
        <member name="F:Mafi.Curves.CubicBezierCurveSegment3f.P2">
            <summary>
            End control point that specifies tangent and "speed" at the end point.
            </summary>
        </member>
        <member name="F:Mafi.Curves.CubicBezierCurveSegment3f.P3">
            <summary>
            End point of the curve.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurveSegment3f.#ctor(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Creates straight curve.
            </summary>
            <remarks>Keep in mind that when `t == x` it does not correspond to x% among the curve.</remarks>
        </member>
        <member name="P:Mafi.Curves.CubicBezierCurveSegment3f.IsLine">
            <summary>
            Whether this segment is a straight line.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurveSegment3f.Sample(Mafi.Percent)">
            <summary>
            Returns position on the curve segment at given <paramref name="t"/> ∈ [0, 1]. Note that <paramref name="t"/>
            is not linear with distance on the curve.
            </summary>
        </member>
        <member name="M:Mafi.Curves.CubicBezierCurveSegment3f.SampleDerivative(Mafi.Percent)">
            <summary>
            Returns derivative at given <paramref name="t"/> ∈ [0, 1]. Note that <paramref name="t"/> is not linear with
            distance on the curve.
            </summary>
        </member>
        <member name="T:Mafi.Db`2">
            <summary>
            Generic DB internally implemented using dictionary. It has protected methods for implementation of add/remove
            logic and is lockable.
            </summary>
        </member>
        <member name="P:Mafi.Db`2.IsReadonly">
            <summary>
            Whether this DB was locked and is ins readonly state.
            </summary>
        </member>
        <member name="P:Mafi.Db`2.Item(`0)">
            <summary>
            Returns requested product or throws an exception. Do not use this indexer if you are not 100% sure that the
            ID exists. Use <see cref="M:Mafi.Db`2.TryGet(`0,`1@)"/> instead.
            </summary>
            <remarks>
            Do not dare to use this indexer in try-catch instead of using <see cref="M:Mafi.Db`2.TryGet(`0,`1@)"/> method!!!
            </remarks>
        </member>
        <member name="T:Mafi.DependencyResolver">
            <summary>
            All public methods are thread safe.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.CreateEmpty">
            <summary>
            Returns empty dependency resolver. This is mainly for testing.
            </summary>
        </member>
        <member name="E:Mafi.DependencyResolver.ObjectInstantiated">
            <summary>
            Called when a new object is instantiated by the resolver. This can be due to dependency resolving or explicit
            instantiation.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolver.m_dependencyRegistrations">
            <summary>
            Dependency registrations. Key is dependency type and value is instance type. Multiple types can be registered
            under one dependency type.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolver.m_genericDependencyRegistrations">
            <summary>
            Dependency registrations for generic type definitions. Key is dependency type and value is instance type.
            Multiple types can be registered under one dependency type. Both key and items in the value array are generic
            type definitions.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolver.m_resolvedInstancesByRegisteredType">
            <summary>
            Already instantiated dependencies ready for resolving. Key is a type of dependency, usually some interface.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolver.m_resolvedInstancesByRealType">
            <summary>
            Dictionary for lookup of duplicates to avoid instantiating a dependency implementation more than once. This
            can happen if one object is registered under two different interfaces. A key is a real type of the dependency
            instance (not its interface).
            </summary>
        </member>
        <member name="P:Mafi.DependencyResolver.AllResolvedInstances">
            <summary>
            Returns all resolved objects so far.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolver.m_customResolveFuncs">
            <summary>
            Extra resolver functions that can be used for injection of dependency resolving process.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolver.m_factoryActionCache">
            <summary>
            Cached factory actions based on the argument type.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolver.m_factoryFuncCache">
            <summary>
            Cached factory functions based on the argument type.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolver.m_factoryFunc2Cache">
            <summary>
            Cached factory functions based on the argument types.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.#ctor(System.Collections.Generic.IReadOnlyDictionary{System.Type,Mafi.Collections.Lyst{System.Type}},System.Collections.Generic.IReadOnlyDictionary{System.Type,System.Type},System.Collections.Generic.IReadOnlyDictionary{System.Type,Mafi.Collections.Lyst{System.Type}},Mafi.Collections.Dict{System.Type,System.Object},Mafi.Collections.Dict{System.Type,System.Object},Mafi.Collections.Dict{System.Type,System.Int32},Mafi.Collections.ImmutableCollections.ImmutableArray{System.Func{System.Reflection.ParameterInfo,Mafi.Option{System.Object}}},System.Predicate{System.Type})">
            <summary>
            Creates dependency resolver from given data. This should be done by <see cref="T:Mafi.DependencyResolverBuilder"/>
            class. This constructor takes given instances so make sure the caller is surrendering them!
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.GetRegistrationsFor``1">
            <summary>
            Returns all implementations types registered under requested dependency type. Note that some dependencies may
            have been added as instances and won't be listed here.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.GetRegistrationsFor(System.Type)">
            <summary>
            Returns all implementation types registered under requested dependency type. Note that some dependencies may
            have been added as instances and won't be listed here.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.enterExternalCall">
             <summary>
             To properly implement locking, any code that does instantiation or resolving must follow this pattern:
            
             <code>
             checkDeadlock();
             lock (m_resolveLock) {
             	enterExternalCall();
             	try {
             		// Your code here.
             	} catch (DependencyResolverException ex) {
             		throw new DependencyResolverException("Helpful message.", ex);
             	} finally {
             		exitExternalCall();
             	}
             }
             </code>
             </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.exitExternalCall">
            <summary>
            See <see cref="M:Mafi.DependencyResolver.enterExternalCall"/> for docs on usage.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.checkDeadlock">
             <summary>
             Checks whether current thread is holding a lock.
            
             See <see cref="M:Mafi.DependencyResolver.enterExternalCall"/> for docs on usage.
             </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.GetResolvedInstance(System.Type)">
            <summary>
            Returns instance of requested type if it was already resolved. Otherwise returns None. This does no
            resolving.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.Instantiate``1">
            <summary>
            Instantiates given type and provides all necessary dependencies to its constructor. Always returns new
            instance.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.Instantiate(System.Type)">
            <summary>
            Instantiates given type and provides all necessary dependencies to its constructor. Always returns new
            instance.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.Resolve``1">
            <summary>
            Resolves given dependency type and returns its instance. It can resolve only previously registered types.
            Returned instance is always the same for the requested type - only one instance per dependency is allowed. If
            one type implements two dependencies, only one instance will be created.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.Resolve(System.Type)">
            <summary>
            Resolves given dependency type and returns its instance. It can resolve only previously registered types.
            Returned instance is always the same for the requested type - only one instance per dependency is allowed. If
            one type implements two dependencies, only one instance will be created.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.EnsureResolved(System.Type,System.Type)">
            <summary>
            Ensures that given type is resolved and cached. This will also work for types that are not registered as
            self. This does not return any value to avoid leaking classes that are not registered as self. Note that this
            works only for class types, not interfaces or special types like <see cref="T:Mafi.AllImplementationsOf`1"/>.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.TryResolve(System.Type)">
            <summary>
            Same as <see cref="M:Mafi.DependencyResolver.Resolve(System.Type)"/> but returns Option.None instead of throwing if there is no corresponding
            dependency registered. Still may throw if dependencies of the requested type are missing.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.ResolveAll``1">
            <summary>
            Resolves all implementations of given dependency type <typeparamref name="T"/>. It can resolve only
            previously registered types.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.resolveDependency(System.Type,System.Boolean,Mafi.Collections.Set{System.Type},System.Int32)">
            <summary>
            Resolves given dependency types and all its dependencies recursively. Returns singleton instance of the
            dependency within this resolver (resolving of type T will always return the same instance). If the resolving
            fails, it either returns null ( <paramref name="throwOnError"/> set to false) or throws <see
            cref="T:Mafi.DependencyResolverException"/>. This can happen when dependency is not registered or cyclic dependency
            is detected. If <paramref name="throwOnError"/> is set to true it always returns non-null.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.InvokeActionHierarchy(System.Object)">
            <summary>
            Resolves dependency of type <see cref="T:Mafi.IAction`1"/> and invokes its <see
            cref="M:Mafi.IAction`1.Invoke(`0)"/> method with given argument that produces desired result. If resolving
            fails it also tries to hierarchically resolve all actions with <c>TArg</c> as all base classes of given
            <paramref name="arg"/>. The first found action will be called.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.InvokeFactoryHierarchy``1(System.Object)">
            <summary>
            Resolves dependency of type <see cref="T:Mafi.IFactory`2"/> and invokes its <see cref="M:Mafi.IFactory`2.Create(`0)"/> method with given argument that produces desired result. The <c>TArg</c> is type of
            given argument. If resolving fails it also tries to hierarchically resolve all factories with <c>TArg</c> as
            all base classes of given <paramref name="arg"/>. The first found factory will be used for creation of the
            result.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.TryInvokeFactoryHierarchy``1(System.Object)">
            <summary>
            Resolves dependency of type <see cref="T:Mafi.IFactory`2"/> and invokes its <see cref="M:Mafi.IFactory`2.Create(`0)"/> method with given argument that produces desired result. The <c>TArg</c> is type of
            given argument. If resolving fails it also tries to hierarchically resolve all factories with <c>TArg</c> as
            all base classes of given <paramref name="arg"/>. The first found factory will be used for creation of the
            result.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.InvokeFactoryHierarchy``1(System.Object,System.Object)">
            <summary>
            Resolves dependency of type <see cref="T:Mafi.IFactory`3"/> and invokes its <see
            cref="M:Mafi.IFactory`3.Create(`0,`1)"/> method with given arguments that produces
            desired result. The <c>TArg1</c> and <c>TArg2</c> are types of given arguments. If resolving fails it also
            tries to hierarchically resolve all factories of all combinations of base classes of types <paramref
            name="arg1"/> and <paramref name="arg2"/>. The first found factory will be used for creation of the result.
            Note that first all base classes of <paramref name="arg2"/> are tested before next base class of <paramref
            name="arg1"/>.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.TryInvokeFactoryHierarchy``1(System.Object,System.Object)">
            <summary>
            Resolves dependency of type <see cref="T:Mafi.IFactory`3"/> and invokes its <see
            cref="M:Mafi.IFactory`3.Create(`0,`1)"/> method with given arguments that produces
            desired result. The <c>TArg1</c> and <c>TArg2</c> are types of given arguments. If resolving fails it also
            tries to hierarchically resolve all factories of all combinations of base classes of types <paramref
            name="arg1"/> and <paramref name="arg2"/>. The first found factory will be used for creation of the result.
            Note that first all base classes of <paramref name="arg2"/> are tested before next base class of <paramref
            name="arg1"/>.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.TryInvokeFactoryHierarchyDefault``1(System.Object,System.Object,System.Func{``0})">
            <summary>
            Resolves dependency of type <see cref="T:Mafi.IFactory`3"/> and invokes its <see
            cref="M:Mafi.IFactory`3.Create(`0,`1)"/> method with given arguments that produces
            desired result. The <c>TArg1</c> and <c>TArg2</c> are types of given arguments. If resolving fails it also
            tries to hierarchically resolve all factories of all combinations of base classes of types <paramref
            name="arg1"/> and <paramref name="arg2"/>. The first found factory will be used for creation of the result.
            Note that first all base classes of <paramref name="arg2"/> are tested before next base class of <paramref
            name="arg1"/>. If resolve fails completely than <paramref name="defaultProvider"/> is used to return a
            default value.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolver.TerminateAndClear">
            <summary>
            Clears the resolver and marks it as terminated. This also calls <see cref="M:System.IDisposable.Dispose"/>
            on all resolved objects that implement <see cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="T:Mafi.DependencyResolver.FactoryFuncKey">
            <summary>
            Key for hierarchy function factories with one arguments.
            </summary>
        </member>
        <member name="T:Mafi.DependencyResolver.FactoryFunc2Key">
            <summary>
            Key for hierarchy function factories with two arguments.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolverBuilder.m_dependencyRegistrations">
            <summary>
            Dependency registrations. Key is dependency type and value is instance type. Multiple types can be registered
            under one dependency type.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolverBuilder.m_dependencyResolvePreferences">
            <summary>
            If more than one implementation is registered under a dependency type, this may specify which one to resolve.
            By default the last one is resolved.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolverBuilder.m_genericDependencyRegistrations">
            <summary>
            Dependency registrations for generic type definitions. Key is dependency type and value is instance type.
            Multiple types can be registered under one dependency type. Both key and items in the value array are generic
            type definitions.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolverBuilder.m_instancesByRegisteredType">
            <summary>
            Already instantiated dependencies. Key is a type of dependency, usually some interface.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolverBuilder.m_instancesByRealType">
            <summary>
            Already instantiated dependencies. Key is actual type of the dependency instance.
            </summary>
        </member>
        <member name="F:Mafi.DependencyResolverBuilder.m_registeredGlobalDeps">
            <summary>
            A list of assemblies that global dependencies were already processed to prevent multi-registration caused by
            stupid programmers that try to define two mods in one assembly.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.BuildAndClear">
            <summary>
            Creates <see cref="T:Mafi.DependencyResolver"/> from registered data.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.GetRegistrations">
            <summary>
            Returns all dependency type registrations. Note that some dependencies may have been added as instances and
            won't be listed here. Does not return registrations of generic type definitions.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.GetRegisteredInstancesByDepType">
            <summary>
            Returns all registered instances by dependency type.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.GetRegisteredInstancesByRealType">
            <summary>
            Returns all registered instances by real type.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.IsAnythingRegisteredAs``1">
            <summary>
            Whether any dependency is registered under <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.IsTypeRegisteredAs``2">
            <summary>
            Whether given type <typeparamref name="TInst"/> is registered as <typeparamref name="TDep"/>.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.RegisterDependency``1">
            <summary>
            Starts dependency registration process of specified <typeparamref name="T"/>. This call does not register
            anything yet.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.RegisterDependency(System.Type)">
            <summary>
            Starts dependency registration process of given <paramref name="type"/>. This call does not register anything
            yet.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.RegisterInstance``1(``0)">
            <summary>
            Starts dependency registration process of given <paramref name="instance"/>. This call does not register
            anything yet.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.UnregisterGlobalDependency``1">
            <summary>
            Removes all registrations of given type based on registrations from <see cref="T:Mafi.GlobalDependencyAttribute"/>.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.ClearRegistrations``1">
            <summary>
            Removes all registered implementations under given <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.ClearRegistrations(System.Type)">
            <summary>
            Removes all registered types and instances under given <paramref name="dependencyType"/>.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.RegisterAllTypesImplementing``1(System.Reflection.Assembly,System.Boolean,System.Boolean)">
            <summary>
            Registers all types from given <paramref name="assembly"/> that are assignable to given <typeparamref
            name="T"/> as <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.RegisterAllGlobalDependencies(System.Reflection.Assembly,System.Predicate{System.Type})">
            <summary>
            Registers all types in given <paramref name="assembly"/> that are marked with
            <see cref="T:Mafi.GlobalDependencyAttribute"/>. <paramref name="shouldRegisterPredicate"/> can be used to filter
            registered types.
            </summary>
        </member>
        <member name="M:Mafi.DependencyResolverBuilder.tryRegisterAllGlobalDependencies(System.Type)">
            <summary>
            WARNING: This method is called via reflection by the tests because it is really hard to test parent public
            method <see cref="M:Mafi.DependencyResolverBuilder.RegisterAllGlobalDependencies(System.Reflection.Assembly,System.Predicate{System.Type})"/> that takes <see cref="T:System.Reflection.Assembly"/> as an argument.
            </summary>
        </member>
        <member name="T:Mafi.DependencyResolverBuilder.DependencyRegistrar">
            <summary>
            Helper struct for modular registration process.
            </summary>
        </member>
        <member name="T:Mafi.DependencyResolverBuilder.DependencyInstanceRegistrar`1">
            <summary>
            Helper struct for modular registration process.
            </summary>
        </member>
        <member name="F:Mafi.GenericDependencyImplementations.m_firstParamToImplementation">
            <summary>
            Simple lookup table from the first generic parameter of DependencyType that implementation of DependencyType
            has. If such a parameter is a generic parameter (IsGenericParameter == true), such implementation is in
            m_otherImplementations.
            </summary>
        </member>
        <member name="M:Mafi.GenericDependencyImplementations.argumentsMatchConstraints(System.Type,System.Type[])">
            <summary>
            Tests whether type arguments match type argument constraints given by type Constraints checking is NOT
            exhausting! Using the type parameters is MakeGenericType thus may fail with an exception. For example:
            Variance, contravariance and default constructor constraints are not checked.
            </summary>
        </member>
        <member name="F:Mafi.GenericDependencyImplementations.GenericImplementation.ImplementationType">
            <summary>
            Type that implements the dependency. It implements it through generic type instance ImplementedType.
            </summary>
        </member>
        <member name="F:Mafi.GenericDependencyImplementations.GenericImplementation.InheritedType">
            <summary>
            The type that assignable to the dependency type and implementation type implements it.
            InheritedType.GetGenericTypeDefinition() == dependencyType
            </summary>
        </member>
        <member name="T:Mafi.GlobalDependencyAttribute">
             <summary>
             Marks a class as a global dependency that will be automatically registered to dependency resolver based on given
             parameters. Marked class does not have to be public - this might be useful for registering internal class that is
             visible to public only under public interfaces or that is usable only within its assembly.
            
             The user of this attribute has no control over the registration process and order is undefined. Thus, this
             attribute should be used for dependencies that will always be registered and order is insignificant. Otherwise
             please use manual registration process that can be controlled by ifs, cycles, and order is guaranteed.
            
             All types marked by this interface are registered BEFORE manual registration is invoke.
             </summary>
        </member>
        <member name="F:Mafi.GlobalDependencyAttribute.RegistrationMode">
            <summary>
            Dependency registration modes specify how to register marked class. Note that individual flags can be
            combined.
            </summary>
        </member>
        <member name="F:Mafi.GlobalDependencyAttribute.OnlyInDebug">
            <summary>
            Whether this dependency is only registered in debug mode.
            </summary>
        </member>
        <member name="T:Mafi.NotGlobalDependencyAttribute">
            <summary>
            Marks an interface or class to not be global dependency. This is handy when class is registered under all
            interfaces but some interfaces are not intended to be dependencies. For classes this is only useful for classes
            that are for some reason automatically registered (classes implementing serialization interfaces).
            </summary>
        </member>
        <member name="T:Mafi.DependencyRegisteredManuallyAttribute">
            <summary>
            Marks class that is registered manually. This improves readability.
            </summary>
        </member>
        <member name="T:Mafi.RegistrationMode">
            <summary>
            Dependency registration modes specify how to register marked class. Note that individual flags can be combined.
            </summary>
        </member>
        <member name="F:Mafi.RegistrationMode.AsSelf">
            <summary>
            Marked class will be registered as self.
            </summary>
        </member>
        <member name="F:Mafi.RegistrationMode.AsAllInterfaces">
            <summary>
            Marked class will be registered as all implemented interfaces in its entire hierarchy.
            </summary>
        </member>
        <member name="F:Mafi.RegistrationMode.AsEverything">
            <summary>
            Marked class will be registered as self and as all implemented interfaces in its entire hierarchy.
            </summary>
        </member>
        <member name="T:Mafi.MultiDependencyAttribute">
            <summary>
            Marks an interface to be multi-dependency. Resolver will keep all all instances instead of only choosing one.
            Dependencies can be resolved with <see cref="T:Mafi.AllImplementationsOf`1"/>.
            </summary>
        </member>
        <member name="T:Mafi.IAction`1">
            <summary>
            Action that takes one argument and produces no results that can be used for automatic calling based on
            <typeparamref name="TArg"/>. See <see cref="M:Mafi.DependencyResolver.InvokeActionHierarchy(System.Object)"/> for more details.
            </summary>
            <typeparam name="TArg">Type of argument.</typeparam>
        </member>
        <member name="T:Mafi.IFactory`2">
            <summary>
            Factory method that can be used for automatic instantiation based on <typeparamref name="TArg"/>. See <see
            cref="M:Mafi.DependencyResolver.InvokeFactoryHierarchy``1(System.Object)"/> for more details.
            </summary>
            <typeparam name="TArg">Type of argument.</typeparam>
            <typeparam name="TResult">Type of result, common for all factory methods in one group.</typeparam>
        </member>
        <member name="T:Mafi.IFactory`3">
            <summary>
            Factory method that can be used for automatic instantiation based on <typeparamref name="TArg1"/> and
            <typeparamref name="TArg2"/>. See <see cref="M:Mafi.DependencyResolver.InvokeFactoryHierarchy``1(System.Object,System.Object)"/> for more details.
            </summary>
            <typeparam name="TArg1">Type of the first argument.</typeparam>
            <typeparam name="TArg2">Type of the second argument.</typeparam>
            <typeparam name="TResult">Type of result, common for all factory methods in one group.</typeparam>
        </member>
        <member name="T:Mafi.Event">
            <summary>
            Saveable event with no arguments.
            IMPORTANT: Using Event can have significant perf overhead. Read more in EventBase.
            </summary>
        </member>
        <member name="T:Mafi.Event`1">
            <summary>
            Saveable event with one argument.
            IMPORTANT: Using Event can have significant perf overhead. Read more in EventBase.
            </summary>
        </member>
        <member name="T:Mafi.Event`2">
            <summary>
            Saveable event with two arguments.
            IMPORTANT: Using Event can have significant perf overhead. Read more in EventBase.
            </summary>
        </member>
        <member name="T:Mafi.EventBase`1">
            <summary>
            Besides memory overhead, Events are extremely costly for load / init.
            Use them only for high level stuff where count of listeners / registrars is very small. 
            </summary>
        </member>
        <member name="P:Mafi.EventBase`1.Callbacks">
            <summary>
            We load callbacks only after someone requests them because resolving callbacks and
            compiling their lambda expressions is extremely expensive. It takes approx 1 sec
            to load 1-2k callbacks. It does not matter if we have 1 event with 1k callbacks
            or 1k events with 1 callback each. However, this still means that game might lag
            when some larger set of Events is fired initially - e.g. registering render managers.
            So avoid using Events for many objects.
            </summary>
        </member>
        <member name="M:Mafi.EventBase`1.Add``1(``0,`0)">
             <summary>
             Adds the given action to be invoked when the event is triggered.
            
             The given action must be a reference to a regular method that is defined on the type TOwner. You can't
             register a lambda or method that is defined on the base class (unless <paramref name="allowInherited"/>
             is set to true.
            
             Having TOwner to be declaring type of the method has 2 reasons:
             1) Checking correct input is fast
             2) When base class registers its callback there is no clash with super class in case the callbacks have the
             same name, e.g. onEnabled() { }.
             </summary>
        </member>
        <member name="M:Mafi.ArrayExtensions.IsEmpty``1(``0[])">
            <summary>
            Whether this array has zero length.
            </summary>
            <remarks>This method will take precedence to LINQ when calling on arrays - exactly what we want.</remarks>
        </member>
        <member name="M:Mafi.ArrayExtensions.IsNotEmpty``1(``0[])">
            <summary>
            Whether this array has non-zero length.
            </summary>
        </member>
        <member name="M:Mafi.ArrayExtensions.First``1(``0[])">
            <summary>
            Returns the first element of the array effectively.
            </summary>
            <remarks>This method will take precedence to LINQ when calling on arrays - exactly what we want.</remarks>
        </member>
        <member name="M:Mafi.ArrayExtensions.Last``1(``0[])">
            <summary>
            Returns the last element of the array effectively.
            </summary>
            <remarks>This method will take precedence to LINQ when calling on arrays - exactly what we want.</remarks>
        </member>
        <member name="M:Mafi.ArrayExtensions.LastOrDefault``1(``0[])">
            <summary>
            Returns the last element of the array or default value effectively.
            </summary>
            <remarks>This method will take precedence to LINQ when calling on arrays - exactly what we want.</remarks>
        </member>
        <member name="M:Mafi.ArrayExtensions.PreLast``1(``0[])">
            <summary>
            Returns second last element of the array effectively.
            </summary>
        </member>
        <member name="M:Mafi.ArrayExtensions.Concatenate``1(``0[],``0[])">
            <summary>
            Concatenates two given arrays to one.
            </summary>
        </member>
        <member name="M:Mafi.CollectionsExtensions.Last``1(System.Collections.Generic.List{``0})">
            <summary>
            Returns the last element of the list effectively.
            </summary>
            <remarks>This method will take precedence to LINQ when calling on arrays - exactly what we want.</remarks>
        </member>
        <member name="M:Mafi.CollectionsExtensions.LastOrDefault``1(System.Collections.Generic.List{``0})">
            <summary>
            Returns the last element of the list or default value effectively.
            </summary>
            <remarks>This method will take precedence to LINQ when calling on arrays - exactly what we want.</remarks>
        </member>
        <member name="T:Mafi.FatalGameException">
            <summary>
            Thrown if the game encountered a fatal exception and should be shut down.
            </summary>
        </member>
        <member name="M:Mafi.LinqExtensions.ToLyst``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts this enumerable to a new list. Consider using <see cref="M:Mafi.LinqExtensions.ToCleanLyst``1(System.Collections.Generic.IEnumerable{``0},Mafi.Collections.Lyst{``0})"/> if you already have
            instance that needs to be filled in.
            </summary>
        </member>
        <member name="M:Mafi.LinqExtensions.ToCleanLyst``1(System.Collections.Generic.IEnumerable{``0},Mafi.Collections.Lyst{``0})">
            <summary>
            Fills given list with this sequence. List is cleared before insertion. Returns the given list for ease of
            chaining.
            </summary>
        </member>
        <member name="M:Mafi.LinqExtensions.ToLyst``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            More effective than <c>.Where(predicate).ToLyst()</c>.
            </summary>
        </member>
        <member name="M:Mafi.LinqExtensions.ToLyst``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},Mafi.Collections.Lyst{``0})">
            <summary>
            More effective than <c>.Where(predicate).ToLyst()</c> and without result lyst allocation.
            </summary>
        </member>
        <member name="M:Mafi.LinqExtensions.MapArray``2(``0[],System.Func{``0,``1})">
            <summary>
            Efficient version of Select that returns new array directly without any intermediate objects. Replaces
            <c>.Select(selector).ToArray()</c>.
            </summary>
        </member>
        <member name="M:Mafi.LinqExtensions.MinMax``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Effectively finds min and max in given sequence.
            </summary>
            <exception cref="T:System.InvalidOperationException">When given sequence is empty.</exception>
        </member>
        <member name="M:Mafi.LinqExtensions.Call``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Calls given action on all elements of the sequence and returns the sequence.
            </summary>
        </member>
        <member name="M:Mafi.LinqExtensions.ToDict``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Creates a dictionary straight from key-value pair sequence.
            </summary>
        </member>
        <member name="T:Mafi.MeanAndStdDev">
            <summary>
            Represents mean and standard deviation pair.
            </summary>
        </member>
        <member name="F:Mafi.MeanAndStdDev.StdDev">
            <summary>
            Standard deviation.
            </summary>
        </member>
        <member name="M:Mafi.StreamExtensions.CopyToFast(System.IO.Stream,System.IO.Stream)">
            <summary>
            Copies contents of this stream from its current position to given stream. This is more efficient than <see
            cref="M:System.IO.Stream.CopyTo(System.IO.Stream)"/> since this is allocation-free. This method is thread safe.
            </summary>
        </member>
        <member name="M:Mafi.StringExtensions.IsEmpty(System.String)">
            <summary>
            Whether string is empty (more efficient than <see cref="!:LinqExtensions.IsEmpty&lt;T&gt;"/>
            </summary>
        </member>
        <member name="M:Mafi.StringExtensions.IsPrintableAscii(System.String)">
            <summary>
            Whether this string contains only printable ASCII characters (chars from ' ' to '~').
            </summary>
        </member>
        <member name="M:Mafi.StringExtensions.ToCleanId(System.String)">
            <summary>
            Replaces chars that are not a-A, 0-9, `_` or `-` with `_`.
            </summary>
        </member>
        <member name="M:Mafi.StringExtensions.SplitCamelCase(System.String)">
            <summary>
            Splits "Some123CamelCASEString" to ["Some", "123", "Camel", "CASE", "String"].
            </summary>
        </member>
        <member name="M:Mafi.StringExtensions.CamelCaseToSpacedSentenceCase(System.String)">
            <summary>
            Converts "Some123CamelCASEString" to "Some 123 camel cASE string".
            </summary>
        </member>
        <member name="M:Mafi.StringExtensions.CamelCaseToSpacedWords(System.String)">
            <summary>
            Converts "Some123CamelCASEString" to "some 123 camel cASE string".
            </summary>
        </member>
        <member name="M:Mafi.StringExtensions.SubstringSafe(System.String,System.Int32,System.Nullable{System.Int32})">
            <summary>
            A safe version of substring that is smart by automatically adjusting limits so that it throws.
            </summary>
        </member>
        <member name="M:Mafi.StringExtensions.SplitToLines(System.String)">
            <summary>
            Splits string to lines, handles any line endings.
            </summary>
        </member>
        <member name="M:Mafi.StringExtensions.SplitToLines(System.String,Mafi.Collections.Lyst{System.String})">
            <summary>
            Splits string to lines, handles any line endings.
            </summary>
        </member>
        <member name="T:Mafi.Numerics.AngleSlim">
            <summary>
            Angle represented as ushort where the entire range represents one rotation.
            0 is zero degrees, (ushort.MaxValue + 1) / 2 is 180 degrees, and (ushort.MaxValue + 1) is 360 or 0.
            Thanks to this representation the angle is always normalized.
            </summary>
        </member>
        <member name="T:Mafi.Numerics.Line2f">
            <summary>
            2D line represented as two points.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2f.Intersect(Mafi.Numerics.Line2f)">
            <summary>
            Returns intersection point of this line and other line. Returns null when lines are parallel.
            </summary>
            <remarks>https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Intersection_of_two_lines</remarks>
        </member>
        <member name="M:Mafi.Numerics.Line2f.DistanceSqrToLineSegment(Mafi.Vector2f)">
            <summary>
            Returns distance from the given point to a line segment specified by the <see cref="F:Mafi.Numerics.Line2f.P0"/> and <see
            cref="F:Mafi.Numerics.Line2f.P1"/>.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2f.DistanceToLine(Mafi.Vector2f)">
            <summary>
            Returns distance from the given point to a line specified by the <see cref="F:Mafi.Numerics.Line2f.P0"/> and <see cref="F:Mafi.Numerics.Line2f.P1"/>.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2f.SignedDistanceToLine(Mafi.Vector2f)">
            <summary>
            Returns signed distance to the given point. Positive distances are for points to the left of the line.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2f.GetClosestTToLineSegment(Mafi.Vector2f)">
            <summary>
            Returns <c>t</c> in range [0, 1] that represents closest point on the line to given point.
            </summary>
        </member>
        <member name="T:Mafi.Numerics.Line2i">
            <summary>
            2D line represented as two points.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2i.GetPoint(Mafi.Percent)">
            <summary>
            Returns point that is linearly interpolated between <see cref="F:Mafi.Numerics.Line2i.P0"/> and <see cref="F:Mafi.Numerics.Line2i.P1"/> based on <c>t</c>.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2i.DistanceToLineSegment(Mafi.Vector2i)">
            <summary>
            Returns distance from the given point to a line segment specified by the <see cref="F:Mafi.Numerics.Line2i.P0"/> and <see
            cref="F:Mafi.Numerics.Line2i.P1"/>.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2i.DistanceSqrToLineSegment(Mafi.Vector2i)">
            <summary>
            Returns squared distance from the given point to a line segment specified by the <see cref="F:Mafi.Numerics.Line2i.P0"/> and <see
            cref="F:Mafi.Numerics.Line2i.P1"/>. This is more efficient than <see cref="M:Mafi.Numerics.Line2i.DistanceToLineSegment(Mafi.Vector2i)"/> as it avoids square root
            computation.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2i.GetClosestTToLineSegment(Mafi.Vector2i)">
            <summary>
            Returns <c>t</c> in range [0, 1] that represents a closest point on the line segment to the given point.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2i.GetClosestTToLine(Mafi.Vector2i)">
            <summary>
            Returns <c>t</c> that represents a closest point on the (infinite) line to the given point.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line2i.IntersectionT(Mafi.Numerics.Line2i)">
            <summary>
            Returns parameter T that captures intersection point <c>P = P0 + T * Direction</c>. If lines are parallel,
            null is returned. If returned T is within [0, 1] range, the intersection point in on this line segment
            (not necessarily on <paramref name="other"/> line segment tough). Null is returned when lines are parallel.
            </summary>
            <remarks>
            https://stackoverflow.com/a/565282/1030376
            </remarks>
        </member>
        <member name="T:Mafi.Numerics.Ratio2i">
            <summary>
            Represents a ratio consisting of two positive integers.
            </summary>
        </member>
        <member name="F:Mafi.Numerics.Ratio2i.A">
            <summary>
            Always positive, except for a struct created by default constructor.
            </summary>
        </member>
        <member name="F:Mafi.Numerics.Ratio2i.B">
            <summary>
            Always positive, except for a struct created by default constructor.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Ratio2i.TryParse(System.String)">
            <summary>
            Attempts to parse Ration in format "a:b". Returns null when the parsing fails.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Ratio2i.Reduce">
            <summary>
            Returns reduced ratio.
            Example: ratio 2:2 will be reduced to 1:1, ratio 4:2 will be reduced to 2:1
            </summary>
        </member>
        <member name="T:Mafi.Numerics.Rect2i">
            <summary>
            2D rectangle that is represented as min and max points. Min is inclusive, max is exclusive.
            </summary>
        </member>
        <member name="F:Mafi.Numerics.Rect2i.Min">
            <summary>
            Inclusive min coordinate.
            </summary>
        </member>
        <member name="F:Mafi.Numerics.Rect2i.Max">
            <summary>
            Exclusive max coordinate.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Rect2i.Intersects(Mafi.Numerics.Rect2i)">
            <summary>
            Whether given rectangle intersects this rectangle.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Rect2i.Contains(Mafi.Vector2i)">
            <summary>
            Whether given point is contained in this rectangle.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Rect2i.InsideDistanceToBoundary(Mafi.Vector2i)">
            <summary>
            Returns distance from point inside of rectangle to the boundary.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Rect2i.ExtendedBy(System.Int32)">
            <summary>
            Extends this rectangle in all directions by given value.
            </summary>
        </member>
        <member name="T:Mafi.Numerics.UnitQuaternion4f">
            <summary>
            A unit Quaternion that represents an arbitrary rotation in 3D. Multiplication of quaternions is equal to
            concatenation of the represented rotations. Multiplication is not commutative as it depends which rotation is
            applied first.
            </summary>
            <remarks>
            All methods of this class guarantee to return unit quaternion if performed on a unit quaternion (+- float
            imprecision). Unfortunately it is not possible in C# to guarantee that all quaternions are unit, for example
            default struct constructor will create zero quaternion.
            </remarks>
        </member>
        <member name="F:Mafi.Numerics.UnitQuaternion4f.Identity">
            <summary>
            Identity quaternion represents rotation of 0 degrees around arbitrary axis.
            </summary>
        </member>
        <member name="F:Mafi.Numerics.UnitQuaternion4f.Xyz">
            <summary>
            Xyz components of the quaternion. This encodes the axis of the rotation but is not the axis as is. Use <see
            cref="M:Mafi.Numerics.UnitQuaternion4f.ToAxisAngle"/> to get the true angle and axis.
            </summary>
        </member>
        <member name="F:Mafi.Numerics.UnitQuaternion4f.W">
            <summary>
            W component of the quaternion. This encodes the angle but is not the angle as is. Use <see
            cref="M:Mafi.Numerics.UnitQuaternion4f.ToAxisAngle"/> to get the true angle and axis.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.#ctor(Mafi.Fix32,Mafi.Fix32,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Constructs a new unit Quaternion from x, y, z, and w components.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.#ctor(Mafi.Vector3f,Mafi.Fix32)">
            <summary>
            Constructs a new unit Quaternion from a 3D vector and w components.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.#ctor(Mafi.Vector4f)">
            <summary>
            Constructs a new unit Quaternion from a 4D vector.
            </summary>
        </member>
        <member name="P:Mafi.Numerics.UnitQuaternion4f.X">
            <summary>
            Y component of the quaternion.
            </summary>
        </member>
        <member name="P:Mafi.Numerics.UnitQuaternion4f.Y">
            <summary>
            Y component of the quaternion.
            </summary>
        </member>
        <member name="P:Mafi.Numerics.UnitQuaternion4f.Z">
            <summary>
            Z component of the quaternion.
            </summary>
        </member>
        <member name="P:Mafi.Numerics.UnitQuaternion4f.Vector4f">
            <summary>
            Returns 4D vector representing the quaternion.
            </summary>
        </member>
        <member name="P:Mafi.Numerics.UnitQuaternion4f.Length">
            <summary>
            Gets the length (magnitude) of the quaternion.
            </summary>
            <seealso cref="P:Mafi.Numerics.UnitQuaternion4f.LengthSqr"/>
        </member>
        <member name="P:Mafi.Numerics.UnitQuaternion4f.LengthSqr">
            <summary>
            Gets the square of the quaternion length (magnitude).
            </summary>
        </member>
        <member name="P:Mafi.Numerics.UnitQuaternion4f.IsNormalized">
            <summary>
            Whether this quaternion is normalized. All operations on the quaternion return normalized quaternion,
            however, there are ways how to obtain not normalized one like default struct ctor.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.TransformVector(Mafi.Vector3f)">
            <summary>
            Transforms given vector by this quaternion.
            </summary>
            <remarks>http://gamedev.stackexchange.com/questions/28395/rotating-vector3-by-a-quaternion</remarks>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.ToAxisAngle(Mafi.Vector3f@,Mafi.AngleDegrees1f@)">
            <summary>
            Convert the current quaternion to axis angle representation.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.ToAxisAngle">
            <summary>
            Convert this instance to an axis-angle representation. Axis is represented with XYZ components of the vector
            and angle is W component.
            </summary>
        </member>
        <member name="P:Mafi.Numerics.UnitQuaternion4f.Renormalized">
            <summary>
            Returns normalized version of this quaternion. If length is near 0 an identity quaternion is returned.
            Renormalization might be needed if many operations are performed in a row.
            </summary>
        </member>
        <member name="P:Mafi.Numerics.UnitQuaternion4f.Conjugated">
            <summary>
            Returns conjugate of this quaternion. Conjugate for unit quaternions is equal to inverse.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.FromAxisAngle(Mafi.Vector3f,Mafi.AngleDegrees1f)">
            <summary>
            Build a quaternion from the given axis and angle.
            </summary>
            <param name="axis">The axis to rotate about.</param>
            <param name="angle">The rotation angle in radians.</param>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.FromRotationBetweenVectors(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Returns shortest-arc rotation from vector u to vector v. The given vectors may be not normalized.
            </summary>
            <remarks>
            http://stackoverflow.com/questions/1171849/finding-quaternion-representing-the-rotation-from-one-vector-to-another
            </remarks>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.Slerp(Mafi.Numerics.UnitQuaternion4f,Mafi.Percent)">
            <summary>
            Do Spherical linear interpolation between this and given quaternions.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.op_UnaryNegation(Mafi.Numerics.UnitQuaternion4f)">
            <summary>
            Negates the quaternion by inverting the axis and angle. This does NOT change the rotation bu itself, just
            internal representation. For inverting the quaternions use <see cref="!:Conjugate"/>.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.UnitQuaternion4f.op_Multiply(Mafi.Numerics.UnitQuaternion4f,Mafi.Numerics.UnitQuaternion4f)">
            <summary>
            Multiplies two instances. This performs concatenation of the rotations represented by the unit quaternions.
            </summary>
        </member>
        <member name="T:Mafi.Numerics.Line3f">
            <summary>
            2D line represented as two points.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line3f.DistanceLineSegmentToPt(Mafi.Vector3f)">
            <summary>
            Returns distance from this line segment to the given point.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.Line3f.GetProjectionToLineSegment(Mafi.Vector3f)">
            <summary>
            Returns distance squared from this line segment to the given point.
            </summary>
        </member>
        <member name="T:Mafi.Numerics.LineRasterizer">
            <summary>
            Helper struct that allows allocation-free line rasterization on integer coordinates.
            </summary>
            <remarks>
            Uses Bresenham's Line Algorithm. Source: http://www.roguebasin.com/index.php?title=Bresenham%27s_Line_Algorithm
            </remarks>
        </member>
        <member name="M:Mafi.Numerics.LineRasterizer.#ctor(Mafi.Vector2i,Mafi.Vector2i,System.Boolean)">
            <summary>
            Creates iterator for line points. Use foreach to iterate. Iterated points are always form <paramref
            name="from"/> to <paramref name="to"/>. This method produces the same points if arguments are swapped, just
            in opposite order.
            </summary>
        </member>
        <member name="T:Mafi.Numerics.Plane">
            <summary>
            3D plane represented as normal and distance from the origin.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.RayCaster.IntersectUnitCube(Mafi.Ray3f,Mafi.Percent@,System.Int32@,Mafi.Percent@,System.Int32@)">
            <summary>
            Computes intersection wit a unit cube (cube with one corner at [0, 0, 0] and other corner at [1, 1, 1]).
            </summary>
            <remarks>Based on http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm</remarks>
        </member>
        <member name="M:Mafi.Numerics.RayCaster.IntersectAabb(Mafi.Ray3f,Mafi.Aabb,Mafi.Percent@,System.Int32@,Mafi.Percent@,System.Int32@)">
            <summary>
            Computes intersection of given <paramref name="ray"/> and axis-aligned bounding box <paramref name="aabb"/>.
            </summary>
        </member>
        <member name="M:Mafi.Numerics.RayCaster.IntersectUnitSphere(Mafi.Ray3f,Mafi.Percent@,Mafi.Percent@)">
            <summary>
            Computes intersection of given <paramref name="ray"/> and unit sphere.
            </summary>
        </member>
        <member name="T:Mafi.PathFinding.AStarPathFinderBase`1">
             <summary>
             Generic A*-based path finder. Implemented path-finding is time-sliced and bi-directional with non-reachability
             detection. Found paths might not be strictly optimal due to the double-direction search.
            
             Derived classes must implement `Node` class derived from `AStarNode` and following methods:
             * <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.GetNeighbors(`0,Mafi.Collections.Lyst{`0})"/>
             * <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.GetStepCost(`0,`0)"/>
             * <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.EstPathCost(`0,`0)"/>
            
             Note that it is up to the derived classes to manage Nodes in efficient way and do their lookups.
            
             Following methods should be used for the actual path finding:
             * <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.InitPathFinding(`0,`0,System.Boolean)"/>
             * <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.ContinuePathFinding(System.Int32@)"/>
            
             If the <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.ContinuePathFinding(System.Int32@)"/> returns <see cref="F:Mafi.PathFinding.PathFinderResult.PathFound"/>, the <see
             cref="M:Mafi.PathFinding.AStarPathFinderBase`1.ReconstructPath``1(Mafi.Collections.Lyst{``0},System.Func{`0,``0})"/> can be used to get the found path.
            
             The <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.GetExploredTiles``1(Mafi.Collections.Lyst{``0},System.Func{`0,``0})"/> method can be used for visualization/debugging purposes.
             </summary>
        </member>
        <member name="F:Mafi.PathFinding.AStarPathFinderBase`1.m_toProcessList">
            <summary>
            Visited nodes that awaiting processing.
            </summary>
        </member>
        <member name="F:Mafi.PathFinding.AStarPathFinderBase`1.m_processedList">
            <summary>
            Nodes that were already processed (all neighbors were expanded).
            </summary>
        </member>
        <member name="F:Mafi.PathFinding.AStarPathFinderBase`1.m_nodesTmp">
            <summary>
            Temporary list of nodes used for neighbors collection and initialization.
            </summary>
        </member>
        <member name="F:Mafi.PathFinding.AStarPathFinderBase`1.DistanceEstimationStartNode">
            <summary>
            Current start node.
            </summary>
        </member>
        <member name="F:Mafi.PathFinding.AStarPathFinderBase`1.DistanceEstimationGoalNode">
            <summary>
            Used for cost estimation in A*.
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarPathFinderBase`1.TotalStepsCount">
            <summary>
            Number of performed steps of the current task.
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarPathFinderBase`1.SomePathAlreadyFound">
            <summary>
            Whether some path was already found. This may be true even when
            <see cref="F:Mafi.PathFinding.PathFinderResult.StillSearching"/> was returned when
            <see cref="P:Mafi.PathFinding.AStarPathFinderBase`1.KeepSearchingToFindOptimalPath"/> was set to true. In this case, found path may not be optimal
            yet.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.GetNeighbors(`0,Mafi.Collections.Lyst{`0})">
            <summary>
            Retrieves all neighbors of the <paramref name="node"/> and saves them to <paramref name="outNeighbors"/>.
            Derived class should only return viable neighbors.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.GetStepCost(`0,`0)">
            <summary>
            Returns path cost between two neighboring nodes. The cost must be positive. The <see
            cref="F:System.Single.PositiveInfinity"/> can be returned to denote that the two nodes cannot be connected.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.getStepCost(`0,`0)">
            <summary>
            Helper function that returns result of <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.GetStepCost(`0,`0)"/> and additionally asserts returned cost.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.EstPathCost(`0,`0)">
             <summary>
             Returns total path cost estimate between two nodes.
            
             IMPORTANT: In order to find an optimal path, the heuristic must be admissible i.e. it should never
             overestimate the actual path cost. Non admissible heuristic will work too and in some cases might produce
             faster search, however, finding an optimal path is not guaranteed anymore.
             </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.GetMaxPathSteps(`0,`0)">
            <summary>
            Returns maximal path length in the number of nodes.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.estPathCost(`0,`0)">
            <summary>
            Helper function that returns result of <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.EstPathCost(`0,`0)"/> and additionally asserts returned cost.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.ResetState">
            <summary>
            Should be called before <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.InitPathFinding(`0,`0,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.InitPathFinding(`0,`0,System.Boolean)">
            <summary>
            Initializes path-finding with single goal node.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.InitPathFinding(Mafi.Collections.Lyst{`0},`0,Mafi.Collections.Lyst{`0},`0,System.Boolean)">
            <summary>
            Initializes path-finding with the given start and goal nodes.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.AddNewGoalNodes(Mafi.Collections.Lyst{`0})">
            <summary>
            Adds new goal nodes to the ongoing or failed path finding run. This can be used to extend search without
            starting completely new rerun.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.ContinuePathFinding(System.Int32@)">
            <summary>
            Runs the path-finding for given number of iterations. Returns status of the operation. Should be called again
            only when <see cref="F:Mafi.PathFinding.PathFinderResult.StillSearching"/> is returned.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.extendPath(`0,`0,Mafi.Fix32@)">
            <summary>
            Extends path-finding tree from <paramref name="currentNode"/> to <paramref name="neighborNode"/> if they are
            connectable according to the const function. Nodes that are not connectable will not be added to the <see
            cref="F:Mafi.PathFinding.AStarPathFinderBase`1.m_toProcessList"/>.
            </summary>
            <returns>True if path was found. False otherwise.</returns>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.ReconstructPath``1(Mafi.Collections.Lyst{``0},System.Func{`0,``0})">
            <summary>
            Reconstructs found path. This should be called only if <see cref="M:Mafi.PathFinding.AStarPathFinderBase`1.ContinuePathFinding(System.Int32@)"/> returned <see
            cref="F:Mafi.PathFinding.PathFinderResult.PathFound"/>.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPathFinderBase`1.GetExploredTiles``1(Mafi.Collections.Lyst{``0},System.Func{`0,``0})">
            <summary>
            Fills given list with nodes that were explored during last or current path-finding run.
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarNode`1.CurrentCost">
            <summary>
            Current minimal cost of the path to this node.
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarNode`1.ParentOnPath">
            <summary>
            Predecessor on the path from this node tot he start. It is used when reconstructing the path. Parent of the
            very first node on the path is set to itself by definition. This value is never null on a valid path.
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarNode`1.PathLength">
            <summary>
            Number of steps to get to the origin of the path (start or goal).
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarNode`1.IsVisitedFromStart">
            <summary>
            Whether this node was explored from the start node or from the goal node.
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarNode`1.IsVisited">
            <summary>
            Whether this node was visited but its neighbors were not explored yet.
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarNode`1.IsProcessed">
            <summary>
            Whether this node is processed all its neighbors have been explored.
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarNode`1.HasParent">
            <summary>
            Whether this node has parent that is not equal to itself. By our convention, start/goal nodes have parents
            set to themselves.
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarPriorityQueue`1.VisitedFromStartSetSize">
            <summary>
            Number of nodes in this list that were explored from start node ( <see
            cref="P:Mafi.PathFinding.AStarNode`1.IsVisitedFromStart"/> set to true).
            </summary>
        </member>
        <member name="P:Mafi.PathFinding.AStarPriorityQueue`1.VisitedFromGoalSetSize">
            <summary>
            Number of nodes in this list that were explored from goal nodes ( <see
            cref="P:Mafi.PathFinding.AStarNode`1.IsVisitedFromStart"/> set to false).
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPriorityQueue`1.Clear">
            <summary>
            Clears this heap and calls <see cref="M:Mafi.PathFinding.AStarNode`1.Clear"/> on all saved nodes.
            </summary>
        </member>
        <member name="M:Mafi.PathFinding.AStarPriorityQueue`1.GetElements">
            <summary>
            Returns currently stored elements as an array slice.
            </summary>
        </member>
        <member name="F:Mafi.PathFinding.PathFinderResult.Unknown">
            <summary>
            Result was not set.
            </summary>
        </member>
        <member name="F:Mafi.PathFinding.PathFinderResult.StillSearching">
            <summary>
            Path was not found yet but we can continue searching to potentially find one.
            </summary>
        </member>
        <member name="F:Mafi.PathFinding.PathFinderResult.PathFound">
            <summary>
            Path between start tile and any of the goals tiles was successfully found.
            </summary>
        </member>
        <member name="F:Mafi.PathFinding.PathFinderResult.PathDoesNotExist">
            <summary>
            Either start or goals are fully enclosed and separated, thus, a valid path does not exist.
            </summary>
        </member>
        <member name="T:Mafi.Random.Noise.LineDistanceNoise">
            <summary>
            Returns distance to a line segment as value.
            </summary>
        </member>
        <member name="T:Mafi.Random.Noise.NoiseTurbulence">
             <summary>
             Turbulence function combines base noises as a weighted sum of different frequencies. For every octave the
             frequency increases and contribution decreases exponentially.
            
             The lacunarity specifies the frequency multiplier between successive octaves. For the best results, set the
             lacunarity to a number between 1.5 and 3.5. A good value is number just under 2.0 (e.g. 1.92) to prevent regular
             overlap in noise lattices.
            
             The persistence value determines how quickly the amplitudes diminish for successive octaves. The amplitude of the
             first octave is 1.0. The amplitude of each subsequent octave is equal to the product of the previous octave's
             amplitude and the persistence value. The persistence is controls roughness.
            
             To cover all possible feature scales, the number of octaves is typically a bit less than log(terrain_width) /
             log(lacunarity). So, for a 1024 x 1024 height field, about 10 octaves are needed.
             </summary>
        </member>
        <member name="F:Mafi.Random.Noise.NoiseTurbulenceParams.Lacunarity">
            <summary>
            Frequency multiplier between successive octaves.
            </summary>
        </member>
        <member name="F:Mafi.Random.Noise.NoiseTurbulenceParams.Persistence">
            <summary>
            Scale multiplier between successive octaves.
            </summary>
        </member>
        <member name="M:Mafi.Random.Noise.NoiseTurbulenceParams.#ctor(System.Int32,Mafi.Percent,Mafi.Percent)">
            <param name="octavesCount">Number of created noise octaves.</param>
            <param name="lacunarity">Frequency multiplier between successive octaves. For the best results, set the
            this to a number between 1.5 and 3.5. A good value is number just under 2.0 (e.g. 1.92) to prevent regular
            overlap in noise lattices.</param>
            <param name="persistence">Scale multiplier between successive octaves.</param>
        </member>
        <member name="M:Mafi.Random.Noise.NoiseTurbulenceParams.GetSumPersistence">
            <summary>
            Returns total persistence over octaves count.
            </summary>
        </member>
        <member name="T:Mafi.Random.Noise.SimplexNoise2D">
            <summary>
            Simplex 2D noise. It is slightly better than Perlin noise because of less apparent structure and higher
            performance (in higher dimensions).
            </summary>
        </member>
        <member name="F:Mafi.Random.Noise.SimplexNoise2D.s_grads">
             <summary>
             Lookup table of 16 gradient vectors.
             </summary>
             <remarks>
             Generated with:
             <code>
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
            int size = 16;
            for (int i = 0; i &lt; size; ++i) {
            double x = Math.Cos(2.0 * Math.PI * i / size);
            double y = Math.Sin(2.0 * Math.PI * i / size);
            Console.WriteLine("new Vector2f({0:0.0000000}f, {1:0.0000000}f),", x, y);
            }
             </code>
             </remarks>
        </member>
        <member name="F:Mafi.Random.Noise.SimplexNoise2D.s_permTable">
            <summary>
            Permutation table for simplex noise. Taken from literature.
            </summary>
        </member>
        <member name="F:Mafi.Random.Noise.SteppedNoiseParams.StepSize">
            <summary>
            Step size, for example 0.2 will make 10 steps on noise that spans [-1, 1] range.
            </summary>
        </member>
        <member name="F:Mafi.Random.Noise.SteppedNoiseParams.StepSteepness">
            <summary>
            Step steepness 1 is no steps, values 10-20 are good for step sizes around 0.2-0.4.
            </summary>
        </member>
        <member name="P:Mafi.Random.Noise.INoise2D.MeanValue">
            <summary>
            Approximate mean value of this noise. For example, Perlin noise has mean value of 0.
            </summary>
        </member>
        <member name="P:Mafi.Random.Noise.INoise2D.Amplitude">
            <summary>
            Approximate peak amplitude of this noise. For example, Perlin noise has amplitude of 1 (+-1 around mean
            value 0).
            </summary>
        </member>
        <member name="P:Mafi.Random.Noise.INoise2D.Period">
            <summary>
            Approximate period of this noise. Noise of period `p` should have one peak/valley per `p` units.
            </summary>
        </member>
        <member name="M:Mafi.Random.Noise.INoise2D.GetValue(Mafi.Vector2f)">
            <summary>
            Returns noise value at requested point.
            </summary>
        </member>
        <member name="M:Mafi.Random.Noise.INoise2D.ReseedClone(Mafi.IRandom)">
            <summary>
            Returns a new noise that is re-seeded with given random generator. If a noise implementation is immutable
            and does not contain any source or randomness it can simply return itself.
            </summary>
        </member>
        <member name="T:Mafi.Random.Noise.IDistanceFn2D">
            <summary>
            Distance function is a special noise function that returns distance to some primitive, such as line.
            </summary>
        </member>
        <member name="M:Mafi.Random.Noise.IDistanceFn2D.GetDistanceSqr(Mafi.Vector2f)">
            <summary>
            Returns distance squared.
            </summary>
        </member>
        <member name="M:Mafi.Random.Noise.INoise2DExtensions.SaveDebugImage(Mafi.Random.Noise.INoise2D,System.String,Mafi.Vector2f,Mafi.Vector2f,System.Int32,System.Int32,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns numeric differentiation of this noise. This operation is relatively expensive as it requires four
            noise samples (three noise samples may be used instead for lower quality differentials).
            </summary>
        </member>
        <member name="P:Mafi.Random.Noise.INoise3D.MeanValue">
            <summary>
            Approximate mean value of this noise. For example, Perlin noise has mean value of 0.
            </summary>
        </member>
        <member name="P:Mafi.Random.Noise.INoise3D.Amplitude">
            <summary>
            Approximate peak amplitude of this noise. For example, Perlin noise has amplitude of 1 (+-1 around mean value
            0).
            </summary>
        </member>
        <member name="P:Mafi.Random.Noise.INoise3D.Period">
            <summary>
            Approximate period of this noise. Noise of period `p` should have one peak/valley per `p` units.
            </summary>
        </member>
        <member name="M:Mafi.Random.Noise.INoise3D.GetValue(Mafi.Vector3f)">
            <summary>
            Returns noise value at requested 3D point.
            </summary>
        </member>
        <member name="M:Mafi.Random.Noise.RidgedNoise2DExtensions.Ridged(Mafi.Random.Noise.INoise2D)">
            <summary>
            Creates a "ridged" (sharp) mountains effect.
            </summary>
        </member>
        <member name="T:Mafi.Fix32">
            <summary>
            Fixed-point 32-bit number that has 10 fractional bits. Hence, the lowest representable value is 2^-10 ~= 0.001
            and the largest value is 2^21 ~= 2M.
            </summary>
        </member>
        <member name="F:Mafi.Fix32.FRACTIONAL_BITS">
            <summary>
            Number of fractional bits. Cannot be less than 8 and must be a multiply of two.
            </summary>
        </member>
        <member name="F:Mafi.Fix32.INTEGER_BITS">
            <summary>
            Number of integer bits including sign. Must be greater than 10.
            </summary>
        </member>
        <member name="F:Mafi.Fix32.MIN_INTEGER">
            <summary>
            Minimal representable integer represented (with no fraction).
            </summary>
        </member>
        <member name="F:Mafi.Fix32.MAX_INTEGER">
            <summary>
            Maximal representable integer represented (with no fraction).
            </summary>
        </member>
        <member name="P:Mafi.Fix32.Epsilon">
            <summary>
            The minimal distance between any two consecutive Fix32 numbers. This is equal to 2^-10 = 1/1024.
            </summary>
        </member>
        <member name="P:Mafi.Fix32.EpsilonNear">
            <summary>
            Epsilon used for "near" checks.
            </summary>
        </member>
        <member name="P:Mafi.Fix32.MinValue">
            <summary>
            Smallest representable value.
            </summary>
        </member>
        <member name="P:Mafi.Fix32.MaxValue">
            <summary>
            Largest representable value.
            </summary>
        </member>
        <member name="F:Mafi.Fix32.MinIntValue">
            <summary>
            Smallest representable integer (with no fraction).
            </summary>
        </member>
        <member name="F:Mafi.Fix32.MaxIntValue">
            <summary>
            Largest representable integer (with no fraction).
            </summary>
        </member>
        <member name="F:Mafi.Fix32.RawValue">
            <summary>
            The actual stored value.
            </summary>
        </member>
        <member name="M:Mafi.Fix32.FromIntUnclamped(System.Int32)">
            <summary>
            This is faster than <see cref="M:Mafi.Fix32.FromInt(System.Int32)"/> but ca be used only when the int surely fits Fix32 range.
            </summary>
        </member>
        <member name="M:Mafi.Fix32.FromFraction(System.Int64,System.Int64)">
            <summary>
            Creates Fix32 from a fraction rounding to the closest valid Fix32 value (towards zero).
            </summary>
            <remarks>
            Arguments are of type <c>long</c> since we need this type internally, but the result of the division must be
            in the Fix32 range.
            </remarks>
        </member>
        <member name="M:Mafi.Fix32.FromIntAndFraction(System.Int32,System.Int64,System.Int64)">
            <summary>
            Created Fix32 from an integer and fraction. Keep in mind that this will be only precise when the denominator
            is a power of two less or equal to 1024. Otherwise, rounding towards zero will occur. Some arguments are of
            type <c>long</c> since we need this type internally, but the result of the division must be in the Fix32
            range.
            </summary>
        </member>
        <member name="M:Mafi.Fix32.FromFloat(System.Single)">
            <summary>
            Creates Fix32 from a double value by rounding to the nearest fraction of 1/1024.
            </summary>
        </member>
        <member name="P:Mafi.Fix32.IsInteger">
            <summary>
            Whether this number is integer and has no fractional part.
            </summary>
        </member>
        <member name="P:Mafi.Fix32.IntegerPart">
            <summary>
            Returns integer part of this value discarding any fraction. Invariant: x == x.IntegerPart +
            x.FractionalPart.
            </summary>
        </member>
        <member name="P:Mafi.Fix32.FractionalPart">
            <summary>
            Fractional part. Invariant: x == x.IntegerPart + x.FractionalPart.
            </summary>
        </member>
        <member name="M:Mafi.Fix32.ToIntFloored">
            <summary>
            Returns floored int. PERF: This is the cheapest rounding.
            </summary>
        </member>
        <member name="M:Mafi.Fix32.ToPercent">
            <summary>
            Converts given Fix32 to percent. Value 1.0 becomes 100%.
            </summary>
        </member>
        <member name="M:Mafi.Fix32.Lerp(Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Linearly interpolates integer between this and <paramref name="to"/> based on parameter <paramref
            name="t"/>. Consider using overload with scale to increase precision.
            </summary>
        </member>
        <member name="M:Mafi.Fix32.Lerp(Mafi.Fix32,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Linearly interpolates integer between this and <paramref name="to"/> based on parameter <paramref
            name="t"/>. The <paramref name="t"/> goes from 0 to <paramref name="scale"/> (inclusive).
            </summary>
        </member>
        <member name="T:Mafi.Fix64">
            <summary>
            Fixed-point 64-bit number that has 20 fractional bits. Hence, the lowest representable value is 2^-10 ~=
            0.000001 and the largest value is 2^43 ~= 8e12.
            </summary>
        </member>
        <member name="F:Mafi.Fix64.FRACTIONAL_BITS">
            <summary>
            Number of fractional bits.
            </summary>
        </member>
        <member name="F:Mafi.Fix64.MIN_INTEGER">
            <summary>
            Minimal representable integer represented (with no fraction).
            </summary>
        </member>
        <member name="F:Mafi.Fix64.MAX_INTEGER">
            <summary>
            Maximal representable integer represented (with no fraction).
            </summary>
        </member>
        <member name="P:Mafi.Fix64.Epsilon">
            <summary>
            The minimal distance between any two consecutive Fix64 numbers.
            </summary>
        </member>
        <member name="P:Mafi.Fix64.EpsilonNear">
            <summary>
            Epsilon used for "near" checks.
            </summary>
        </member>
        <member name="F:Mafi.Fix64.EpsilonFix32NearOneSqr">
            <summary>
            This is the only correct epsilon to use to check whether an original value is near 1 by checking its square.
            </summary>
        </member>
        <member name="P:Mafi.Fix64.MinValue">
            <summary>
            Smallest representable value.
            </summary>
        </member>
        <member name="P:Mafi.Fix64.MaxValue">
            <summary>
            Largest representable value.
            </summary>
        </member>
        <member name="P:Mafi.Fix64.MinIntValue">
            <summary>
            Smallest representable integer (with no fraction).
            </summary>
        </member>
        <member name="P:Mafi.Fix64.MaxIntValue">
            <summary>
            Largest representable integer (with no fraction).
            </summary>
        </member>
        <member name="F:Mafi.Fix64.RawValue">
            <summary>
            The actual stored value.
            </summary>
        </member>
        <member name="P:Mafi.Fix64.IsInteger">
            <summary>
            Whether this number is integer and has no fractional part.
            </summary>
        </member>
        <member name="P:Mafi.Fix64.IntegerPart">
            <summary>
            Returns integer part of this value discarding any fraction. Invariant: x == x.IntegerPart +
            x.FractionalPart.
            </summary>
        </member>
        <member name="P:Mafi.Fix64.FractionalPart">
            <summary>
            Fractional part. Invariant: x == x.IntegerPart + x.FractionalPart.
            </summary>
        </member>
        <member name="T:Mafi.LazyResolve`1">
            <summary>
            Simple implementation of a value that will be fetched on the first access and cached. This class is thread safe.
            </summary>
        </member>
        <member name="M:Mafi.LazyResolve`1.#ctor(`0)">
            <summary>
            Creates a lazy instance directly from a value.
            </summary>
        </member>
        <member name="M:Mafi.LazyResolve`1.#ctor(Mafi.IResolver)">
            <summary>
            Creates a lazy instance from a function that when called returns value. This function is called at most once.
            </summary>
        </member>
        <member name="M:Mafi.LazyResolve`1.#ctor">
            <summary>
            Use `SetValue` to set value later.
            </summary>
        </member>
        <member name="M:Mafi.LazyResolve`1.op_Implicit(`0)~Mafi.LazyResolve{`0}">
            <summary>
            Wraps given value in Lazy wrapper. This is mostly convenient in tests when we usually already have the values
            ready and do not need to use the lazy semantics.
            </summary>
        </member>
        <member name="T:Mafi.Localization.LocStrFormatted">
             <summary>
             Formatted localized string. This is a convenience wrapper telling you that this string may not be English
             and many string mutation operations should not be performed.
            
             This should not be saved, since change of language or fix in translation won't propagate here.
             </summary>
        </member>
        <member name="T:Mafi.Localization.LocalizationManager">
             <summary>
             Manages strings localizations.
            
             To create localized strings use helper class <see cref="T:Mafi.Localization.Loc"/>. All strings MUST be created during the
             initialization phase. Errors will be thrown for strings created later.
            
             Each string is identified by ID which must be unique and non-changing. This ID is also uses for saving/loading
             of localized strings, so that translations can be fixed for saved games.
             </summary>
        </member>
        <member name="M:Mafi.Localization.LocalizationManager.IgnoreDuplicates">
            <summary>
            When called, all duplicates will be ignored and re-registering data will override current ones.
            </summary>
        </member>
        <member name="M:Mafi.Localization.LocalizationManager.ScanForStaticLocStrFields(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            To make sure all static fields are initialized, this should be called on all loaded assemblies.
            </summary>
        </member>
        <member name="F:Mafi.Localization.LocalizationManager.LangInfo.CultureInfoId">
            <summary>
            Culture ID as used by <see cref="T:System.Globalization.CultureInfo"/>. This is also used as a key save in user preferences.
            </summary>
        </member>
        <member name="F:Mafi.Localization.LocalizationManager.LangInfo.LanguageTitle">
            <summary>
            Title of a language in already localized in the language.
            </summary>
        </member>
        <member name="F:Mafi.Localization.LocalizationManager.LangInfo.FileName">
            <summary>
            Filename including extension.
            </summary>
        </member>
        <member name="T:Mafi.Localization.Loc">
            <summary>
            Localization helper class.
            </summary>
        </member>
        <member name="M:Mafi.Localization.Loc.Str(System.String,System.String,System.String)">
            <summary>
            Creates localized string without any arguments.
            </summary>
        </member>
        <member name="M:Mafi.Localization.Loc.Str1(System.String,System.String,System.String)">
            <summary>
            Creates localized string with one argument but without plural forms, the argument does not affect
            plurality. Note that some languages may need to change other words than nouns based on numeric argument.
            </summary>
        </member>
        <member name="M:Mafi.Localization.Loc.Str2(System.String,System.String,System.String)">
            <summary>
            Creates localized string with two arguments but without plural forms, the arguments do not affect
            plurality. Note that some languages may need to change other words than nouns based on numeric argument.
            </summary>
        </member>
        <member name="M:Mafi.Localization.Loc.Str3(System.String,System.String,System.String)">
            <summary>
            Creates localized string with three arguments but without plural forms, the arguments do not affect
            plurality. Note that some languages may need to change other words than nouns based on numeric argument.
            </summary>
        </member>
        <member name="M:Mafi.Localization.Loc.Str1Plural(System.String,System.String,System.String,System.String)">
            <summary>
            Creates localized string with one argument that has plural forms. The correct plural form will be
            chosen automatically during formatting using <see cref="M:Mafi.Localization.LocStr1Plural.Format(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Mafi.Localization.LocStr">
            <summary>
            Localized string without any arguments. Serializable. Can be implicitly converted to <see cref="T:Mafi.Localization.LocStrFormatted"/>.
            </summary>
        </member>
        <member name="P:Mafi.Localization.LocStr.AsFormatted">
            <summary>
            Implicit conversion to LocStrFmt. This is very cheap operation without any allocations.
            </summary>
        </member>
        <member name="M:Mafi.Localization.LocStr.op_Implicit(Mafi.Localization.LocStr)~Mafi.Localization.LocStrFormatted">
            <summary>
            Implicit conversion to LocStrFmt. This is very cheap operation without any allocations.
            </summary>
        </member>
        <member name="T:Mafi.Localization.LocStr1">
            <summary>
            Localized string with one argument but without plural forms. Serializable if unformatted.
            </summary>
        </member>
        <member name="T:Mafi.Localization.LocStr2">
            <summary>
            Localized string with one argument but without plural forms. Serializable if unformatted.
            </summary>
        </member>
        <member name="T:Mafi.Localization.LocStr3">
            <summary>
            Localized string with three arguments but without plural forms. Serializable if unformatted.
            </summary>
        </member>
        <member name="T:Mafi.Localization.LocStr1Plural">
            <summary>
            Localized string with one argument with plural forms. Serializable if unformatted.
            </summary>
        </member>
        <member name="T:Mafi.Utils.MovingAverageHelper">
             <summary>
             Calculates moving average from the data given.
            
             The average is calculated from last windowSize points.
             </summary>
        </member>
        <member name="T:Mafi.Utils.CastTo`1">
            <summary>
            Generic casting utility.
            </summary>
            <remarks>
            Inspired from:
            https://stackoverflow.com/questions/1189144/c-sharp-non-boxing-conversion-of-generic-enum-to-int
            </remarks>
        </member>
        <member name="M:Mafi.Utils.CastTo`1.From``1(``0)">
            <summary>
            Casts <see cref="!:TSrc"/> to <see cref="!:TDst"/>. This does not cause boxing for value types.
            Useful in generic methods.
            </summary>
        </member>
        <member name="T:Mafi.Utils.FarmHash">
            <summary>
            Farmhash.Sharp is a .NET port of Google's Farmhash algorithm for calculating 32bit and 64bit non-cryptographic
            hashes. Farmhash.Sharp has great performance characteristics when calculating 64bit hashes, especially on short
            strings or a subsequence of byte arrays.
            </summary>
        </member>
        <member name="M:Mafi.Utils.FarmHash.Hash32(System.Byte*,System.Int32)">
            <summary>
            Calculates a 32bit hash from a given byte array upto a certain length
            </summary>
            <param name="s">pointer to bytes that contain at least <paramref name="len"/> bytes</param>
            <param name="length">number of bytes to consume to calculate hash</param>
            <returns>A 32bit hash</returns>
        </member>
        <member name="M:Mafi.Utils.FarmHash.Hash32(System.Byte[],System.Int32)">
            <summary>
            Calculates a 32bit hash from a given byte array upto a certain length
            </summary>
            <param name="s">Byte array to calculate the hash on</param>
            <param name="length">Number of bytes from the buffer to calculate the hash with</param>
            <returns>A 32bit hash</returns>
        </member>
        <member name="M:Mafi.Utils.FarmHash.Hash32(System.String)">
            <summary>
            Calculates a 32bit hash from a given string.
            <para>
            See the
            <see href="/articles/guides/strings.html">article on strings</see>
            for longform explanation
            </para>
            </summary>
            <param name="s">String to hash</param>
            <returns>A 32bit hash</returns>
        </member>
        <member name="T:Mafi.Utils.MemoryLogStorage">
            <summary>
            High throughput, tread safe, non-blocking logging storage.
            </summary>
        </member>
        <member name="F:Mafi.Utils.MemoryLogStorage.m_isSubscribed">
            <summary>
            Subscription tracking to avoid over-subscription.
            </summary>
        </member>
        <member name="M:Mafi.Utils.MemoryLogStorage.GetAndRemoveAllStoredLogs">
            <summary>
            Copies all stored logs to the given list in the order of their log time and clears the log storage.
            </summary>
        </member>
        <member name="T:Mafi.Percent">
            <summary>
            Represents percentage in base 10 with 5 decimal digits precision (xx.xxx%). Max values are +-2.1M%.
            </summary>
        </member>
        <member name="F:Mafi.Percent.FRAC_DEC_DIGITS">
            <summary>
            Number of fractional decimal digits.
            </summary>
        </member>
        <member name="F:Mafi.Percent.RawValue">
            <summary>
            The actual stored value.
            </summary>
        </member>
        <member name="M:Mafi.Percent.FromPercentVal(System.Int32)">
            <summary>
            Creates percentage from int that is already pre-multiplied by 100. Value 1 represents 1%.
            </summary>
        </member>
        <member name="P:Mafi.Percent.IntegerPart">
            <summary>
            Returns integer part of this value discarding any fraction. Invariant: x == x.IntegerPart +
            x.FractionalPart.
            </summary>
        </member>
        <member name="P:Mafi.Percent.FractionalPart">
            <summary>
            Fractional part. Invariant: x == x.IntegerPart + x.FractionalPart.
            </summary>
        </member>
        <member name="M:Mafi.Percent.ToDouble">
            <summary>
            Returns this number as double. This conversion is loss-less.
            </summary>
        </member>
        <member name="M:Mafi.Percent.Clamp0To100">
            <summary>
            Clamps this percentage to [0, 100] range (inclusive).
            </summary>
        </member>
        <member name="M:Mafi.Percent.InverseTo100">
            <summary>
            Returns 100% - this
            </summary>
        </member>
        <member name="M:Mafi.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            Combines two hashes in significantly better way than just XOR.
            </summary>
        </member>
        <member name="M:Mafi.Hash.Combine``2(``0,``1)">
            <summary>
            Combines two hashes in significantly better way than just XOR.
            </summary>
        </member>
        <member name="M:Mafi.Hash.Combine``3(``0,``1,``2)">
            <summary>
            Combines three hashes in significantly better way than just XOR.
            </summary>
        </member>
        <member name="M:Mafi.Hash.Combine``4(``0,``1,``2,``3)">
            <summary>
            Combines four hashes in significantly better way than just XOR.
            </summary>
        </member>
        <member name="M:Mafi.IEvent.Add``1(``0,System.Action)">
             <summary>
             Adds the given action to be invoked when the event is triggered.
            
             The given action must be a reference to a regular method that is defined on the type TOwner. Meaning that you
             can't register any lambda or method that is defined on the base class. However base class itself can register
             its own methods.
            
             Having TOwner to be declaring type of the method has 2 reasons:
             1) Checking correct input is fast
             2) When base class registers its callback there is no clash with super class in case the callbacks have the
             same name, e.g. onEnabled() { }.
             </summary>
        </member>
        <member name="M:Mafi.IEvent`1.Add``1(``0,System.Action{`0})">
             <summary>
             Adds the given action to be invoked when the event is triggered.
            
             The given action must be a reference to a regular method that is defined on the type TOwner. Meaning that you
             can't register any lambda or method that is defined on the base class. However base class itself can register
             its own methods.
            
             Having TOwner to be declaring type of the method has 2 reasons:
             1) Checking correct input is fast
             2) When base class registers its callback there is no clash with super class in case the callbacks have the
             same name, e.g. onEnabled() { }.
             </summary>
        </member>
        <member name="M:Mafi.IEvent`2.Add``1(``0,System.Action{`0,`1})">
             <summary>
             Adds the given action to be invoked when the event is triggered.
            
             The given action must be a reference to a regular method that is defined on the type TOwner. Meaning that you
             can't register any lambda or method that is defined on the base class. However base class itself can register
             its own methods.
            
             Having TOwner to be declaring type of the method has 2 reasons:
             1) Checking correct input is fast
             2) When base class registers its callback there is no clash with super class in case the callbacks have the
             same name, e.g. onEnabled() { }.
             </summary>
        </member>
        <member name="M:Mafi.TgaImageUtils.SaveTgaImage(Mafi.Rgb[],System.Int32,System.Int32,System.String)">
            <summary>
            Saves given row-major data as a TGA image. Note that the data Y axis is bottom to top.
            </summary>
        </member>
        <member name="M:Mafi.TgaImageUtils.SaveTgaImage(Mafi.Rgb[],System.Int32,System.Int32,System.IO.Stream)">
            <summary>
            Saves given row-major data as a TGA image. Note that the data Y axis is bottom to top.
            </summary>
        </member>
        <member name="T:Mafi.Lazy`1">
            <summary>
            Simple implementation of a value that will be fetched on the first access and cached. This class is thread safe.
            </summary>
        </member>
        <member name="M:Mafi.Lazy`1.#ctor(`0)">
            <summary>
            Creates a lazy instance directly from a value.
            </summary>
        </member>
        <member name="M:Mafi.Lazy`1.#ctor(System.Func{`0})">
            <summary>
            Creates a lazy instance from a function that when called returns value. This function is called at most once.
            </summary>
        </member>
        <member name="M:Mafi.Lazy`1.op_Implicit(`0)~Mafi.Lazy{`0}">
            <summary>
            Wraps given value in Lazy wrapper. This is mostly convenient in tests when we usually already have the values
            ready and do not need to use the lazy semantics.
            </summary>
        </member>
        <member name="F:Mafi.Logging.Graylog.GelfMessage.Version">
            <summary>
            GELF spec version.
            </summary>
        </member>
        <member name="F:Mafi.Logging.Graylog.GelfMessage.ShortMessage">
            <summary>
            A short descriptive message.
            </summary>
        </member>
        <member name="F:Mafi.Logging.Graylog.GelfMessage.FullMessage">
            <summary>
            Long message that can i.e. contain a backtrace; optional.
            </summary>
        </member>
        <member name="F:Mafi.Logging.Graylog.GelfMessage.Timestamp">
            <summary>
            Seconds since UNIX epoch with optional decimal places for milliseconds; SHOULD be set by client library.
            Will be set to the current timestamp (now) by the server if absent.
            </summary>
        </member>
        <member name="F:Mafi.Logging.Graylog.GelfMessage.Level">
            <summary>
            The level equal to the standard syslog levels; optional, default is 1 (ALERT).
            </summary>
        </member>
        <member name="M:Mafi.Logging.LogEntry.ToString(System.Text.StringBuilder,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Serializes this log to given string builder.
            </summary>
        </member>
        <member name="M:Mafi.Logging.LogEntry.ToString">
            <summary>
            Serializes this log to a string. Serialization does not append any new lines, however, new lines may be in
            the message itself.
            </summary>
        </member>
        <member name="T:Mafi.Logging.LogType">
            <summary>
            Log type flags. The lower the number the more severe (approximately).
            </summary>
        </member>
        <member name="T:Mafi.Log">
            <summary>
            High throughput, culture-agnostic, timezone-agnostic logging system. All messages are formatted with invariant
            culture. Please remember that date format of invariant culture is MM/dd/YYYY so format date explicitly by its
            ToString method if needed.
            </summary>
            <remarks>
            PERF: All log methods are calling the <see cref="M:Mafi.Log.onLogReceived(Mafi.Logging.LogType,System.String,System.Exception,System.Boolean,System.String)"/> method directly to avoid unnecessary function
            calls.
            </remarks>
        </member>
        <member name="E:Mafi.Log.LogReceived">
            <summary>
            Log received callback. Note that the handler have to be thread safe!
            </summary>
        </member>
        <member name="E:Mafi.Log.LogReceivedThreadStatic">
            <summary>
            Thread-static version of <see cref="E:Mafi.Log.LogReceived"/> event. Useful in tests that run in parallel.
            </summary>
        </member>
        <member name="F:Mafi.Log.s_clearPaths">
            <summary>
            Matches paths in stack trace in format "in D:\Path\To\src\Mafi\Class.cs" (or starting with "at ...") and
            removes the absolute path so that all paths are relative to the project.
            </summary>
        </member>
        <member name="M:Mafi.Log.Debug(System.String)">
            <summary>
            Logs given information message.
            </summary>
        </member>
        <member name="M:Mafi.Log.GameProgress(System.String)">
            <summary>
            Logs given information message.
            </summary>
        </member>
        <member name="M:Mafi.Log.Info(System.String)">
            <summary>
            Logs given information message.
            </summary>
        </member>
        <member name="M:Mafi.Log.InfoDebug(System.String)">
            <summary>
            Logs a debug info message.
            </summary>
        </member>
        <member name="M:Mafi.Log.Warning(System.String)">
            <summary>
            Logs given warning message.
            </summary>
        </member>
        <member name="M:Mafi.Log.Error(System.String)">
            <summary>
            Logs given error message.
            </summary>
        </member>
        <member name="M:Mafi.Log.Exception(System.Exception,System.String)">
            <summary>
            Logs given exception.
            </summary>
        </member>
        <member name="F:Mafi.MafiMath.DEFAULT_FLOAT_TOLERANCE">
            <summary>
            Any two floats around zero that differ less than this tolerance are considered "near".
            </summary>
        </member>
        <member name="F:Mafi.MafiMath.TAU_D">
            <summary>
            Tau τ = 2 π. It is the "right" constant superior to π.
            </summary>
        </member>
        <member name="F:Mafi.MafiMath.TAU">
            <summary>
            Tau τ = 2 π. It is the "right" constant superior to π.
            </summary>
        </member>
        <member name="F:Mafi.MafiMath.DEG_2_RAD">
            <summary>
            Multiplicative constant that converts degrees to radians.
            </summary>
        </member>
        <member name="F:Mafi.MafiMath.RAD_2_DEG">
            <summary>
            Multiplicative constant that converts radians to degrees to radians.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IsPowerOfTwo(System.Int32)">
            <summary>
            Whether given integer is a power of two and not zero. If you don't care about zero use more efficient <see
            cref="M:Mafi.MafiMath.IsPowerOfTwoOrZero(System.Int32)"/> function.
            PERF: Very efficient.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IsPowerOfTwoOrZero(System.Int32)">
            <summary>
            Returns true if given integer is a power of two or zero. This is more efficient than the <see
            cref="M:Mafi.MafiMath.IsPowerOfTwo(System.Int32)"/> function.
            PERF: Very efficient.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.CeilToPowerOfTwoOrZero(System.Int32)">
            <summary>
            Returns the nearest higher power of two or zero. If the number is already a power of two, it stays the same.
            </summary>
            <remarks>http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2Float</remarks>
        </member>
        <member name="M:Mafi.MafiMath.Gcd(System.Int32,System.Int32)">
            <summary>
            Computes greatest common divisor of the arguments according to Euclidean algorithm
            https://en.wikipedia.org/wiki/Euclidean_algorithm
            </summary>
            <remarks>If both parameters are zero, returns zero.</remarks>
        </member>
        <member name="M:Mafi.MafiMath.Gcd(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Computes greatest common divisor for a sequence of numbers. Create you own version not using IEnumerable for
            performance critical usage.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,System.Int64,System.Int64)">
            <summary>
            Linearly interpolates integer between <paramref name="from"/> and <paramref name="to"/> based on parameter
            <paramref name="t"/>. The <paramref name="t"/> goes from 0 to <paramref name="scale"/> (inclusive).
            </summary>
            <remarks>This function uses longs to prevent overflows.</remarks>
            <param name="from">From</param>
            <param name="to">To</param>
            <param name="t">Interpolation parameter [0, <paramref name="scale"/>)</param>
            <param name="scale">The scale of interpolation parameter.</param>
        </member>
        <member name="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,Mafi.Percent)">
            <summary>
            Linearly interpolates integer between <paramref name="from"/> and <paramref name="to"/> based on parameter
            <paramref name="t"/>. The <paramref name="t"/> goes from 0 to 1.
            </summary>
            <param name="from">From</param>
            <param name="to">To</param>
            <param name="t">Interpolation parameter [0, 1]</param>
        </member>
        <member name="M:Mafi.MafiMath.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Linearly interpolates between <paramref name="from"/> and <paramref name="to"/> based on parameter <paramref
            name="t"/>. The <paramref name="t"/> goes from 0 to 1.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.Sqerp(System.Int32,System.Int32,System.Int64,System.Int64)">
             <summary>
             "Symmetric quadratic" interpolation between two integers. Interpolates integer between <paramref
             name="from"/> and <paramref name="to"/> based on time parameter <paramref name="t"/>. The <paramref
             name="t"/> goes from 0 to <paramref name="scale"/> (inclusive).
            
             The number added to <paramref name="from"/> grows quadratically in <paramref name="t"/> until it reaches (
             <paramref name="from"/> + <paramref name="to"/>) / 2 at t = <paramref name="scale"/> / 2, after reaching
             this point it starts to grow according to reversed quadratic function with origin at ( <paramref
             name="scale"/>, <paramref name="to"/>).
            
             This means that as <paramref name="t"/> is closer to 0 or scale the interpolation function has slower growth
             with fastest growth at t = scale / 2. The speed of growth (first derivative) of the interpolation function
             is symmetrical about <paramref name="scale"/> / 2.
             </summary>
             <remarks>This function uses longs to prevent overflows.</remarks>
             <param name="from">From</param>
             <param name="to">To</param>
             <param name="t">Interpolation parameter [0, <paramref name="scale"/>]</param>
             <param name="scale">The scale of interpolation parameter.</param>
        </member>
        <member name="M:Mafi.MafiMath.RoundToSigDigits(System.Single,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Formats a float to a given number of significant digits.
            </summary>
            <example>
            <code>
            0.086 -› "0.09" (digits = 1)
            0.00030908 -› "0.00031" (digits = 2)
            1239451.0 -› "1240000" (digits = 3)
            5084611353.0 -› "5085000000" (digits = 4)
            0.00000000000000000846113537656557 -› "0.00000000000000000846114" (digits = 6)
            50.8437 -› "50.84" (digits = 4)
            50.846 -› "50.85" (digits = 4)
            990.0 -› "1000" (digits = 1)
            -5488.0 -› "-5000" (digits = 1)
            -990.0 -› "-1000" (digits = 1)
            0.0000789 -› "0.000079" (digits = 2)
            </code>
            </example>
            <remarks>https://stackoverflow.com/questions/374316/round-a-double-to-x-significant-figures</remarks>
        </member>
        <member name="M:Mafi.MafiMath.RoundToMultipleOf(System.Int32,System.Int32)">
            <summary>
            Rounds this integer value to a nearest multiple of given number.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.RoundToMultipleOf(System.Single,System.Int32)">
            <summary>
            Rounds this float value to a nearest multiple of given number.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IsNear(System.Int32,System.Int32,System.Int32)">
            <summary>
            Whether difference between <paramref name="value"/> and <paramref name="targetValue"/> is less or equal than
            <paramref name="tolerance"/>.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IsNear(System.Int64,System.Int64,System.Int64)">
            <summary>
            Whether difference between <paramref name="value"/> and <paramref name="targetValue"/> is less or equal than
            <paramref name="tolerance"/>.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IsNear(System.Single,System.Single)">
            <summary>
            Whether difference between two given values around zero is less than <see cref="F:Mafi.MafiMath.DEFAULT_FLOAT_TOLERANCE"/>.
            If the values are not around zero please use <see cref="M:Mafi.MafiMath.IsNear(System.Single,System.Single,System.Single)"/> with custom tolerance.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IsNear(System.Single,System.Single,System.Single)">
            <summary>
            Whether difference between two given values is less or equal to <paramref name="tolerance"/>.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IsNear(System.Double,System.Double,System.Double)">
            <summary>
            Whether difference between two given values is less or equal to <paramref name="tolerance"/>.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IsNearZero(System.Single)">
            <summary>
            Whether magnitude of this value is less than <see cref="F:Mafi.MafiMath.DEFAULT_FLOAT_TOLERANCE"/>.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IsFinite(System.Single)">
            <summary>
            Whether given <paramref name="value"/> is not infinity nor NaN.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.Log(System.Single)">
            <summary>
            Natural logarithm of base e.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.Log10(System.Single)">
            <summary>
            Logarithm of base 10.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.SmoothInterpolate(System.Single,System.Single,System.Single)">
            <summary>
            Smoothly interpolates between <paramref name="from"/> and <paramref name="to"/> based on <paramref
            name="t"/>. This function has zero 1st and 2nd order derivatives at t = 0 and t = 1. Parameter <paramref
            name="t"/> is expected to be within [0, 1] range.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)">
             <summary>
             Computes floored symmetrical version of modulo. Unlike C#'s remainder operator the result will be always
             non-negative like a modulo in algebra. See example for clarification.
             </summary>
             <example>
             <code>
            Modulo(4, 3) = 1  // 4 % 3 == 1
            Modulo(3, 3) = 0  // 3 % 3 == 0
            Modulo(2, 3) = 2  // 2 % 3 == 2
            Modulo(1, 3) = 1  // 1 % 3 == 1
            Modulo(0, 3) = 0  // 0 % 3 == 0
            Modulo(-1, 3) = 2  // -1 % 3 == -1
            Modulo(-2, 3) = 1  // -2 % 3 == -2
            Modulo(-3, 3) = 0  // -3 % 3 == 0
            Modulo(-4, 3) = 2  // -4 % 3 == -1
             </code>
             </example>
        </member>
        <member name="M:Mafi.MafiMath.Modulo(System.Single,System.Single)">
            <summary>
            Computes floored symmetrical version of modulo. Unlike C#'s remainder operator the result will be always
            non-negative like a modulo in algebra. See <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/> for details.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.ModuloPowerOfTwo(System.Int32,System.Int32)">
            <summary>
            Computes algebraic modulo (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>) in a very fast way assuming that the modulus
            is a power of two. It is up the caller to ensure that.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.CeilDiv(System.Int32,System.Int32)">
             <summary>
             Computes ceiled division. Unlike normal division operator in C# this always rounds up. See examples below.
             </summary>
             <example>
             <code>
            CeilDiv(5, 2) = 3    //  5 / 2 == 2
            CeilDiv(-5, 2) = -2  // -5 / 2 = -2
             </code>
             </example>
        </member>
        <member name="M:Mafi.MafiMath.FloorDiv(System.Int32,System.Int32)">
            <summary>
            Computes floor division. Unlike normal division operator in C# this always rounds down. See examples below.
            </summary>
            <example>
            <code>
            FloorDiv(5, 2) = 2    //  5 / 2 == 2
            FloorDiv(-5, 2) = -3  // -5 / 2 == -2
            </code>
            </example>
        </member>
        <member name="M:Mafi.MafiMath.FloorDivByExp2(System.Int32,System.Int32)">
            <summary>
            Computes floor division by a power of two.
            WARNING: Given divisor is the exponent of the base two.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.FloorDiv(System.Single,System.Single)">
            <summary>
            Computes floor division. Unlike normal division operator in C# this always rounds down. See <see
            cref="M:Mafi.MafiMath.FloorDiv(System.Int32,System.Int32)"/> for details.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.ArcAngle(Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Computes arc angle from <paramref name="arcLength"/> and circle <paramref name="radius"/>.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.ArcLength(Mafi.AngleDegrees1f,Mafi.Fix32)">
            <summary>
            Computes arc length from <paramref name="arcAngle"/> and circle <paramref name="radius"/>.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.SmoothStep(System.Single,System.Single,System.Single)">
            <summary>
            Smoothly interpolates value <paramref name="from"/> to value <paramref name="to"/> based on time parameter
            <paramref name="t"/> that must be in range [0, 1]. This version is unclamped as it does clamp <paramref
            name="t"/> to [0, 1] but assumes that caller ensures that.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.EaseIn(System.Single,System.Single,System.Single)">
            <summary>
            Smooth transition similar to <see cref="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,System.Int64,System.Int64)"/> that is faster at the start and slower at the end.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.EaseOut(System.Single,System.Single,System.Single)">
            <summary>
            Smooth transition similar to <see cref="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,System.Int64,System.Int64)"/> that is slower at the start and faster at the end.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.EaseInOut(System.Single,System.Single,System.Single)">
            <summary>
            Slow start and slow end with fast transition in the middle using bezier curve.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.EaseInOut(System.Single)">
            <summary>
            Slow start and slow end with fast transition in the middle using bezier curve.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.CubicInterpolate(Mafi.Fix32,Mafi.Fix32,Mafi.Fix32,Mafi.Fix32,Mafi.Percent)">
            <summary>
            Interpolates between <paramref name="v1"/> and <paramref name="v2"/> using cubic spline.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.CubicInterpolate(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Warning: Not deterministic!
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.GetFirstSetBitIndex(System.UInt32)">
            <summary>
            Returns index of set least significant bit in given number.
            Returns value 32 if this is called on zero.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.GetFirstSetBitIndex(System.UInt64)">
            <summary>
            Returns trailing zero bits count, or an index (from LSB) of the first set bit.
            Returns value 64 if this is called on zero.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.IterateCirclePoints(System.Int32,System.Action{System.Int32,System.Int32})">
             <summary>
             Iterates a discrete points on a circle with given radius. A circle with zero radius will have one point.
            
             Uses modified Midpoint algorithm: https://en.wikipedia.org/wiki/Midpoint_circle_algorithm
             </summary>
        </member>
        <member name="M:Mafi.MafiMath.TryDiv128To64(System.UInt64,System.UInt64,System.UInt64,System.UInt64@)">
            <summary>
            Divides 128 bit unsigned number represented as two ulong by 64 bit number.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.PackTwoSmallPositiveFloats(System.Single,System.Single)">
            <summary>
            Packs two positive floats in range [0, 8) to one. Each packed float has 1/256 precision.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.UnPackTwoSmallPositiveFloats(System.Single,System.Single@,System.Single@)">
            <summary>
            Unpacks float from <see cref="M:Mafi.MafiMath.PackTwoSmallPositiveFloats(System.Single,System.Single)"/>.
            </summary>
        </member>
        <member name="M:Mafi.MafiMath.FovToDistance(System.Single,System.Single)">
            <summary>
            Converts perspective camera's field of view and object size (along that FOV) to distance from the
            center of the object so that the object will span the entire FOV of the camera.
            </summary>
        </member>
        <member name="M:Mafi.Make.Kvp``2(``0,``1)">
            <summary>
            Convenience method for making pairs. This avoid the need for specifying types of <see
            cref="T:System.Collections.Generic.KeyValuePair`2"/>'s constructor explicitly.
            </summary>
        </member>
        <member name="T:Mafi.Aabb">
            <summary>
            Axis-aligned bounding box.
            </summary>
        </member>
        <member name="T:Mafi.AngleDegrees1f">
            <summary>
            Angle in degrees represented as Fix32 value.
            </summary>
            <remarks>
            We represent this value as degrees to allow exact representation of common angles like 90 or 180 degrees.
            </remarks>
        </member>
        <member name="P:Mafi.AngleDegrees1f.Radians">
            <summary>
            Returns a Fix32 value representing angle in radians.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.Normalized">
            <summary>
            Returns normalized angle that is within [0, 360) degrees.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.DirectionVector">
            <summary>
            Returns normalized direction of this angle. This is essentially unit complex number representing this angle.
            </summary>
        </member>
        <member name="M:Mafi.AngleDegrees1f.DirectionVectorOfSize(Mafi.Fix32)">
            <summary>
            More precise than scaling <see cref="P:Mafi.AngleDegrees1f.DirectionVector"/>.
            </summary>
        </member>
        <member name="M:Mafi.AngleDegrees1f.AngleTo(Mafi.AngleDegrees1f)">
            <summary>
            Returns signed shortest-arc angle to other given angle. Unlike the <c>-</c> operator this takes into
            account the singularity at 0.
            </summary>
        </member>
        <member name="M:Mafi.AngleDegrees1f.IsNear(Mafi.AngleDegrees1f)">
            <summary>
            Whether this and given values are within given tolerance. This takes into account the singularity at 0.
            </summary>
        </member>
        <member name="M:Mafi.AngleDegrees1f.IsNear(Mafi.AngleDegrees1f,Mafi.AngleDegrees1f)">
            <summary>
            Whether this and given values are within given tolerance. This takes into account the singularity at 0.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.Abs">
            <summary>
            Returns absolute value of this value.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.Sign">
            <summary>
            Returns sign of this value.
            </summary>
        </member>
        <member name="M:Mafi.AngleDegrees1f.Min(Mafi.AngleDegrees1f)">
            <summary>
            Returns minimum of this and given values.
            </summary>
        </member>
        <member name="M:Mafi.AngleDegrees1f.Max(Mafi.AngleDegrees1f)">
            <summary>
            Returns maximum of this and given values.
            </summary>
        </member>
        <member name="M:Mafi.AngleDegrees1f.Clamp(Mafi.AngleDegrees1f,Mafi.AngleDegrees1f)">
            <summary>
            Clamps this value to given minimum and maximum.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.IsZero">
            <summary>
            Whether this value is equal to zero.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.IsNotZero">
            <summary>
            Whether this value is equal to zero.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.IsPositive">
            <summary>
            Whether this value is greater than zero.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.IsNotPositive">
            <summary>
            Whether this value is less or equal to zero.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.IsNegative">
            <summary>
            Whether this value is less than zero.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.IsNotNegative">
            <summary>
            Whether this value is greater or equal to zero.
            </summary>
        </member>
        <member name="M:Mafi.AngleDegrees1f.Average(Mafi.AngleDegrees1f)">
            <summary>
            Returns average of this and given value.
            </summary>
        </member>
        <member name="P:Mafi.AngleDegrees1f.Squared">
            <summary>
            Returns squared value.
            </summary>
        </member>
        <member name="T:Mafi.ColorRgba">
            <summary>
            Compact representation of RGBA color that uses only one <see cref="T:System.UInt32"/>. This is 4x smaller than Unity's
            Color.
            </summary>
        </member>
        <member name="F:Mafi.ColorRgba.Empty">
            <summary>
            Transparent black color.
            </summary>
        </member>
        <member name="M:Mafi.ColorRgba.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates RGBA color from byte values in range 0 to 255.
            </summary>
        </member>
        <member name="M:Mafi.ColorRgba.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates RGBA color from int values in range 0 to 255. This is convenience overload so called do not need to
            cast ints to bytes.
            </summary>
        </member>
        <member name="M:Mafi.ColorRgba.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates RGBA color from RGB hex and alpha.
            </summary>
        </member>
        <member name="M:Mafi.ColorRgba.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates RGBA color form float values in range 0.0 to 1.0.
            </summary>
        </member>
        <member name="P:Mafi.ColorRgba.IsEmpty">
            <summary>
            Whether the color is empty (transparent black).
            </summary>
        </member>
        <member name="M:Mafi.ColorRgba.ToHex">
            <summary>
            Returns #RRGGBBAA string (8 hex digits).
            </summary>
        </member>
        <member name="F:Mafi.ColorRgba.Rgba">
            <summary>
            Value containing ARGB value packed as unsigned int.
            </summary>
        </member>
        <member name="M:Mafi.Direction90.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates direction from a vector. One of the directions must be zero and other not zero, however,
            magnitude of the components does not matter.
            </summary>
        </member>
        <member name="P:Mafi.Direction90.RotatedPlus90">
            <summary>
            Rotates by +90 degrees (counter-clock-wise).
            </summary>
        </member>
        <member name="P:Mafi.Direction90.RotatedMinus90">
            <summary>
            Rotates by -90 degrees (clock-wise).
            </summary>
        </member>
        <member name="P:Mafi.Direction90.Rotated180">
            <summary>
            Rotates by 180 degrees (the same as unary - operator).
            </summary>
        </member>
        <member name="M:Mafi.Direction90.ToRotation">
            <summary>
            Converts current direction to a rotation assuming that +x axis is 0 rotation.
            </summary>
        </member>
        <member name="M:Mafi.Direction90.IsParallelTo(Mafi.Direction90)">
            <summary>
            Whether this and given directions are parallel (+X and -X, etc).
            </summary>
        </member>
        <member name="M:Mafi.Direction90.op_UnaryNegation(Mafi.Direction90)">
            <summary>
            Rotates by 180 degrees.
            </summary>
        </member>
        <member name="T:Mafi.NeighborCoord">
            <summary>
            Represents von Neumann neighbor coord (set of points at a Manhattan distance of 1). Index maps points (1, 0),
            (-1, 0), (0, 1), and (0, -1) to indices 0, 1, 2, and 3 respectively. That's: 0b00 = +x, 0b01 = -x, 0b10 = +y, and
            0b11 = -y.
            </summary>
        </member>
        <member name="P:Mafi.NeighborCoord.All4Neighbors">
            <summary>
            Helper array for looping over all four neighbors.
            </summary>
        </member>
        <member name="F:Mafi.NeighborCoord.s_all4Neighbors">
            <summary>
            All four neighbors array. We can not wrap this immediately because of type initialization loop.
            </summary>
        </member>
        <member name="T:Mafi.Rotation90">
            <summary>
            Represents absolute or relative rotation in multiplies of 90 degrees.
            </summary>
        </member>
        <member name="M:Mafi.Rotation90.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates rotation given by X and Y directions. One of the directions must be zero, however, magnitude of the
            arguments does not matter.
            </summary>
        </member>
        <member name="M:Mafi.Rotation90.#ctor(Mafi.Vector2i)">
            <summary>
            Creates rotation given by direction vector. One of the components of the direction must be zero, however,
            magnitude of the components does not matter.
            </summary>
        </member>
        <member name="P:Mafi.Rotation90.RotatedPlus90">
            <summary>
            Rotates by +90 degrees (counter-clock-wise).
            </summary>
        </member>
        <member name="P:Mafi.Rotation90.RotatedMinus90">
            <summary>
            Rotates by -90 degrees (clock-wise).
            </summary>
        </member>
        <member name="P:Mafi.Rotation90.Rotated180">
            <summary>
            Rotates by 180 degrees.
            </summary>
        </member>
        <member name="P:Mafi.Rotation90.DirectionVector">
            <summary>
            Returns vector representing direction of this rotation. Only one coordinate is set to either 1 or -1.
            </summary>
        </member>
        <member name="P:Mafi.Rotation90.Angle">
            <summary>
            Returns angle in degrees that this rotation represents.
            </summary>
        </member>
        <member name="P:Mafi.Rotation90.Quaternion">
            <summary>
            Returns quaternion representation of this rotation. Identity is considered to be facing X direction and
            rotates in X-Y plane counter-clock wise. TODO: Test this shit!
            </summary>
        </member>
        <member name="M:Mafi.Rotation90.op_UnaryNegation(Mafi.Rotation90)">
            <summary>
            Rotates by 180 degrees.
            </summary>
        </member>
        <member name="M:Mafi.Rotation90.op_Addition(Mafi.Rotation90,Mafi.Rotation90)">
            <summary>
            Adds two rotations.
            </summary>
        </member>
        <member name="M:Mafi.Rotation90.op_Subtraction(Mafi.Rotation90,Mafi.Rotation90)">
            <summary>
            Subtracts the rhs rotation from the lhs rotation.
            </summary>
        </member>
        <member name="T:Mafi.Vector2f">
            <summary>
            Immutable 2D vector of Fix32 values.
            </summary>
            <remarks>
            This is partial struct and this file should contain only specific members for <see cref="T:Mafi.Vector2f"/>. All
            general members should be added to the generator T4 template.
            </remarks>
        </member>
        <member name="F:Mafi.Vector2f.Zero">
            <summary>
            Vector (0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector2f.One">
            <summary>
            Vector (1, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector2f.UnitX">
            <summary>
            Vector (1, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector2f.UnitY">
            <summary>
            Vector (0, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector2f.MinValue">
            <summary>
            Vector (Fix32.MinValue, Fix32.MinValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector2f.MaxValue">
            <summary>
            Vector (Fix32.MaxValue, Fix32.MaxValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector2f.X">
            <summary>
            The X component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector2f.Y">
            <summary>
            The Y component of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.#ctor(Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Creates new Vector2f from raw components.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.Sum">
            <summary>
            Sum of all components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.Product">
            <summary>
            Product of all components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.Length">
            <summary>
            Euclidean length of this vector.
            PERF: Expensive, uses sqrt. Consider using <see cref="P:Mafi.Vector2f.LengthSqr"/> whenever possible (when comparing
            lengths, etc.).
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.LengthSqr">
            <summary>
            Euclidean length squared of this vector.
            PERF: Cheaper than <see cref="P:Mafi.Vector2f.Length"/>, does not require expensive sqrt.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.IsZero">
            <summary>
            Whether this vector has all components equal to zero.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.IsNotZero">
            <summary>e
            Whether this vector has at least one components not equal to zero.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.SetX(Mafi.Fix32)">
            <summary>
            Returns new vector with changed X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.SetY(Mafi.Fix32)">
            <summary>
            Returns new vector with changed Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.ExtendZ(Mafi.Fix32)">
            <summary>
            Extends this vector a new component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.ExtendZw(Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Extends this vector new components.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.IncrementX">
            <summary>
            Returns new vector with incremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.IncrementY">
            <summary>
            Returns new vector with incremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.DecrementX">
            <summary>
            Returns new vector with decremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.DecrementY">
            <summary>
            Returns new vector with decremented Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.AddX(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.AddY(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.AddXy(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to all components.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.MultiplyX(Mafi.Fix32)">
            <summary>
            Returns new vector with given value multiplied with the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.MultiplyY(Mafi.Fix32)">
            <summary>
            Returns new vector with given value multiplied with the Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.ReflectX">
            <summary>
            Returns new vector with reflected X component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.ReflectY">
            <summary>
            Returns new vector with reflected Y component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.RoundedVector2i">
            <summary>
            Gets rounded Vector2i representation of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.CeiledVector2i">
            <summary>
            Gets ceiled Vector2i representation of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.FlooredVector2i">
            <summary>
            Gets floored Vector2i representation of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.OfLength(Mafi.Fix32)">
            <summary>
            Returns scaled vector to requested length. This method is faster and more intuitive than normalization
            followed by multiplication.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.IsNear(Mafi.Vector2f,Mafi.Fix32)">
            <summary>
            Tests whether corresponding components of this and given vectors are within tolerance.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.IsNormalized">
            <summary>
            Whether this vector length is (nearly) one using default epsilon <see cref="P:Mafi.Fix32.EpsilonNear"/>. Note that
            This uses efficient check of length squared without the need for square root computation.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.Normalized">
            <summary>
            Returns normalized vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Dot(Mafi.Vector2f)">
            <summary>
            Returns dot product of this vector with given vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.DistanceTo(Mafi.Vector2f)">
            <summary>
            Returns distance from this vector to the other vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.DistanceSqrTo(Mafi.Vector2f)">
            <summary>
            Returns squared distance from this vector to the other vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.Angle">
            <summary>
            Returns absolute angle of this vector. Returned angle is in range [-τ/2, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.PseudoCross(Mafi.Vector2f)">
            <summary>
            Returns pseudo-cross product of this vector with <paramref name="other"/> vector. That is, Z component of 3D
            cross product between the two vectors with Z equal to 0.
            </summary>
            <remarks>
            This operation is very efficient and has following properties:
            * v1.PseudoCross(v2) = |v1| |v2| sin(θ) where θ is signed angle from v1 to v2 ( <c>v1.AngleTo(v2)</c>).
            * Returns 0 for parallel (or anti-parallel) vectors.
            * Returns positive values when v2 is to the left of v1.
            * Returns negative values when v2 is to the right of v1.
            </remarks>
        </member>
        <member name="M:Mafi.Vector2f.Rotate(Mafi.AngleDegrees1f)">
            <summary>
            Returns rotated vector by given angle. Positive angle values represent in counter-clockwise rotation. This
            means that <c>(1, 0).Rotate(90°) == (0, 1)</c>.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Rotate(Mafi.Rotation90)">
            <summary>
            Returns rotated vector by given angle. Positive angle values represent in counter-clockwise rotation. This
            means that <c>(1, 0).Rotate(90°) == (0, 1)</c>.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Rotate(Mafi.AngleDegrees1f,Mafi.Vector2f)">
            <summary>
            Returns rotated vector by given angle around given pivot point. Positive angle values represent in
            counter-clockwise rotation. This means that <c>(1, 0).Rotate(90°) == (0, 1)</c>.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.AngleTo(Mafi.Vector2f)">
            <summary>
            Returns signed angle from this vector to <paramref name="other"/> vector. Returned angle represents how much
            this vector has to be rotated to obtain <paramref name="other"/> vector. Returned value is [-τ/2, τ/2). This
            means that <c>v1.AngleTo(v2) == -v2.AngleTo(v1)</c> and <c>v1.Rotate(v1.AngleTo(v2)) == v2</c>.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.AngleBetween(Mafi.Vector2f)">
            <summary>
            Returns absolute angle between this and <see paramref="other"/> vectors. Returned angle is in range [0, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.IsParallelTo(Mafi.Vector2f)">
            <summary>
            Whether this and <see paramref="other"/> vectors are parallel and not anti-parallel.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.IsAntiParallelTo(Mafi.Vector2f)">
            <summary>
            Whether this and <see paramref="other"/> vectors are anti-parallel and not parallel.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.IsParallelOrAntiParallelTo(Mafi.Vector2f)">
            <summary>
            Whether this and <see paramref="other"/> vectors are parallel or anti-parallel. This is more efficient than
            calling <see paramref="IsParallelTo"/> and <see paramref="IsAntiParallelTo"/>.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.LeftOrthogonalVector">
            <summary>
            Returns this vector rotated by 90 degrees to the left (counter clockwise).
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.RightOrthogonalVector">
            <summary>
            Returns this vector rotated by 90 degrees to the right (clockwise).
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Reflect(Mafi.Vector2f)">
            <summary>
            Reflection of this vector from plane specified by given normal (has to be normalized). This vector should be
            pointing to the plane and reflected vector is pointing away from the plane.
            </summary>
            <remarks>
            <code>
                        Normal vector
                      *
            this   \  |  * reflected
            vector  \ | /  vector
                 ____*|/____  reflection surface given by the normal
            </code>
            </remarks>
        </member>
        <member name="M:Mafi.Vector2f.Min(Mafi.Vector2f)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Max(Mafi.Vector2f)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.MinComponent">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.MaxComponent">
            <summary>
            Returns component-wise max of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Clamp(Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns component-wise clamp of this vectors.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.AbsValue">
            <summary>
            Returns component-wise absolute value of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.Signs">
            <summary>
            Returns component-wise sign of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Modulo(Mafi.Fix32)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Modulo(Mafi.Vector2f)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Average(Mafi.Vector2f)">
            <summary>
            Returns component-wise average of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.Lerp(Mafi.Vector2f,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Linearly interpolates between this and <paramref name="to"/> vectors based on <paramref name="t"/>.
            Interpolation parameter <paramref name="t"/> is expected to be from 0 to 1.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_Equality(Mafi.Vector2f,Mafi.Vector2f)">
            <summary>
            Exact equality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_Inequality(Mafi.Vector2f,Mafi.Vector2f)">
            <summary>
            Exact inequality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_LessThan(Mafi.Vector2f,Mafi.Vector2f)">
            <summary>
            Component-wise less-than operator. Returns true if all components of the left-hand side vector are less than
            respective components of the right-hand side vector.
            WARNING: <c>A &lt; B</c> is not equal to <c>A &gt;= B</c>. For example vectors (1, 2) and (2, 1) are not
            less-than nor greater-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_LessThanOrEqual(Mafi.Vector2f,Mafi.Vector2f)">
            <summary>
            Component-wise less-than-or-equal operator. Returns true if all components of the left-hand side vector are
            less than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &lt;= B</c> is not equal to <c>A &gt; B</c>. For example vectors (1, 2) and (2, 1) are not
            less-than-or-equal nor greater-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_GreaterThan(Mafi.Vector2f,Mafi.Vector2f)">
            <summary>
            Component-wise greater-than operator. Returns true if all components of the left-hand side vector are
            greater than respective components of the right-hand side vector.
            WARNING: <c>A &gt; B</c> is not equal to <c>A &lt;= B</c>. For example vectors (1, 2) and (2, 1) are not
            greater-than nor less-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_GreaterThanOrEqual(Mafi.Vector2f,Mafi.Vector2f)">
            <summary>
            Component-wise greater-than-or-equal operator. Returns true if all components of the left-hand side vector
            are greater than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &gt;= B</c> is not equal to <c>A &lt; B</c>. For example vectors (1, 2) and (2, 1) are not
            greater-than-or-equal nor less-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_Division(Mafi.Vector2f,Mafi.Vector2f)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_Division(Mafi.Vector2i,Mafi.Vector2f)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_Division(Mafi.Vector2f,Mafi.Vector2i)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_Modulus(Mafi.Vector2f,Mafi.Vector2f)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_Modulus(Mafi.Vector2i,Mafi.Vector2f)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2f.op_Modulus(Mafi.Vector2f,Mafi.Vector2i)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="P:Mafi.Vector2f.DotSelf">
            <summary>
            Returns dot product of this vector with itslef.
            </summary>
        </member>
        <member name="M:Mafi.Vector2fExtensions.NextVector2f(Mafi.IRandom,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.Vector2fExtensions.NextVector2f(Mafi.IRandom,Mafi.Vector2f,Mafi.Vector2f)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="T:Mafi.Vector2i">
            <summary>
            Immutable 2D int vector.
            </summary>
            <remarks>
            This is partial struct and this file should contain only specific members for <see cref="T:Mafi.Vector2i"/>. All
            general members should be added to the generator T4 template.
            </remarks>
        </member>
        <member name="F:Mafi.Vector2i.Zero">
            <summary>
            Vector (0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector2i.One">
            <summary>
            Vector (1, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector2i.UnitX">
            <summary>
            Vector (1, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector2i.UnitY">
            <summary>
            Vector (0, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector2i.MinValue">
            <summary>
            Vector (int.MinValue, int.MinValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector2i.MaxValue">
            <summary>
            Vector (int.MaxValue, int.MaxValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector2i.X">
            <summary>
            The X component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector2i.Y">
            <summary>
            The Y component of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates new Vector2i from raw components.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.Sum">
            <summary>
            Sum of all components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.Product">
            <summary>
            Product of all components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.ProductInt">
            <summary>
            Product of all components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.Length">
            <summary>
            Euclidean length of this vector.
            PERF: Expensive, uses sqrt. Consider using <see cref="P:Mafi.Vector2i.LengthSqr"/> whenever possible (when comparing
            lengths, etc.).
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.LengthInt">
            <summary>
            Approximate euclidean length of this vector as integer.
            PERF: Expensive, uses sqrt, consider using <see cref="P:Mafi.Vector2i.LengthSqr"/> whenever possible.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.LengthSqrInt">
            <summary>
            Euclidean length squared of this vector.
            PERF: Cheaper than <see cref="P:Mafi.Vector2i.Length"/>, does not require expensive sqrt.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.LengthSqr">
            <summary>
            Euclidean length squared of this vector.
            PERF: Cheaper than <see cref="P:Mafi.Vector2i.Length"/>, does not require expensive sqrt.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.IsZero">
            <summary>
            Whether this vector has all components equal to zero.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.IsNotZero">
            <summary>e
            Whether this vector has at least one components not equal to zero.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.SetX(System.Int32)">
            <summary>
            Returns new vector with changed X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.SetY(System.Int32)">
            <summary>
            Returns new vector with changed Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.ExtendZ(System.Int32)">
            <summary>
            Extends this vector a new component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.ExtendZw(System.Int32,System.Int32)">
            <summary>
            Extends this vector new components.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.IncrementX">
            <summary>
            Returns new vector with incremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.IncrementY">
            <summary>
            Returns new vector with incremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.DecrementX">
            <summary>
            Returns new vector with decremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.DecrementY">
            <summary>
            Returns new vector with decremented Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.AddX(System.Int32)">
            <summary>
            Returns new vector with given value added to the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.AddY(System.Int32)">
            <summary>
            Returns new vector with given value added to the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.AddXy(System.Int32)">
            <summary>
            Returns new vector with given value added to all components.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.MultiplyX(System.Int32)">
            <summary>
            Returns new vector with given value multiplied with the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.MultiplyY(System.Int32)">
            <summary>
            Returns new vector with given value multiplied with the Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.ReflectX">
            <summary>
            Returns new vector with reflected X component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.ReflectY">
            <summary>
            Returns new vector with reflected Y component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.Vector2f">
            <summary>
            Gets Vector2f representation of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.MulDiv(System.Int64,System.Int64)">
            <summary>
            Multiples and divides all components. This method is using long precision to prevent int32 overflows.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.OfLength(System.Int32)">
            <summary>
            Returns scaled vector to requested length. This method is more precise, faster and more intuitive than
            normalization followed by multiplication.
            WARNING: Setting length of integer vector may not produce exact requested length do to rounding error.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.IsNear(Mafi.Vector2i,System.Int32)">
            <summary>
            Whether corresponding components of this and given vectors are within given tolerance.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Dot(Mafi.Vector2i)">
            <summary>
            Returns dot product of this vector with given vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.DotInt(Mafi.Vector2i)">
            <summary>
            Returns dot product of this vector with given vector as int32. Note that result of this method may overflow
            if magnitude of any component is larger than ~30,000.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.DistanceTo(Mafi.Vector2i)">
            <summary>
            Returns distance from this vector to the other vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.DistanceSqrTo(Mafi.Vector2i)">
            <summary>
            Returns squared distance from this vector to the other vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.Angle">
            <summary>
            Returns absolute angle of this vector. Returned angle is in range [-τ/2, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.PseudoCross(Mafi.Vector2i)">
            <summary>
            Returns pseudo-cross product of this vector with <paramref name="other"/> vector. That is, Z component of 3D
            cross product between the two vectors with Z equal to 0.
            </summary>
            <remarks>
            This operation is very efficient and has following properties:
            * v1.PseudoCross(v2) = |v1| |v2| sin(θ) where θ is signed angle from v1 to v2 ( <c>v1.AngleTo(v2)</c>).
            * Returns 0 for parallel (or anti-parallel) vectors.
            * Returns positive values when v2 is to the left of v1.
            * Returns negative values when v2 is to the right of v1.
            </remarks>
        </member>
        <member name="M:Mafi.Vector2i.Rotate(Mafi.AngleDegrees1f)">
            <summary>
            Returns rotated vector by given angle. Positive angle values represent in counter-clockwise rotation. This
            means that <c>(1, 0).Rotate(90°) == (0, 1)</c>.
            WARNING: Please keep in mind that rotating integer vectors may not be precise for vectors with small
            magnitudes due to rounding errors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Rotate(Mafi.Rotation90)">
            <summary>
            Returns rotated vector by given angle. Positive angle values represent in counter-clockwise rotation. This
            means that <c>(1, 0).Rotate(90°) == (0, 1)</c>.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Rotate(Mafi.AngleDegrees1f,Mafi.Vector2i)">
            <summary>
            Returns rotated vector by given angle around given pivot point. Positive angle values represent in
            counter-clockwise rotation. This means that <c>(1, 0).Rotate(90°) == (0, 1)</c>.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.AngleTo(Mafi.Vector2i)">
            <summary>
            Returns signed angle from this vector to <paramref name="other"/> vector. Returned angle represents how much
            this vector has to be rotated to obtain <paramref name="other"/> vector. Returned value is [-τ/2, τ/2). This
            means that <c>v1.AngleTo(v2) == -v2.AngleTo(v1)</c> and <c>v1.Rotate(v1.AngleTo(v2)) == v2</c>.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.AngleBetween(Mafi.Vector2i)">
            <summary>
            Returns absolute angle between this and <see paramref="other"/> vectors. Returned angle is in range [0, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.IsParallelTo(Mafi.Vector2i)">
            <summary>
            Whether this and <see paramref="other"/> vectors are parallel and not anti-parallel.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.IsAntiParallelTo(Mafi.Vector2i)">
            <summary>
            Whether this and <see paramref="other"/> vectors are anti-parallel and not parallel.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.IsParallelOrAntiParallelTo(Mafi.Vector2i)">
            <summary>
            Whether this and <see paramref="other"/> vectors are parallel or anti-parallel. This is more efficient than
            calling <see paramref="IsParallelTo"/> and <see paramref="IsAntiParallelTo"/>.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.LeftOrthogonalVector">
            <summary>
            Returns this vector rotated by 90 degrees to the left (counter clockwise).
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.RightOrthogonalVector">
            <summary>
            Returns this vector rotated by 90 degrees to the right (clockwise).
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Min(Mafi.Vector2i)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Max(Mafi.Vector2i)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.MinComponent">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.MaxComponent">
            <summary>
            Returns component-wise max of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Clamp(System.Int32,System.Int32)">
            <summary>
            Returns component-wise clamp of this vectors.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.AbsValue">
            <summary>
            Returns component-wise absolute value of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.Signs">
            <summary>
            Returns component-wise sign of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Modulo(System.Int32)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Modulo(Mafi.Vector2i)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Average(Mafi.Vector2i)">
            <summary>
            Returns component-wise average of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Lerp(Mafi.Vector2i,System.Int64,System.Int64)">
            <summary>
            Linearly interpolates between this and <paramref name="to"/> vectors based on <paramref name="t"/>.
            Interpolation parameter <paramref name="t"/> goes from 0 to <paramref name="scale"/>.
            See <see cref="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,System.Int64,System.Int64)"/> for details.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Lerp(Mafi.Vector2i,Mafi.Vector2i,System.Int64,System.Int64)">
            <summary>
            Linearly interpolates between <paramref name="from"/> and <paramref name="to"/> vectors based on <paramref
            name="t"/>. Interpolation parameter <paramref name="t"/> goes from 0 to <paramref name="scale"/>. See <see
            cref="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,System.Int64,System.Int64)"/> for details.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.op_Equality(Mafi.Vector2i,Mafi.Vector2i)">
            <summary>
            Exact equality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.op_Inequality(Mafi.Vector2i,Mafi.Vector2i)">
            <summary>
            Exact inequality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.op_LessThan(Mafi.Vector2i,Mafi.Vector2i)">
            <summary>
            Component-wise less-than operator. Returns true if all components of the left-hand side vector are less than
            respective components of the right-hand side vector.
            WARNING: <c>A &lt; B</c> is not equal to <c>A &gt;= B</c>. For example vectors (1, 2) and (2, 1) are not
            less-than nor greater-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.op_LessThanOrEqual(Mafi.Vector2i,Mafi.Vector2i)">
            <summary>
            Component-wise less-than-or-equal operator. Returns true if all components of the left-hand side vector are
            less than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &lt;= B</c> is not equal to <c>A &gt; B</c>. For example vectors (1, 2) and (2, 1) are not
            less-than-or-equal nor greater-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.op_GreaterThan(Mafi.Vector2i,Mafi.Vector2i)">
            <summary>
            Component-wise greater-than operator. Returns true if all components of the left-hand side vector are
            greater than respective components of the right-hand side vector.
            WARNING: <c>A &gt; B</c> is not equal to <c>A &lt;= B</c>. For example vectors (1, 2) and (2, 1) are not
            greater-than nor less-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.op_GreaterThanOrEqual(Mafi.Vector2i,Mafi.Vector2i)">
            <summary>
            Component-wise greater-than-or-equal operator. Returns true if all components of the left-hand side vector
            are greater than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &gt;= B</c> is not equal to <c>A &lt; B</c>. For example vectors (1, 2) and (2, 1) are not
            greater-than-or-equal nor less-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.FloorDiv(System.Int32)">
            <summary>
            Computes floor division. Unlike normal division operator in C# this always rounds down.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.op_Division(Mafi.Vector2i,Mafi.Vector2i)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.FloorDiv(Mafi.Vector2i)">
            <summary>
            Computes floor division. Unlike normal division operator in C# this always rounds down.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.op_Modulus(Mafi.Vector2i,Mafi.Vector2i)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector2i.Rotate(Mafi.Vector2f)">
            <summary>
            Returns rotated vector by given angle represented as a complex number (2D quaternion). Given complex number
            should be normalized. The rotation angle is equal to angle represented by the complex number. Please keep in
            mind that rotating integer vectors may not be precise for vectors with small magnitudes due to rounding
            errors.
            </summary>
        </member>
        <member name="P:Mafi.Vector2i.AnglePositive">
            <summary>
            Returns absolute angle of this vector. Returned angle is in range [0, τ]. See also <see cref="P:Mafi.Vector2i.Angle"/>.
            </summary>
        </member>
        <member name="M:Mafi.Vector2iExtensions.NextVector2i(Mafi.IRandom,System.Int32,System.Int32)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.Vector2iExtensions.NextVector2i(Mafi.IRandom,Mafi.Vector2i,Mafi.Vector2i)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="T:Mafi.Vector3f">
            <summary>
            Immutable 3D float vector.
            </summary>
            <remarks>
            This is partial struct and this file should contain only specific members for <see cref="T:Mafi.Vector3f"/>. All general
            members should be added to the generator T4 template.
            </remarks>
        </member>
        <member name="F:Mafi.Vector3f.Zero">
            <summary>
            Vector (0, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector3f.One">
            <summary>
            Vector (1, 1, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector3f.UnitX">
            <summary>
            Vector (1, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector3f.UnitY">
            <summary>
            Vector (0, 1, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector3f.UnitZ">
            <summary>
            Vector (0, 0, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector3f.MinValue">
            <summary>
            Vector (Fix32.MinValue, Fix32.MinValue, Fix32.MinValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector3f.MaxValue">
            <summary>
            Vector (Fix32.MaxValue, Fix32.MaxValue, Fix32.MaxValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector3f.X">
            <summary>
            The X component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector3f.Y">
            <summary>
            The Y component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector3f.Z">
            <summary>
            The Z component of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.#ctor(Mafi.Fix32,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Creates new Vector3f from raw components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.#ctor(Mafi.Vector2f,Mafi.Fix32)">
            <summary>
            Creates new Vector3f from Vector2f and raw components.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.Xy">
            <summary>
            Gets the first two components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.Sum">
            <summary>
            Sum of all components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.Length">
            <summary>
            Euclidean length of this vector.
            PERF: Expensive, uses sqrt. Consider using <see cref="P:Mafi.Vector3f.LengthSqr"/> whenever possible (when comparing
            lengths, etc.).
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.LengthSqr">
            <summary>
            Euclidean length squared of this vector.
            PERF: Cheaper than <see cref="P:Mafi.Vector3f.Length"/>, does not require expensive sqrt.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.IsZero">
            <summary>
            Whether this vector has all components equal to zero.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.IsNotZero">
            <summary>e
            Whether this vector has at least one components not equal to zero.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.SetX(Mafi.Fix32)">
            <summary>
            Returns new vector with changed X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.SetY(Mafi.Fix32)">
            <summary>
            Returns new vector with changed Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.SetZ(Mafi.Fix32)">
            <summary>
            Returns new vector with changed Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.SetXy(Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns new vector with changed X and Y components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.SetXy(Mafi.Vector2f)">
            <summary>
            Returns new vector with changed X and Y components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.SetXyz(Mafi.Fix32,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns new vector with changed X, Y, and Z components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.ExtendW(Mafi.Fix32)">
            <summary>
            Extends this vector a new component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.IncrementX">
            <summary>
            Returns new vector with incremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.IncrementY">
            <summary>
            Returns new vector with incremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.IncrementZ">
            <summary>
            Returns new vector with incremented Z component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.DecrementX">
            <summary>
            Returns new vector with decremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.DecrementY">
            <summary>
            Returns new vector with decremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.DecrementZ">
            <summary>
            Returns new vector with decremented Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.AddX(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.AddY(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.AddZ(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to the Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.AddXyz(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to all components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.MultiplyX(Mafi.Fix32)">
            <summary>
            Returns new vector with given value multiplied with the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.MultiplyY(Mafi.Fix32)">
            <summary>
            Returns new vector with given value multiplied with the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.MultiplyZ(Mafi.Fix32)">
            <summary>
            Returns new vector with given value multiplied with the Z component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.ReflectX">
            <summary>
            Returns new vector with reflected X component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.ReflectY">
            <summary>
            Returns new vector with reflected Y component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.ReflectZ">
            <summary>
            Returns new vector with reflected Z component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.RoundedVector3i">
            <summary>
            Gets rounded Vector3i representation of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.CeiledVector3i">
            <summary>
            Gets ceiled Vector3i representation of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.FlooredVector3i">
            <summary>
            Gets floored Vector3i representation of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.OfLength(Mafi.Fix32)">
            <summary>
            Returns scaled vector to requested length. This method is faster and more intuitive than normalization
            followed by multiplication.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.IsNear(Mafi.Vector3f,Mafi.Fix32)">
            <summary>
            Tests whether corresponding components of this and given vectors are within tolerance.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.IsNormalized">
            <summary>
            Whether this vector length is (nearly) one using default epsilon <see cref="P:Mafi.Fix32.EpsilonNear"/>. Note that
            This uses efficient check of length squared without the need for square root computation.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.Normalized">
            <summary>
            Returns normalized vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.Dot(Mafi.Vector3f)">
            <summary>
            Returns dot product of this vector with given vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.DistanceTo(Mafi.Vector3f)">
            <summary>
            Returns distance from this vector to the other vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.DistanceSqrTo(Mafi.Vector3f)">
            <summary>
            Returns squared distance from this vector to the other vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.Angle">
            <summary>
            Returns absolute angle of this vector. Returned angle is in range [-τ/2, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.Cross(Mafi.Vector3f)">
            <summary>
            Returns cross product of this vector with given vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.IsParallelTo(Mafi.Vector3f)">
            <summary>
            Whether this and <see paramref="other"/> vectors are parallel and not anti-parallel.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.IsAntiParallelTo(Mafi.Vector3f)">
            <summary>
            Whether this and <see paramref="other"/> vectors are anti-parallel and not parallel.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.IsParallelOrAntiParallelTo(Mafi.Vector3f)">
            <summary>
            Whether this and <see paramref="other"/> vectors are parallel or anti-parallel. This is more efficient than
            calling <see paramref="IsParallelTo"/> and <see paramref="IsAntiParallelTo"/>.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.AngleBetween(Mafi.Vector3f)">
            <summary>
            Returns absolute angle between this and <see paramref="other"/> vectors. Returned angle is in range [0, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.AngleTo(Mafi.Vector3f)">
            <summary>
            Signed angle-to is not possible in 3D without some kind of reference vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.RotatedAroundX(Mafi.AngleDegrees1f)">
            <summary>
            Returns this vector rotated around X-axis by given amount.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.RotatedAroundY(Mafi.AngleDegrees1f)">
            <summary>
            Returns this vector rotated around Y-axis by given amount.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.RotatedAroundZ(Mafi.AngleDegrees1f)">
            <summary>
            Returns this vector rotated around Z-axis by given amount.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.rotate2dVector(Mafi.Fix32@,Mafi.Fix32@,Mafi.Rotation90)">
            <summary>
            Helper function that rotates a 2d vector, it gets as first two parameters by given angle.
            (1, 0) when rotated by 90 degrees gives (0, 1)
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.RotatedAroundX(Mafi.Rotation90)">
            <summary>
            Returns this vector rotated around X-axis by given amount.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.RotatedAroundY(Mafi.Rotation90)">
            <summary>
            Returns this vector rotated around Y-axis by given amount.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.RotatedAroundZ(Mafi.Rotation90)">
            <summary>
            Returns this vector rotated around Z-axis by given amount.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.Reflect(Mafi.Vector3f)">
            <summary>
            Reflection of this vector from plane specified by given normal (has to be normalized). This vector should be
            pointing to the plane and reflected vector is pointing away from the plane.
            </summary>
            <remarks>
            <code>
                        Normal vector
                      *
            this   \  |  * reflected
            vector  \ | /  vector
                 ____*|/____  reflection surface given by the normal
            </code>
            </remarks>
        </member>
        <member name="M:Mafi.Vector3f.Min(Mafi.Vector3f)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.Max(Mafi.Vector3f)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.MinComponent">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.MaxComponent">
            <summary>
            Returns component-wise max of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.Clamp(Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns component-wise clamp of this vectors.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.AbsValue">
            <summary>
            Returns component-wise absolute value of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.Signs">
            <summary>
            Returns component-wise sign of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.Modulo(Mafi.Fix32)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.Modulo(Mafi.Vector3f)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.Average(Mafi.Vector3f)">
            <summary>
            Returns component-wise average of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.Lerp(Mafi.Vector3f,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Linearly interpolates between this and <paramref name="to"/> vectors based on <paramref name="t"/>.
            Interpolation parameter <paramref name="t"/> is expected to be from 0 to 1.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_Equality(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Exact equality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_Inequality(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Exact inequality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_LessThan(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Component-wise less-than operator. Returns true if all components of the left-hand side vector are less than
            respective components of the right-hand side vector.
            WARNING: <c>A &lt; B</c> is not equal to <c>A &gt;= B</c>. For example vectors (1, 2, 3) and (3, 2, 1) are not
            less-than nor greater-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_LessThanOrEqual(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Component-wise less-than-or-equal operator. Returns true if all components of the left-hand side vector are
            less than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &lt;= B</c> is not equal to <c>A &gt; B</c>. For example vectors (1, 2, 3) and (3, 2, 1) are not
            less-than-or-equal nor greater-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_GreaterThan(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Component-wise greater-than operator. Returns true if all components of the left-hand side vector are
            greater than respective components of the right-hand side vector.
            WARNING: <c>A &gt; B</c> is not equal to <c>A &lt;= B</c>. For example vectors (1, 2, 3) and (3, 2, 1) are not
            greater-than nor less-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_GreaterThanOrEqual(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Component-wise greater-than-or-equal operator. Returns true if all components of the left-hand side vector
            are greater than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &gt;= B</c> is not equal to <c>A &lt; B</c>. For example vectors (1, 2, 3) and (3, 2, 1) are not
            greater-than-or-equal nor less-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_Division(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_Division(Mafi.Vector3i,Mafi.Vector3f)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_Division(Mafi.Vector3f,Mafi.Vector3i)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_Modulus(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_Modulus(Mafi.Vector3i,Mafi.Vector3f)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3f.op_Modulus(Mafi.Vector3f,Mafi.Vector3i)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="P:Mafi.Vector3f.Orthogonal">
            <summary>
            Returns an (arbitrary) orthogonal vector. Returned vector is not normalized.
            </summary>
            <remarks>
            Returned vector is a cross product with an axis corresponding to the smallest component of the vector.
            </remarks>
        </member>
        <member name="P:Mafi.Vector3f.LengthSqrAsFix32">
            <summary>
            Euclidean length squared of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3fExtensions.NextVector3f(Mafi.IRandom,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.Vector3fExtensions.NextVector3f(Mafi.IRandom,Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="T:Mafi.Vector3i">
            <summary>
            Immutable 3D int vector.
            </summary>
            <remarks>
            This is partial struct and this file should contain only specific members for <see cref="T:Mafi.Vector3i"/>. All general
            members should be added to the generator T4 template.
            </remarks>
        </member>
        <member name="F:Mafi.Vector3i.Zero">
            <summary>
            Vector (0, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector3i.One">
            <summary>
            Vector (1, 1, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector3i.UnitX">
            <summary>
            Vector (1, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector3i.UnitY">
            <summary>
            Vector (0, 1, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector3i.UnitZ">
            <summary>
            Vector (0, 0, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector3i.MinValue">
            <summary>
            Vector (int.MinValue, int.MinValue, int.MinValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector3i.MaxValue">
            <summary>
            Vector (int.MaxValue, int.MaxValue, int.MaxValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector3i.X">
            <summary>
            The X component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector3i.Y">
            <summary>
            The Y component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector3i.Z">
            <summary>
            The Z component of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates new Vector3i from raw components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.#ctor(Mafi.Vector2i,System.Int32)">
            <summary>
            Creates new Vector3i from Vector2i and raw components.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.Xy">
            <summary>
            Gets the first two components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.Sum">
            <summary>
            Sum of all components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.Length">
            <summary>
            Euclidean length of this vector.
            PERF: Expensive, uses sqrt. Consider using <see cref="P:Mafi.Vector3i.LengthSqr"/> whenever possible (when comparing
            lengths, etc.).
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.LengthInt">
            <summary>
            Approximate euclidean length of this vector as integer.
            PERF: Expensive, uses sqrt, consider using <see cref="P:Mafi.Vector3i.LengthSqr"/> whenever possible.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.LengthSqrInt">
            <summary>
            Euclidean length squared of this vector.
            PERF: Cheaper than <see cref="P:Mafi.Vector3i.Length"/>, does not require expensive sqrt.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.LengthSqr">
            <summary>
            Euclidean length squared of this vector.
            PERF: Cheaper than <see cref="P:Mafi.Vector3i.Length"/>, does not require expensive sqrt.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.IsZero">
            <summary>
            Whether this vector has all components equal to zero.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.IsNotZero">
            <summary>e
            Whether this vector has at least one components not equal to zero.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.SetX(System.Int32)">
            <summary>
            Returns new vector with changed X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.SetY(System.Int32)">
            <summary>
            Returns new vector with changed Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.SetZ(System.Int32)">
            <summary>
            Returns new vector with changed Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.SetXy(System.Int32,System.Int32)">
            <summary>
            Returns new vector with changed X and Y components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.SetXy(Mafi.Vector2i)">
            <summary>
            Returns new vector with changed X and Y components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.SetXyz(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns new vector with changed X, Y, and Z components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.ExtendW(System.Int32)">
            <summary>
            Extends this vector a new component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.IncrementX">
            <summary>
            Returns new vector with incremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.IncrementY">
            <summary>
            Returns new vector with incremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.IncrementZ">
            <summary>
            Returns new vector with incremented Z component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.DecrementX">
            <summary>
            Returns new vector with decremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.DecrementY">
            <summary>
            Returns new vector with decremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.DecrementZ">
            <summary>
            Returns new vector with decremented Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.AddX(System.Int32)">
            <summary>
            Returns new vector with given value added to the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.AddY(System.Int32)">
            <summary>
            Returns new vector with given value added to the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.AddZ(System.Int32)">
            <summary>
            Returns new vector with given value added to the Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.AddXyz(System.Int32)">
            <summary>
            Returns new vector with given value added to all components.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.MultiplyX(System.Int32)">
            <summary>
            Returns new vector with given value multiplied with the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.MultiplyY(System.Int32)">
            <summary>
            Returns new vector with given value multiplied with the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.MultiplyZ(System.Int32)">
            <summary>
            Returns new vector with given value multiplied with the Z component.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.ReflectX">
            <summary>
            Returns new vector with reflected X component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.ReflectY">
            <summary>
            Returns new vector with reflected Y component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.ReflectZ">
            <summary>
            Returns new vector with reflected Z component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.Vector3f">
            <summary>
            Gets Vector3f representation of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.MulDiv(System.Int64,System.Int64)">
            <summary>
            Multiples and divides all components. This method is using long precision to prevent int32 overflows.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.OfLength(System.Int32)">
            <summary>
            Returns scaled vector to requested length. This method is more precise, faster and more intuitive than
            normalization followed by multiplication.
            WARNING: Setting length of integer vector may not produce exact requested length do to rounding error.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.IsNear(Mafi.Vector3i,System.Int32)">
            <summary>
            Whether corresponding components of this and given vectors are within given tolerance.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Dot(Mafi.Vector3i)">
            <summary>
            Returns dot product of this vector with given vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.DotInt(Mafi.Vector3i)">
            <summary>
            Returns dot product of this vector with given vector as int32. Note that result of this method may overflow
            if magnitude of any component is larger than ~30,000.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.DistanceTo(Mafi.Vector3i)">
            <summary>
            Returns distance from this vector to the other vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.DistanceSqrTo(Mafi.Vector3i)">
            <summary>
            Returns squared distance from this vector to the other vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.Angle">
            <summary>
            Returns absolute angle of this vector. Returned angle is in range [-τ/2, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Cross(Mafi.Vector3i)">
            <summary>
            Returns cross product of this vector with given vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.IsParallelTo(Mafi.Vector3i)">
            <summary>
            Whether this and <see paramref="other"/> vectors are parallel and not anti-parallel.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.IsAntiParallelTo(Mafi.Vector3i)">
            <summary>
            Whether this and <see paramref="other"/> vectors are anti-parallel and not parallel.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.IsParallelOrAntiParallelTo(Mafi.Vector3i)">
            <summary>
            Whether this and <see paramref="other"/> vectors are parallel or anti-parallel. This is more efficient than
            calling <see paramref="IsParallelTo"/> and <see paramref="IsAntiParallelTo"/>.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.AngleBetween(Mafi.Vector3i)">
            <summary>
            Returns absolute angle between this and <see paramref="other"/> vectors. Returned angle is in range [0, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.AngleTo(Mafi.Vector3i)">
            <summary>
            Signed angle-to is not possible in 3D without some kind of reference vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.RotatedAroundX(Mafi.AngleDegrees1f)">
            <summary>
            Returns this vector rotated around X-axis by given amount.
            WARNING: Please keep in mind that rotating integer vectors may not be precise for vectors with small
            magnitudes due to rounding errors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.RotatedAroundY(Mafi.AngleDegrees1f)">
            <summary>
            Returns this vector rotated around Y-axis by given amount.
            WARNING: Please keep in mind that rotating integer vectors may not be precise for vectors with small
            magnitudes due to rounding errors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.RotatedAroundZ(Mafi.AngleDegrees1f)">
            <summary>
            Returns this vector rotated around Z-axis by given amount.
            WARNING: Please keep in mind that rotating integer vectors may not be precise for vectors with small
            magnitudes due to rounding errors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.rotate2dVector(System.Int32@,System.Int32@,Mafi.Rotation90)">
            <summary>
            Helper function that rotates a 2d vector, it gets as first two parameters by given angle.
            (1, 0) when rotated by 90 degrees gives (0, 1)
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.RotatedAroundX(Mafi.Rotation90)">
            <summary>
            Returns this vector rotated around X-axis by given amount.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.RotatedAroundY(Mafi.Rotation90)">
            <summary>
            Returns this vector rotated around Y-axis by given amount.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.RotatedAroundZ(Mafi.Rotation90)">
            <summary>
            Returns this vector rotated around Z-axis by given amount.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Min(Mafi.Vector3i)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Max(Mafi.Vector3i)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.MinComponent">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.MaxComponent">
            <summary>
            Returns component-wise max of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Clamp(System.Int32,System.Int32)">
            <summary>
            Returns component-wise clamp of this vectors.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.AbsValue">
            <summary>
            Returns component-wise absolute value of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.Signs">
            <summary>
            Returns component-wise sign of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Modulo(System.Int32)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Modulo(Mafi.Vector3i)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Average(Mafi.Vector3i)">
            <summary>
            Returns component-wise average of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Lerp(Mafi.Vector3i,System.Int64,System.Int64)">
            <summary>
            Linearly interpolates between this and <paramref name="to"/> vectors based on <paramref name="t"/>.
            Interpolation parameter <paramref name="t"/> goes from 0 to <paramref name="scale"/>.
            See <see cref="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,System.Int64,System.Int64)"/> for details.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.Lerp(Mafi.Vector3i,Mafi.Vector3i,System.Int64,System.Int64)">
            <summary>
            Linearly interpolates between <paramref name="from"/> and <paramref name="to"/> vectors based on <paramref
            name="t"/>. Interpolation parameter <paramref name="t"/> goes from 0 to <paramref name="scale"/>. See <see
            cref="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,System.Int64,System.Int64)"/> for details.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.op_Equality(Mafi.Vector3i,Mafi.Vector3i)">
            <summary>
            Exact equality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.op_Inequality(Mafi.Vector3i,Mafi.Vector3i)">
            <summary>
            Exact inequality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.op_LessThan(Mafi.Vector3i,Mafi.Vector3i)">
            <summary>
            Component-wise less-than operator. Returns true if all components of the left-hand side vector are less than
            respective components of the right-hand side vector.
            WARNING: <c>A &lt; B</c> is not equal to <c>A &gt;= B</c>. For example vectors (1, 2, 3) and (3, 2, 1) are not
            less-than nor greater-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.op_LessThanOrEqual(Mafi.Vector3i,Mafi.Vector3i)">
            <summary>
            Component-wise less-than-or-equal operator. Returns true if all components of the left-hand side vector are
            less than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &lt;= B</c> is not equal to <c>A &gt; B</c>. For example vectors (1, 2, 3) and (3, 2, 1) are not
            less-than-or-equal nor greater-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.op_GreaterThan(Mafi.Vector3i,Mafi.Vector3i)">
            <summary>
            Component-wise greater-than operator. Returns true if all components of the left-hand side vector are
            greater than respective components of the right-hand side vector.
            WARNING: <c>A &gt; B</c> is not equal to <c>A &lt;= B</c>. For example vectors (1, 2, 3) and (3, 2, 1) are not
            greater-than nor less-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.op_GreaterThanOrEqual(Mafi.Vector3i,Mafi.Vector3i)">
            <summary>
            Component-wise greater-than-or-equal operator. Returns true if all components of the left-hand side vector
            are greater than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &gt;= B</c> is not equal to <c>A &lt; B</c>. For example vectors (1, 2, 3) and (3, 2, 1) are not
            greater-than-or-equal nor less-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.FloorDiv(System.Int32)">
            <summary>
            Computes floor division. Unlike normal division operator in C# this always rounds down.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.op_Division(Mafi.Vector3i,Mafi.Vector3i)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.FloorDiv(Mafi.Vector3i)">
            <summary>
            Computes floor division. Unlike normal division operator in C# this always rounds down.
            </summary>
        </member>
        <member name="M:Mafi.Vector3i.op_Modulus(Mafi.Vector3i,Mafi.Vector3i)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="P:Mafi.Vector3i.SortedComponents">
            <summary>
            Returns vector with sorted components ascending order using 2-3 ifs.
            </summary>
        </member>
        <member name="M:Mafi.Vector3iExtensions.NextVector3i(Mafi.IRandom,System.Int32,System.Int32)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.Vector3iExtensions.NextVector3i(Mafi.IRandom,Mafi.Vector3i,Mafi.Vector3i)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="T:Mafi.Vector4f">
            <summary>
            Immutable 4D float vector.
            </summary>
            <remarks>
            This is partial struct and this file should contain only specific members for <see cref="T:Mafi.Vector4f"/>. All general
            members should be added to the generator T4 template.
            </remarks>
        </member>
        <member name="F:Mafi.Vector4f.Zero">
            <summary>
            Vector (0, 0, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.One">
            <summary>
            Vector (1, 1, 1, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.UnitX">
            <summary>
            Vector (1, 0, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.UnitY">
            <summary>
            Vector (0, 1, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.UnitZ">
            <summary>
            Vector (0, 0, 1, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.UnitW">
            <summary>
            Vector (0, 0, 0, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.MinValue">
            <summary>
            Vector (Fix32.MinValue, Fix32.MinValue, Fix32.MinValue, Fix32.MinValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.MaxValue">
            <summary>
            Vector (Fix32.MaxValue, Fix32.MaxValue, Fix32.MaxValue, Fix32.MaxValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.X">
            <summary>
            The X component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.Y">
            <summary>
            The Y component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.Z">
            <summary>
            The Z component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector4f.W">
            <summary>
            The W component of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.#ctor(Mafi.Fix32,Mafi.Fix32,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Creates new Vector4f from raw components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.#ctor(Mafi.Vector2f,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Creates new Vector4f from Vector2f and raw components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.#ctor(Mafi.Vector3f,Mafi.Fix32)">
            <summary>
            Creates new Vector4f from Vector3f and raw components.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.Xy">
            <summary>
            Gets the first two components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.Xyz">
            <summary>
            Gets the first three components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.Sum">
            <summary>
            Sum of all components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.Length">
            <summary>
            Euclidean length of this vector.
            PERF: Expensive, uses sqrt. Consider using <see cref="P:Mafi.Vector4f.LengthSqr"/> whenever possible (when comparing
            lengths, etc.).
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.LengthSqr">
            <summary>
            Euclidean length squared of this vector.
            PERF: Cheaper than <see cref="P:Mafi.Vector4f.Length"/>, does not require expensive sqrt.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.IsZero">
            <summary>
            Whether this vector has all components equal to zero.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.IsNotZero">
            <summary>e
            Whether this vector has at least one components not equal to zero.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.SetX(Mafi.Fix32)">
            <summary>
            Returns new vector with changed X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.SetY(Mafi.Fix32)">
            <summary>
            Returns new vector with changed Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.SetZ(Mafi.Fix32)">
            <summary>
            Returns new vector with changed Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.SetW(Mafi.Fix32)">
            <summary>
            Returns new vector with changed W component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.SetXy(Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns new vector with changed X and Y components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.SetXy(Mafi.Vector2f)">
            <summary>
            Returns new vector with changed X and Y components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.SetXyz(Mafi.Fix32,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns new vector with changed X, Y, and Z components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.SetXyz(Mafi.Vector3f)">
            <summary>
            Returns new vector with changed X, Y, and Z components.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.IncrementX">
            <summary>
            Returns new vector with incremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.IncrementY">
            <summary>
            Returns new vector with incremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.IncrementZ">
            <summary>
            Returns new vector with incremented Z component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.IncrementW">
            <summary>
            Returns new vector with incremented W component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.DecrementX">
            <summary>
            Returns new vector with decremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.DecrementY">
            <summary>
            Returns new vector with decremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.DecrementZ">
            <summary>
            Returns new vector with decremented Z component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.DecrementW">
            <summary>
            Returns new vector with decremented W component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.AddX(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.AddY(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.AddZ(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to the Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.AddW(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to the W component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.AddXyzw(Mafi.Fix32)">
            <summary>
            Returns new vector with given value added to all components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.MultiplyX(Mafi.Fix32)">
            <summary>
            Returns new vector with given value multiplied with the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.MultiplyY(Mafi.Fix32)">
            <summary>
            Returns new vector with given value multiplied with the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.MultiplyZ(Mafi.Fix32)">
            <summary>
            Returns new vector with given value multiplied with the Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.MultiplyW(Mafi.Fix32)">
            <summary>
            Returns new vector with given value multiplied with the W component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.ReflectX">
            <summary>
            Returns new vector with reflected X component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.ReflectY">
            <summary>
            Returns new vector with reflected Y component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.ReflectZ">
            <summary>
            Returns new vector with reflected Z component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.ReflectW">
            <summary>
            Returns new vector with reflected W component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.RoundedVector4i">
            <summary>
            Gets rounded Vector4i representation of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.CeiledVector4i">
            <summary>
            Gets ceiled Vector4i representation of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.FlooredVector4i">
            <summary>
            Gets floored Vector4i representation of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.OfLength(Mafi.Fix32)">
            <summary>
            Returns scaled vector to requested length. This method is faster and more intuitive than normalization
            followed by multiplication.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.IsNear(Mafi.Vector4f,Mafi.Fix32)">
            <summary>
            Tests whether corresponding components of this and given vectors are within tolerance.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.IsNormalized">
            <summary>
            Whether this vector length is (nearly) one using default epsilon <see cref="P:Mafi.Fix32.EpsilonNear"/>. Note that
            This uses efficient check of length squared without the need for square root computation.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.Normalized">
            <summary>
            Returns normalized vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.Dot(Mafi.Vector4f)">
            <summary>
            Returns dot product of this vector with given vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.DistanceTo(Mafi.Vector4f)">
            <summary>
            Returns distance from this vector to the other vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.DistanceSqrTo(Mafi.Vector4f)">
            <summary>
            Returns squared distance from this vector to the other vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.Angle">
            <summary>
            Returns absolute angle of this vector. Returned angle is in range [-τ/2, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.Reflect(Mafi.Vector4f)">
            <summary>
            Reflection of this vector from plane specified by given normal (has to be normalized). This vector should be
            pointing to the plane and reflected vector is pointing away from the plane.
            </summary>
            <remarks>
            <code>
                        Normal vector
                      *
            this   \  |  * reflected
            vector  \ | /  vector
                 ____*|/____  reflection surface given by the normal
            </code>
            </remarks>
        </member>
        <member name="M:Mafi.Vector4f.Min(Mafi.Vector4f)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.Max(Mafi.Vector4f)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.MinComponent">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.MaxComponent">
            <summary>
            Returns component-wise max of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.Clamp(Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns component-wise clamp of this vectors.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.AbsValue">
            <summary>
            Returns component-wise absolute value of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4f.Signs">
            <summary>
            Returns component-wise sign of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.Modulo(Mafi.Fix32)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.Modulo(Mafi.Vector4f)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.Average(Mafi.Vector4f)">
            <summary>
            Returns component-wise average of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.Lerp(Mafi.Vector4f,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Linearly interpolates between this and <paramref name="to"/> vectors based on <paramref name="t"/>.
            Interpolation parameter <paramref name="t"/> is expected to be from 0 to 1.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_Equality(Mafi.Vector4f,Mafi.Vector4f)">
            <summary>
            Exact equality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_Inequality(Mafi.Vector4f,Mafi.Vector4f)">
            <summary>
            Exact inequality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_LessThan(Mafi.Vector4f,Mafi.Vector4f)">
            <summary>
            Component-wise less-than operator. Returns true if all components of the left-hand side vector are less than
            respective components of the right-hand side vector.
            WARNING: <c>A &lt; B</c> is not equal to <c>A &gt;= B</c>. For example vectors (1, 2, 3, 4) and (4, 3, 2, 1) are not
            less-than nor greater-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_LessThanOrEqual(Mafi.Vector4f,Mafi.Vector4f)">
            <summary>
            Component-wise less-than-or-equal operator. Returns true if all components of the left-hand side vector are
            less than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &lt;= B</c> is not equal to <c>A &gt; B</c>. For example vectors (1, 2, 3, 4) and (4, 3, 2, 1) are not
            less-than-or-equal nor greater-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_GreaterThan(Mafi.Vector4f,Mafi.Vector4f)">
            <summary>
            Component-wise greater-than operator. Returns true if all components of the left-hand side vector are
            greater than respective components of the right-hand side vector.
            WARNING: <c>A &gt; B</c> is not equal to <c>A &lt;= B</c>. For example vectors (1, 2, 3, 4) and (4, 3, 2, 1) are not
            greater-than nor less-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_GreaterThanOrEqual(Mafi.Vector4f,Mafi.Vector4f)">
            <summary>
            Component-wise greater-than-or-equal operator. Returns true if all components of the left-hand side vector
            are greater than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &gt;= B</c> is not equal to <c>A &lt; B</c>. For example vectors (1, 2, 3, 4) and (4, 3, 2, 1) are not
            greater-than-or-equal nor less-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_Division(Mafi.Vector4f,Mafi.Vector4f)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_Division(Mafi.Vector4i,Mafi.Vector4f)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_Division(Mafi.Vector4f,Mafi.Vector4i)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_Modulus(Mafi.Vector4f,Mafi.Vector4f)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_Modulus(Mafi.Vector4i,Mafi.Vector4f)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4f.op_Modulus(Mafi.Vector4f,Mafi.Vector4i)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4fExtensions.NextVector4f(Mafi.IRandom,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.Vector4fExtensions.NextVector4f(Mafi.IRandom,Mafi.Vector4f,Mafi.Vector4f)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="T:Mafi.Vector4i">
            <summary>
            Immutable 4D int vector.
            </summary>
            <remarks>
            This is partial struct and this file should contain only specific members for <see cref="T:Mafi.Vector4i"/>. All general
            members should be added to the generator T4 template.
            </remarks>
        </member>
        <member name="F:Mafi.Vector4i.Zero">
            <summary>
            Vector (0, 0, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.One">
            <summary>
            Vector (1, 1, 1, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.UnitX">
            <summary>
            Vector (1, 0, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.UnitY">
            <summary>
            Vector (0, 1, 0, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.UnitZ">
            <summary>
            Vector (0, 0, 1, 0).
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.UnitW">
            <summary>
            Vector (0, 0, 0, 1).
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.MinValue">
            <summary>
            Vector (int.MinValue, int.MinValue, int.MinValue, int.MinValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.MaxValue">
            <summary>
            Vector (int.MaxValue, int.MaxValue, int.MaxValue, int.MaxValue).
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.X">
            <summary>
            The X component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.Y">
            <summary>
            The Y component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.Z">
            <summary>
            The Z component of this vector.
            </summary>
        </member>
        <member name="F:Mafi.Vector4i.W">
            <summary>
            The W component of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates new Vector4i from raw components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.#ctor(Mafi.Vector2i,System.Int32,System.Int32)">
            <summary>
            Creates new Vector4i from Vector2i and raw components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.#ctor(Mafi.Vector3i,System.Int32)">
            <summary>
            Creates new Vector4i from Vector3i and raw components.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.Xy">
            <summary>
            Gets the first two components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.Xyz">
            <summary>
            Gets the first three components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.Sum">
            <summary>
            Sum of all components of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.Length">
            <summary>
            Euclidean length of this vector.
            PERF: Expensive, uses sqrt. Consider using <see cref="P:Mafi.Vector4i.LengthSqr"/> whenever possible (when comparing
            lengths, etc.).
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.LengthInt">
            <summary>
            Approximate euclidean length of this vector as integer.
            PERF: Expensive, uses sqrt, consider using <see cref="P:Mafi.Vector4i.LengthSqr"/> whenever possible.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.LengthSqrInt">
            <summary>
            Euclidean length squared of this vector.
            PERF: Cheaper than <see cref="P:Mafi.Vector4i.Length"/>, does not require expensive sqrt.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.LengthSqr">
            <summary>
            Euclidean length squared of this vector.
            PERF: Cheaper than <see cref="P:Mafi.Vector4i.Length"/>, does not require expensive sqrt.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.IsZero">
            <summary>
            Whether this vector has all components equal to zero.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.IsNotZero">
            <summary>e
            Whether this vector has at least one components not equal to zero.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.SetX(System.Int32)">
            <summary>
            Returns new vector with changed X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.SetY(System.Int32)">
            <summary>
            Returns new vector with changed Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.SetZ(System.Int32)">
            <summary>
            Returns new vector with changed Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.SetW(System.Int32)">
            <summary>
            Returns new vector with changed W component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.SetXy(System.Int32,System.Int32)">
            <summary>
            Returns new vector with changed X and Y components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.SetXy(Mafi.Vector2i)">
            <summary>
            Returns new vector with changed X and Y components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.SetXyz(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns new vector with changed X, Y, and Z components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.SetXyz(Mafi.Vector3i)">
            <summary>
            Returns new vector with changed X, Y, and Z components.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.IncrementX">
            <summary>
            Returns new vector with incremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.IncrementY">
            <summary>
            Returns new vector with incremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.IncrementZ">
            <summary>
            Returns new vector with incremented Z component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.IncrementW">
            <summary>
            Returns new vector with incremented W component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.DecrementX">
            <summary>
            Returns new vector with decremented X component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.DecrementY">
            <summary>
            Returns new vector with decremented Y component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.DecrementZ">
            <summary>
            Returns new vector with decremented Z component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.DecrementW">
            <summary>
            Returns new vector with decremented W component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.AddX(System.Int32)">
            <summary>
            Returns new vector with given value added to the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.AddY(System.Int32)">
            <summary>
            Returns new vector with given value added to the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.AddZ(System.Int32)">
            <summary>
            Returns new vector with given value added to the Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.AddW(System.Int32)">
            <summary>
            Returns new vector with given value added to the W component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.AddXyzw(System.Int32)">
            <summary>
            Returns new vector with given value added to all components.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.MultiplyX(System.Int32)">
            <summary>
            Returns new vector with given value multiplied with the X component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.MultiplyY(System.Int32)">
            <summary>
            Returns new vector with given value multiplied with the Y component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.MultiplyZ(System.Int32)">
            <summary>
            Returns new vector with given value multiplied with the Z component.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.MultiplyW(System.Int32)">
            <summary>
            Returns new vector with given value multiplied with the W component.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.ReflectX">
            <summary>
            Returns new vector with reflected X component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.ReflectY">
            <summary>
            Returns new vector with reflected Y component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.ReflectZ">
            <summary>
            Returns new vector with reflected Z component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.ReflectW">
            <summary>
            Returns new vector with reflected W component (opposite sign).
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.Vector4f">
            <summary>
            Gets Vector4f representation of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.MulDiv(System.Int64,System.Int64)">
            <summary>
            Multiples and divides all components. This method is using long precision to prevent int32 overflows.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.OfLength(System.Int32)">
            <summary>
            Returns scaled vector to requested length. This method is more precise, faster and more intuitive than
            normalization followed by multiplication.
            WARNING: Setting length of integer vector may not produce exact requested length do to rounding error.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.IsNear(Mafi.Vector4i,System.Int32)">
            <summary>
            Whether corresponding components of this and given vectors are within given tolerance.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.Dot(Mafi.Vector4i)">
            <summary>
            Returns dot product of this vector with given vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.DotInt(Mafi.Vector4i)">
            <summary>
            Returns dot product of this vector with given vector as int32. Note that result of this method may overflow
            if magnitude of any component is larger than ~30,000.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.DistanceTo(Mafi.Vector4i)">
            <summary>
            Returns distance from this vector to the other vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.DistanceSqrTo(Mafi.Vector4i)">
            <summary>
            Returns squared distance from this vector to the other vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.Angle">
            <summary>
            Returns absolute angle of this vector. Returned angle is in range [-τ/2, τ/2].
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.Min(Mafi.Vector4i)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.Max(Mafi.Vector4i)">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.MinComponent">
            <summary>
            Returns component-wise min of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.MaxComponent">
            <summary>
            Returns component-wise max of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.Clamp(System.Int32,System.Int32)">
            <summary>
            Returns component-wise clamp of this vectors.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.AbsValue">
            <summary>
            Returns component-wise absolute value of this vector.
            </summary>
        </member>
        <member name="P:Mafi.Vector4i.Signs">
            <summary>
            Returns component-wise sign of this vector.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.Modulo(System.Int32)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.Modulo(Mafi.Vector4i)">
            <summary>
            Returns component-wise modulo operation on this vector (see <see cref="M:Mafi.MafiMath.Modulo(System.Int32,System.Int32)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.Average(Mafi.Vector4i)">
            <summary>
            Returns component-wise average of this and given vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.Lerp(Mafi.Vector4i,System.Int64,System.Int64)">
            <summary>
            Linearly interpolates between this and <paramref name="to"/> vectors based on <paramref name="t"/>.
            Interpolation parameter <paramref name="t"/> goes from 0 to <paramref name="scale"/>.
            See <see cref="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,System.Int64,System.Int64)"/> for details.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.Lerp(Mafi.Vector4i,Mafi.Vector4i,System.Int64,System.Int64)">
            <summary>
            Linearly interpolates between <paramref name="from"/> and <paramref name="to"/> vectors based on <paramref
            name="t"/>. Interpolation parameter <paramref name="t"/> goes from 0 to <paramref name="scale"/>. See <see
            cref="M:Mafi.MafiMath.Lerp(System.Int32,System.Int32,System.Int64,System.Int64)"/> for details.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.op_Equality(Mafi.Vector4i,Mafi.Vector4i)">
            <summary>
            Exact equality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.op_Inequality(Mafi.Vector4i,Mafi.Vector4i)">
            <summary>
            Exact inequality of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.op_LessThan(Mafi.Vector4i,Mafi.Vector4i)">
            <summary>
            Component-wise less-than operator. Returns true if all components of the left-hand side vector are less than
            respective components of the right-hand side vector.
            WARNING: <c>A &lt; B</c> is not equal to <c>A &gt;= B</c>. For example vectors (1, 2, 3, 4) and (4, 3, 2, 1) are not
            less-than nor greater-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.op_LessThanOrEqual(Mafi.Vector4i,Mafi.Vector4i)">
            <summary>
            Component-wise less-than-or-equal operator. Returns true if all components of the left-hand side vector are
            less than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &lt;= B</c> is not equal to <c>A &gt; B</c>. For example vectors (1, 2, 3, 4) and (4, 3, 2, 1) are not
            less-than-or-equal nor greater-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.op_GreaterThan(Mafi.Vector4i,Mafi.Vector4i)">
            <summary>
            Component-wise greater-than operator. Returns true if all components of the left-hand side vector are
            greater than respective components of the right-hand side vector.
            WARNING: <c>A &gt; B</c> is not equal to <c>A &lt;= B</c>. For example vectors (1, 2, 3, 4) and (4, 3, 2, 1) are not
            greater-than nor less-than-or-equal.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.op_GreaterThanOrEqual(Mafi.Vector4i,Mafi.Vector4i)">
            <summary>
            Component-wise greater-than-or-equal operator. Returns true if all components of the left-hand side vector
            are greater than or equal to respective components of the right-hand side vector.
            WARNING: <c>A &gt;= B</c> is not equal to <c>A &lt; B</c>. For example vectors (1, 2, 3, 4) and (4, 3, 2, 1) are not
            greater-than-or-equal nor less-than.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.FloorDiv(System.Int32)">
            <summary>
            Computes floor division. Unlike normal division operator in C# this always rounds down.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.op_Division(Mafi.Vector4i,Mafi.Vector4i)">
            <summary>
            Component-wise division of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.FloorDiv(Mafi.Vector4i)">
            <summary>
            Computes floor division. Unlike normal division operator in C# this always rounds down.
            </summary>
        </member>
        <member name="M:Mafi.Vector4i.op_Modulus(Mafi.Vector4i,Mafi.Vector4i)">
            <summary>
            Component-wise modulo of two vectors.
            </summary>
        </member>
        <member name="M:Mafi.Vector4iExtensions.NextVector4i(Mafi.IRandom,System.Int32,System.Int32)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.Vector4iExtensions.NextVector4i(Mafi.IRandom,Mafi.Vector4i,Mafi.Vector4i)">
            <summary>
            Returns a vector where each component is pseudo-random uniformly distributed value between
            <paramref name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="F:Mafi.Matrix2i.M00">
            <summary>
            Row 0, col 0.
            </summary>
        </member>
        <member name="F:Mafi.Matrix2i.M01">
            <summary>
            Row 0, col 1.
            </summary>
        </member>
        <member name="F:Mafi.Matrix2i.M10">
            <summary>
            Row 1, col 0.
            </summary>
        </member>
        <member name="F:Mafi.Matrix2i.M11">
            <summary>
            Row 1, col 1.
            </summary>
        </member>
        <member name="M:Mafi.PercentExtensions.Percent(System.Int32)">
            <summary>
            Converts given integer to percent. Value 1 becomes 1%.
            </summary>
        </member>
        <member name="M:Mafi.PercentExtensions.Percent(System.Double)">
            <summary>
            Converts given double to percent. Value 1 becomes 1%.
            </summary>
        </member>
        <member name="M:Mafi.PercentExtensions.NextPercent(Mafi.IRandom)">
            <summary>
            Returns random percentage in range 0-100% (exclusive).
            </summary>
        </member>
        <member name="F:Mafi.Ray3f.Origin">
            <summary>
            Ray origin.
            </summary>
        </member>
        <member name="F:Mafi.Ray3f.Direction">
            <summary>
            Normalized direction of the ray.
            </summary>
        </member>
        <member name="M:Mafi.Ray3f.#ctor(Mafi.Vector3f,Mafi.Vector3f)">
            <summary>
            Creates a ray starting at origin along direction.
            </summary>
        </member>
        <member name="M:Mafi.Ray3f.GetPoint(Mafi.Percent)">
            <summary>
            Returns a point at distance units along the ray.
            </summary>
        </member>
        <member name="T:Mafi.ObjectPool`1">
             <summary>
             Generic implementation of object pooling pattern with predefined pool size limit. The main purpose is that
             limited number of frequently used objects can be kept in the pool for further recycling.
            
             This class is thread safe and lock-free ( <see cref="T:System.Threading.Interlocked"/> operations are used).
             </summary>
             <remarks>
             1) It is not the goal to keep all returned objects. Pool is not meant for storage. If there is no space in the
             pool, extra returned objects will be dropped.
            
             2) It is implied that if object was obtained from a pool, the caller will return it back in a relatively short
             time. Keeping checked out objects for long durations is ok, but reduces usefulness of pooling. Just new up your
             own.
            
             Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice.
             Rationale: If there is no intent for reusing the object, do not use pool - just use "new".
             </remarks>
        </member>
        <member name="T:Mafi.ObjectPool`1.Element">
            <summary>
            Struct for holding the instances so we can do interlocked compare-exchange operation.
            </summary>
        </member>
        <member name="F:Mafi.ObjectPool`1.m_factory">
            <summary>
            Object factory is stored for the lifetime of the pool. We will call this only when pool needs to expand.
            </summary>
        </member>
        <member name="F:Mafi.ObjectPool`1.m_reset">
            <summary>
            Resets the object for the next use.
            </summary>
        </member>
        <member name="F:Mafi.ObjectPool`1.m_items">
            <summary>
            Storage for the pool objects. The first item is stored in a dedicated field because we expect to be able to
            satisfy most requests from it.
            </summary>
        </member>
        <member name="M:Mafi.ObjectPool`1.#ctor(System.Int32,System.Func{`0},System.Action{`0})">
            <summary>
            Creates a new thread-safe lock-free object pool. The total size should not be too small to be able to pool
            enough object but also not big since we perform linear search for available objects.
            </summary>
        </member>
        <member name="M:Mafi.ObjectPool`1.GetInstance">
            <summary>
            Returns an instance (either from pool or new one). The returned instance was resetted using reset function.
            NOTE: The caller should perform operation and then return the object to the pool. Instances obtained from the
            pool should have very short life-span. For long-living objects create an instance using new.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness. Note that Free will try
            to store recycled objects close to the start thus statistically reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Mafi.ObjectPool`1.ReturnInstance(`0)">
            <summary>
            Returns objects to the pool.
            IMPORTANT: The caller is responsible to ensure that he is the only owner of returned instance and no other
            object have reference to returned object.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness. Note that Free will try
            to store recycled objects close to the start thus statistically reducing how far we will typically search in
            Allocate.
            </remarks>
        </member>
        <member name="T:Mafi.ObjectPool2`1">
            <summary>
            Dynamic object pool with max size limit. This class is NOT thread safe. If you intend to use it from multiple
            threads please use [ThreadStatic] to have an instance per thread and avoid any locking.
            </summary>
        </member>
        <member name="F:Mafi.ObjectPool2`1.m_maxSize">
            <summary>
            Maximum size of the pool.
            </summary>
        </member>
        <member name="F:Mafi.ObjectPool2`1.m_factory">
            <summary>
            Object factory is stored for the lifetime of the pool. We will call this only when no objects are available
            in the pool.
            </summary>
        </member>
        <member name="F:Mafi.ObjectPool2`1.m_reset">
            <summary>
            Resets the object for the next use.
            </summary>
        </member>
        <member name="F:Mafi.ObjectPool2`1.m_items">
            <summary>
            Storage for the pooled objects.
            </summary>
        </member>
        <member name="M:Mafi.ObjectPool2`1.GetInstance">
            <summary>
            Returns an instance (either pooled or new one). The returned instance was reset using the reset function. It
            is responsibility of the caller to return instance to the pool.
            </summary>
        </member>
        <member name="M:Mafi.ObjectPool2`1.ReturnInstance(`0@)">
            <summary>
            Returns objects to the pool.
            IMPORTANT: The caller is responsible to ensure that he is the only owner of returned instance and no other
            object have reference to returned object.
            </summary>
        </member>
        <member name="T:Mafi.Option`1">
             <summary>
             A generic Option type that allows for explicit distinguishing between an intentionally set value, and a default
             value of None. It is readonly struct. Storing mutable values is ok end expected.
            
             The purpose of this class is not to completely prevent null reference exceptions but to introduce semantics to
             help distinguishing potentially null values and expected non-null references.
             </summary>
             <remarks>
             This struct has only one member - the pointer to the class. This is to minimize overhead. With only one pointer
             the memory overhead is actually 0.
             </remarks>
        </member>
        <member name="F:Mafi.Option`1.None">
            <summary>
            The Option indicating there is no value.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.Create(`0)">
            <summary>
            Creates an <see cref="T:Mafi.Option`1"/> from given value. The value may be null.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.Some(`0)">
            <summary>
            Creates an <see cref="T:Mafi.Option`1"/> from given value. The value is expected to be not null (yes, it will throw
            exception in your face if it is not).
            </summary>
        </member>
        <member name="F:Mafi.Option`1.Value">
            <summary>
            Value of the option. Exception is raised when accessing an option that has no value so you better behave!
            </summary>
            <remarks>The access is checked in debug mode.</remarks>
        </member>
        <member name="M:Mafi.Option`1.#ctor(`0)">
            <summary>
            Private constructor to enforce usage of <see cref="M:Mafi.Option.Some``1(``0)"/> and <see cref="F:Mafi.Option.None"/>.
            Default-construction option struct results in <see cref="F:Mafi.Option.None"/> value.
            </summary>
        </member>
        <member name="P:Mafi.Option`1.HasValue">
            <summary>
            Bool indicating whether the option has a value (opposite to <see cref="P:Mafi.Option`1.IsNone"/>).
            </summary>
        </member>
        <member name="P:Mafi.Option`1.IsNone">
            <summary>
            Bool indicating whether the option has no value (opposite to <see cref="P:Mafi.Option`1.HasValue"/>).
            </summary>
        </member>
        <member name="M:Mafi.Option`1.ValueOr(`0)">
            <summary>
            Gets the value of the option if present, and the provided value otherwise. Keep in mind that the given
            default value gets evaluated every time even if it is not used, so do not put <cdoe>new</cdoe> statements or
            function calls there.
            </summary>
        </member>
        <member name="P:Mafi.Option`1.ValueOrNull">
            <summary>
            Gets raw reference of this option. This is useful for usage with Elvis operator ?.;
            </summary>
        </member>
        <member name="M:Mafi.Option`1.As``1">
            <summary>
            Returns value of option cast as <typeparamref name="TResult"/>. Returns cast value or
            <see cref="F:Mafi.Option.None"/> if this option has no value or the cast failed.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.op_Implicit(Mafi.Option)~Mafi.Option{`0}">
            <summary>
            Implicitly converts an <see cref="T:Mafi.Option"/> to an <see cref="T:Mafi.Option`1"/>.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.op_Implicit(`0)~Mafi.Option{`0}">
            <summary>
            Implicitly converts given value to an <see cref="T:Mafi.Option`1"/>. Due to C# spec limitations the implicit cast
            does not work for interfaces, use <see cref="M:Mafi.Option.Create``1(``0)"/> or <see cref="M:Mafi.Option.Some``1(``0)"/>
            instead.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.op_Equality(Mafi.Option{`0},Mafi.Option{`0})">
            <summary>
            Compares two options for equality based on their values.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.op_Inequality(Mafi.Option{`0},Mafi.Option{`0})">
            <summary>
            Compares two options for inequality based on their values.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.op_Equality(Mafi.Option{`0},`0)">
            <summary>
            Compares option and raw value for equality.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.op_Inequality(Mafi.Option{`0},`0)">
            <summary>
            Compares option and raw value for inequality.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.op_Equality(`0,Mafi.Option{`0})">
            <summary>
            Compares option and raw value for equality.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.op_Inequality(`0,Mafi.Option{`0})">
            <summary>
            Compares option and raw value for inequality.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.op_BitwiseOr(Mafi.Option{`0},Mafi.Option{`0})">
            <summary>
            Operator that works like ?? for nullable types but does not short circuit.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.Equals(Mafi.Option{`0})">
            <summary>
            Compares the option to another option for equality based on their values.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.Equals(`0)">
            <summary>
            Compares the option to another option for equality based on their values.
            </summary>
        </member>
        <member name="M:Mafi.Option`1.Equals(System.Object)">
            <summary>
            Compares the option to another object for equality based on their values.
            </summary>
        </member>
        <member name="T:Mafi.IOptionNonGeneric">
            <summary>
            Non-generic interface for access. Keep in mind that access through this interface will box the Option. Use only
            if the option is already boxed.
            </summary>
        </member>
        <member name="T:Mafi.Option">
            <summary>
            Helper class that simplifies creation of options by automated type inference.
            </summary>
        </member>
        <member name="F:Mafi.Option.None">
            <summary>
            The default Option type specifying there is no value.
            </summary>
        </member>
        <member name="M:Mafi.Option.Create``1(``0)">
            <summary>
            Creates an <see cref="T:Mafi.Option`1"/> from given value. The value may be null.
            </summary>
        </member>
        <member name="M:Mafi.Option.Some``1(``0)">
            <summary>
            Creates an <see cref="T:Mafi.Option`1"/> from given value. The value is expected to be not null.
            </summary>
        </member>
        <member name="T:Mafi.OptionExtensions">
            <summary>
            Extensions that add convenient methods for existing types.
            </summary>
        </member>
        <member name="M:Mafi.OptionExtensions.Get``2(Mafi.Collections.Dict{``0,``1},``0)">
            <summary>
            Returns stored value under given key or None.
            </summary>
        </member>
        <member name="M:Mafi.OptionExtensions.GetStruct``2(Mafi.Collections.Dict{``0,``1},``0)">
            <summary>
            Returns stored struct under given key or default instance if it does not exist.
            </summary>
        </member>
        <member name="M:Mafi.OptionExtensions.SelectValues``1(System.Collections.Generic.IEnumerable{Mafi.Option{``0}})">
            <summary>
            Returns sequence of values ignoring elements that are None.
            </summary>
        </member>
        <member name="M:Mafi.OptionExtensions.SelectValues``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,Mafi.Option{``0}})">
            <summary>
            Returns sequence of values ignoring elements that are None.
            </summary>
        </member>
        <member name="M:Mafi.OptionExtensions.SelectValues``1(Mafi.Collections.ImmutableCollections.ImmutableArray{Mafi.Option{``0}})">
            <summary>
            Returns sequence of values ignoring elements that are None.
            </summary>
        </member>
        <member name="T:Mafi.OptionPlus`1">
            <summary>
            OptionPlus is an option that can store both classes and structs. This should be used only in generic classes that
            have to store its parameter in some kind of Option type.
            </summary>
        </member>
        <member name="F:Mafi.OptionPlus`1.None">
            <summary>
            The Option indicating there is no value.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.Create(`0)">
            <summary>
            Creates an <see cref="T:Mafi.OptionPlus`1"/> from given value. The value may be null.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.Some(`0)">
            <summary>
            Creates an <see cref="T:Mafi.OptionPlus`1"/> from given value. The value is expected to be not null (yes, it will
            throw exception in your face if it is not).
            </summary>
        </member>
        <member name="F:Mafi.OptionPlus`1.Value">
            <summary>
            Value of the option. Exception is raised when accessing an option that has no value so you better behave!
            </summary>
            <remarks>The access is checked in debug mode.</remarks>
        </member>
        <member name="M:Mafi.OptionPlus`1.#ctor(`0)">
            <summary>
            Private constructor to enforce usage of <see cref="M:Mafi.OptionPlus.Some``1(``0)"/> and <see cref="F:Mafi.OptionPlus.None"/>.
            Default-construction option struct results in <see cref="F:Mafi.OptionPlus.None"/> value.
            </summary>
        </member>
        <member name="P:Mafi.OptionPlus`1.IsNone">
            <summary>
            Bool indicating whether the option has no value (opposite to <see cref="F:Mafi.OptionPlus`1.HasValue"/>).
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.ValueOr(`0)">
            <summary>
            Gets the value of the option if present, and the provided value otherwise. Keep in mind that the given
            default value gets evaluated every time even if it is not used, so do not put <cdoe>new</cdoe> statements or
            function calls there.
            </summary>
        </member>
        <member name="P:Mafi.OptionPlus`1.ValueOrDefault">
            <summary>
            Gets raw reference of this option. This is useful for usage with Elvis operator ?.;
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.As``1">
            <summary>
            Returns value of option casted as <typeparamref name="TResult"/>. Returns casted value or <see
            cref="F:Mafi.OptionPlus.None"/> if this option has no value or the cast failed.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.op_Implicit(Mafi.OptionPlus)~Mafi.OptionPlus{`0}">
            <summary>
            Implicitly converts an <see cref="T:Mafi.OptionPlus"/> to an <see cref="T:Mafi.OptionPlus`1"/>.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.op_Implicit(`0)~Mafi.OptionPlus{`0}">
            <summary>
            Implicitly converts given value to an <see cref="T:Mafi.OptionPlus`1"/>. Due to C# spec limitations the implicit
            cast does not work for interfaces, use <see cref="M:Mafi.OptionPlus.Create``1(``0)"/> or <see
            cref="M:Mafi.OptionPlus.Some``1(``0)"/> instead.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.op_Equality(Mafi.OptionPlus{`0},Mafi.OptionPlus{`0})">
            <summary>
            Compares two options for equality based on their values.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.op_Inequality(Mafi.OptionPlus{`0},Mafi.OptionPlus{`0})">
            <summary>
            Compares two options for inequality based on their values.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.op_Equality(Mafi.OptionPlus{`0},`0)">
            <summary>
            Compares option and raw value for equality.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.op_Inequality(Mafi.OptionPlus{`0},`0)">
            <summary>
            Compares option and raw value for inequality.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.op_Equality(`0,Mafi.OptionPlus{`0})">
            <summary>
            Compares option and raw value for equality.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.op_Inequality(`0,Mafi.OptionPlus{`0})">
            <summary>
            Compares option and raw value for inequality.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.Equals(Mafi.OptionPlus{`0})">
            <summary>
            Compares the option to another option for equality based on their values.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.Equals(`0)">
            <summary>
            Compares the option to another option for equality based on their values.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus`1.Equals(System.Object)">
            <summary>
            Compares the option to another object for equality based on their values.
            </summary>
        </member>
        <member name="T:Mafi.OptionPlus">
            <summary>
            Helper class that simplifies creation of options by automated type inference.
            </summary>
        </member>
        <member name="F:Mafi.OptionPlus.None">
            <summary>
            The default Option type specifying there is no value.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus.Create``1(``0)">
            <summary>
            Creates an <see cref="T:Mafi.OptionPlus`1"/> from given value. The value may be null.
            </summary>
        </member>
        <member name="M:Mafi.OptionPlus.Some``1(``0)">
            <summary>
            Creates an <see cref="T:Mafi.OptionPlus`1"/> from given value. The value is expected to be not null.
            </summary>
        </member>
        <member name="F:Mafi.GameVersion.NAME">
            <summary>
            Name of the current (minor) game version.
            </summary>
            <remarks>Update <see cref="M:Mafi.GameVersion.GetMinorVersionName(System.String)"/> when changing this.</remarks>
        </member>
        <member name="F:Mafi.GameVersion.MAJOR_VERSION">
            <summary>
            Major version. Guaranteed to be an int.
            </summary>
        </member>
        <member name="F:Mafi.GameVersion.MINOR_VERSION">
            <summary>
            Represents a large update. Guaranteed to be an int.
            </summary>
            <remarks>Update <see cref="M:Mafi.GameVersion.GetMinorVersionName(System.String)"/> when changing this.</remarks>
        </member>
        <member name="F:Mafi.GameVersion.REVISION_VERSION">
            <summary>
            Represents a small update, something that adds minor features and fixes bugs. Guaranteed to be an int.
            </summary>
        </member>
        <member name="F:Mafi.GameVersion.HOTFIX_NAME">
            <summary>
            Hotfix name. Guaranteed to be a char or empty string.
            Use hotfix when patch is just fixing bugs, no new features.
            </summary>
        </member>
        <member name="T:Mafi.IRandom">
            <summary>
            Pseudo-random generator.
            </summary>
            <remarks>
            It is assumed that this generator may not be able to return value 0. Helper methods for getting random values
            count with it.
            </remarks>
        </member>
        <member name="M:Mafi.IRandom.Seed(System.Byte[])">
            <summary>
            Seeds the random generator by given seed data. The data may not be very random so further randomization with
            something like hashing is recommended. The implementation should use ALL bytes to create a seed. Change of a
            single bit should result in very different sequence.
            </summary>
        </member>
        <member name="M:Mafi.IRandom.GetState">
            <summary>
            Returns state of this generator. If this state is passed to the <see cref="M:Mafi.IRandom.Seed(System.Byte[])"/> method it should result
            in the same generator at the one that returned the seed. Returned array is from <see cref="T:Mafi.ArrayPool`1"/>,
            please return it there if possible.
            </summary>
        </member>
        <member name="M:Mafi.IRandom.Jump">
            <summary>
            Jumps random generator to very many states forward. Typically on the order of 2^64 steps or more. This can
            me used to shuffle the generator to generate very different sequence.
            </summary>
        </member>
        <member name="M:Mafi.IRandom.NextUlong">
            <summary>
            Returns pseudo-random uniformly distributed 64-bit value.
            </summary>
        </member>
        <member name="M:Mafi.IRandom.Clone">
            <summary>
            Clones this instance. Both this and returned instances have identical state.
            </summary>
        </member>
        <member name="T:Mafi.IRandomExtensions">
            <summary>
            This extensions class provides convenience methods for all implementations of <see cref="T:Mafi.IRandom"/> interface
            without enforcing the implementation to the base classes.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.Seed(Mafi.IRandom,System.String)">
            <summary>
            Seeds this generator with a string.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.SeedFast(Mafi.IRandom,System.Int32,System.Int32)">
            <summary>
            Seeds this generator with pne or two ints.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.SeedFast(Mafi.IRandom,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Seeds this generator with three or four ints.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.SeedFastWithHash``1(Mafi.IRandom,``0)">
            <summary>
            Seeds this generator with a hash of given object.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextUint(Mafi.IRandom)">
            <summary>
            Returns pseudo-random uniformly distributed 32-bit unsigned value.
            </summary>
            <remarks>Note that this can return value 0 even if the original random generator cannot return 0.</remarks>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextInt(Mafi.IRandom)">
            <summary>
            Returns pseudo-random uniformly distributed 32-bit signed value.
            </summary>
            <remarks>Note that this can return value 0 even if the original random generator cannot return 0.</remarks>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextIntNotNegative(Mafi.IRandom)">
            <summary>
            Returns pseudo-random uniformly distributed non-negative 31-bit value (sign bit is always 0).
            </summary>
            <remarks>Note that this can return value 0 even if the original random generator cannot return 0.</remarks>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextInt(Mafi.IRandom,System.Int32)">
            <summary>
            Returns pseudo-random uniformly distributed value between 0 (inclusive) and <paramref name="maxValueExcl"/>
            (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextInt(Mafi.IRandom,System.Int32,System.Int32)">
            <summary>
            Returns pseudo-random uniformly distributed value between <paramref name="minValueIncl"/> (inclusive) and
            <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextUint(Mafi.IRandom,System.UInt32,System.UInt32)">
            <summary>
            Returns pseudo-random uniformly distributed value between <paramref name="minValueIncl"/> (inclusive) and
            <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextLong(Mafi.IRandom)">
            <summary>
            Returns pseudo-random uniformly distributed non-negative 63-bit value (sign bit is always 0).
            </summary>
            <remarks>Note that this can return value 0 even if the original random generator cannot return 0.</remarks>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextLong(Mafi.IRandom,System.Int64,System.Int64)">
            <summary>
            Returns pseudo-random uniformly distributed value between <paramref name="minValueIncl"/> (inclusive) and
            <paramref name="maxValueExcl"/> (exclusive). Note that this function cannot handle entire range of long. For
            ranges larger than 53 bits some values may not be possible to obtain.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextFloat(Mafi.IRandom)">
            <summary>
            Returns pseudo-random uniformly distributed single-precision floating point value in range [0, 1), that is
            zero inclusive and one exclusive.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextFloat(Mafi.IRandom,System.Single,System.Single)">
            <summary>
            Returns pseudo-random uniformly distributed single-precision floating point value in between <paramref
            name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextDouble(Mafi.IRandom)">
            <summary>
            Returns pseudo-random uniformly distributed double-precision floating point value in range [0, 1), that is
            zero inclusive and one exclusive.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextDouble(Mafi.IRandom,System.Double,System.Double)">
            <summary>
            Returns pseudo-random uniformly distributed double-precision floating point value in between <paramref
            name="minValueIncl"/> (inclusive) and <paramref name="maxValueExcl"/> (exclusive).
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextBool(Mafi.IRandom)">
            <summary>
            Returns true 50% of a time.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.TestProbability(Mafi.IRandom,System.Single)">
            <summary>
            Returns true <paramref name="probability"/>% of times (by random). While probability should be between 0 and
            1, it can be out of range and the results are as expected - returns always false for probability below 0 and
            always true for probability above 1.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.Generate(Mafi.IRandom,System.Byte[])">
            <summary>
            Fills given buffer with random data. Consider using more effective <see cref="M:Mafi.IRandomExtensions.Generate(Mafi.IRandom,System.UInt32[])"/>
            or <see cref="M:Mafi.IRandomExtensions.Generate(Mafi.IRandom,System.UInt64[])"/>.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.Generate(Mafi.IRandom,System.UInt32[])">
            <summary>
            Fills given buffer with random data.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.Generate(Mafi.IRandom,System.UInt64[])">
            <summary>
            Fills given buffer with random data. This method is very effective, more effective than <see
            cref="M:Mafi.IRandomExtensions.Generate(Mafi.IRandom,System.Byte[])"/> overload.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.Shuffle``1(Mafi.IRandom,``0[])">
            <summary>
            Randomly shuffles given array.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.Shuffle``1(Mafi.IRandom,``0[],System.Int32,System.Int32)">
            <summary>
            Randomly shuffles given array.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.GetRandomElementOrDefault``1(Mafi.IRandom,Mafi.Collections.ReadonlyCollections.IIndexable{``0})">
            <summary>
            Returns a random element from the given collection or default when collection is empty.
            </summary>
            <returns>Returns default value (null) if the collection is empty.</returns>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextGaussian(Mafi.IRandom)">
            <summary>
            Returns pseudo-random single-precision floating point value from normal distribution with mean 0 and std.
            deviation 1.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextGaussian(Mafi.IRandom,System.Single,System.Single)">
            <summary>
            Returns pseudo-random single-precision floating point value from normal distribution with given mean and
            std. deviation.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextGaussianTrunc(Mafi.IRandom,Mafi.Fix32,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns pseudo-random single-precision floating point value from normal distribution with given and std.
            deviation. Returned value will never be further than <paramref name="maxAbsDeviation"/>.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.NextGaussianTrunc(Mafi.IRandom,Mafi.Fix32,Mafi.Fix32,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns pseudo-random single-precision floating point value from normal distribution with given and std.
            deviation. Returned value will never be outside of <paramref name="minDeviation"/> and <paramref
            name="maxDeviation"/>.
            </summary>
        </member>
        <member name="M:Mafi.IRandomExtensions.SampleCircleCenterBiased(Mafi.IRandom,Mafi.Vector2f,Mafi.Fix32,Mafi.Fix32)">
            <summary>
            Returns a sample from a circle by choosing random angle and radius. This sampling is not uniform and is
            biased toward the centers.
            </summary>
        </member>
        <member name="T:Mafi.CanBeNullAttribute">
             <summary>
             Indicates that the value of the marked element could be <c>null</c> sometimes,
             so checking for <c>null</c> is required before its usage.
             </summary>
             <example><code>
             [CanBeNull] object Test() => null;
            
             void UseTest() {
               var p = Test();
               var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
             }
             </code></example>
        </member>
        <member name="T:Mafi.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element can never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:Mafi.ItemNotNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
            <example><code>
            public void Foo([ItemNotNull]List&lt;string&gt; books)
            {
              foreach (var book in books) {
                if (book != null) // Warning: Expression is always true
                 Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:Mafi.ItemCanBeNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
            <example><code>
            public void Foo([ItemCanBeNull]List&lt;string&gt; books)
            {
              foreach (var book in books)
              {
                // Warning: Possible 'System.NullReferenceException'
                Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:Mafi.StringFormatMethodAttribute">
             <summary>
             Indicates that the marked method builds string by the format pattern and (optional) arguments.
             The parameter, which contains the format string, should be given in constructor. The format string
             should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
             </summary>
             <example><code>
             [StringFormatMethod("message")]
             void ShowError(string message, params object[] args) { /* do something */ }
            
             void Foo() {
               ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
             }
             </code></example>
        </member>
        <member name="M:Mafi.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as the format string
            </param>
        </member>
        <member name="T:Mafi.ValueProviderAttribute">
             <summary>
             Use this annotation to specify a type that contains static or const fields
             with values for the annotated property/field/parameter.
             The specified type will be used to improve completion suggestions.
             </summary>
             <example><code>
             namespace TestNamespace
             {
               public class Constants
               {
                 public static int INT_CONST = 1;
                 public const string STRING_CONST = "1";
               }
            
               public class Class1
               {
                 [ValueProvider("TestNamespace.Constants")] public int myField;
                 public void Foo([ValueProvider("TestNamespace.Constants")] string str) { }
            
                 public void Test()
                 {
                   Foo(/*try completion here*/);//
                   myField = /*try completion here*/
                 }
               }
             }
             </code></example>
        </member>
        <member name="T:Mafi.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be a string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:Mafi.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
            
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
            
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:Mafi.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If the method has a single input parameter, its name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same) for the method output
            means that the method doesn't return normally (throws or terminates the process).<br/>
            Value <c>canbenull</c> is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row, or use single attribute
            with rows separated by semicolon. There is no notion of order rows, all rows are checked
            for applicability and applied per each program state tracked by the analysis engine.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=&gt; halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("null &lt;= param:null")] // reverse condition syntax
            public string GetName(string surname)
            </code></item>
            <item><code>
            [ContractAnnotation("s:null =&gt; true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null =&gt; null; notnull =&gt; notnull")]
            public object Transform(object data)
            </code></item>
            <item><code>
            [ContractAnnotation("=&gt; true, result: notnull; =&gt; false, result: null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:Mafi.LocalizationRequiredAttribute">
            <summary>
            Indicates whether the marked element should be localized.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:Mafi.CannotApplyEqualityOperatorAttribute">
             <summary>
             Indicates that the value of the marked type (or its derivatives)
             cannot be compared using '==' or '!=' operators and <c>Equals()</c>
             should be used instead. However, using '==' or '!=' for comparison
             with <c>null</c> is always permitted.
             </summary>
             <example><code>
             [CannotApplyEqualityOperator]
             class NoEquality { }
            
             class UsesNoEquality {
               void Test() {
                 var ca1 = new NoEquality();
                 var ca2 = new NoEquality();
                 if (ca1 != null) { // OK
                   bool condition = ca1 == ca2; // Warning
                 }
               }
             }
             </code></example>
        </member>
        <member name="T:Mafi.BaseTypeRequiredAttribute">
             <summary>
             When applied to a target attribute, specifies a requirement for any type marked
             with the target attribute to implement or inherit specific type or types.
             </summary>
             <example><code>
             [BaseTypeRequired(typeof(IComponent)] // Specify requirement
             class ComponentAttribute : Attribute { }
            
             [Component] // ComponentAttribute requires implementing IComponent interface
             class MyComponent : IComponent { }
             </code></example>
        </member>
        <member name="T:Mafi.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be reported as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:Mafi.MeansImplicitUseAttribute">
            <summary>
            Can be applied to attributes, type parameters, and parameters of a type assignable from <see cref="T:System.Type"/> .
            When applied to an attribute, the decorated attribute behaves the same as <see cref="T:Mafi.UsedImplicitlyAttribute"/>.
            When applied to a type parameter or to a parameter of type <see cref="T:System.Type"/>,  indicates that the corresponding type
            is used implicitly.
            </summary>
        </member>
        <member name="T:Mafi.ImplicitUseKindFlags">
            <summary>
            Specify the details of implicitly used symbol when it is marked
            with <see cref="T:Mafi.MeansImplicitUseAttribute"/> or <see cref="T:Mafi.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:Mafi.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:Mafi.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:Mafi.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:Mafi.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:Mafi.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered to be used implicitly when marked
            with <see cref="T:Mafi.MeansImplicitUseAttribute"/> or <see cref="T:Mafi.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:Mafi.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:Mafi.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:Mafi.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:Mafi.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:Mafi.PureAttribute">
             <summary>
             Indicates that a method does not make any observable state changes.
             The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
             </summary>
             <example><code>
             [Pure] int Multiply(int x, int y) => x * y;
            
             void M() {
               Multiply(123, 42); // Waring: Return value of pure method is not used
             }
             </code></example>
        </member>
        <member name="T:Mafi.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of the method invocation must be used.
            </summary>
            <remarks>
            Methods decorated with this attribute (in contrast to pure methods) might change state,
            but make no sense without using their return value. <br/>
            Similarly to <see cref="T:Mafi.PureAttribute"/>, this attribute
            will help detecting usages of the method when the return value in not used.
            Additionally, you can optionally specify a custom message, which will be used when showing warnings, e.g.
            <code>[MustUseReturnValue("Use the return value to...")]</code>.
            </remarks>
        </member>
        <member name="T:Mafi.ProvidesContextAttribute">
             <summary>
             Indicates the type member or parameter of some type, that should be used instead of all other ways
             to get the value of that type. This annotation is useful when you have some "context" value evaluated
             and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
             </summary>
             <example><code>
             class Foo {
               [ProvidesContext] IBarService _barService = ...;
            
               void ProcessNode(INode node) {
                 DoSomething(node, node.GetGlobalServices().Bar);
                 //              ^ Warning: use value of '_barService' field
               }
             }
             </code></example>
        </member>
        <member name="T:Mafi.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:Mafi.SourceTemplateAttribute">
            <summary>
            An extension method marked with this attribute is processed by code completion
            as a 'Source Template'. When the extension method is completed over some expression, its source code
            is automatically expanded like a template at call site.
            </summary>
            <remarks>
            Template method body can contain valid source code and/or special comments starting with '$'.
            Text inside these comments is added as source code when the template is applied. Template parameters
            can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
            Use the <see cref="T:Mafi.MacroAttribute"/> attribute to specify macros for parameters.
            </remarks>
            <example>
            In this example, the 'forEach' method is a source template available over all values
            of enumerable types, producing ordinary C# 'foreach' statement and placing caret inside block:
            <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:Mafi.MacroAttribute">
            <summary>
            Allows specifying a macro for a parameter of a <see cref="T:Mafi.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
            You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
            is defined in the <see cref="P:Mafi.MacroAttribute.Expression"/> property. When applied on a method, the target
            template parameter is defined in the <see cref="P:Mafi.MacroAttribute.Target"/> property. To apply the macro silently
            for the parameter, set the <see cref="P:Mafi.MacroAttribute.Editable"/> property value = -1.
            </remarks>
            <example>
            Applying the attribute on a source template method:
            <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
            Applying the attribute on a template method parameter:
            <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:Mafi.MacroAttribute.Expression">
            <summary>
            Allows specifying a macro that will be executed for a <see cref="T:Mafi.SourceTemplateAttribute">source template</see>
            parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:Mafi.MacroAttribute.Editable">
            <summary>
            Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
            If the target parameter is used several times in the template, only one occurrence becomes editable;
            other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
            use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>
        </member>
        <member name="P:Mafi.MacroAttribute.Target">
            <summary>
            Identifies the target parameter of a <see cref="T:Mafi.SourceTemplateAttribute">source template</see> if the
            <see cref="T:Mafi.MacroAttribute"/> is applied on a template method.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcSuppressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that the marked parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcViewComponentAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component name.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcViewComponentViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component view. If applied to a method, the MVC view component view name is default.
            </summary>
        </member>
        <member name="T:Mafi.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:Mafi.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that the marked parameter or method is a Razor section.
            Use this attribute for custom wrappers similar to
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:Mafi.CollectionAccessAttribute">
            <summary>
            Indicates how method, constructor invocation, or property access
            over collection type affects the contents of the collection.
            Use <see cref="P:Mafi.CollectionAccessAttribute.CollectionAccessType"/> to specify the access type.
            </summary>
            <remarks>
            Using this attribute only makes sense if all collection methods are marked with this attribute.
            </remarks>
            <example><code>
            public class MyStringCollection : List&lt;string&gt;
            {
              [CollectionAccess(CollectionAccessType.Read)]
              public string GetFirstString()
              {
                return this.ElementAt(0);
              }
            }
            class Test
            {
              public void Foo()
              {
                // Warning: Contents of the collection is never updated
                var col = new MyStringCollection();
                string x = col.GetFirstString();
              }
            }
            </code></example>
        </member>
        <member name="T:Mafi.CollectionAccessType">
            <summary>
            Provides a value for the <see cref="T:Mafi.CollectionAccessAttribute"/> to define
            how the collection method invocation affects the contents of the collection.
            </summary>
        </member>
        <member name="F:Mafi.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:Mafi.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:Mafi.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:Mafi.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:Mafi.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts the control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with
            <see cref="T:Mafi.AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:Mafi.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:Mafi.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:Mafi.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:Mafi.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:Mafi.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:Mafi.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:Mafi.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:Mafi.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception.
            </summary>
        </member>
        <member name="T:Mafi.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:Mafi.NoEnumerationAttribute">
             <summary>
             Indicates that IEnumerable passed as a parameter is not enumerated.
             Use this annotation to suppress the 'Possible multiple enumeration of IEnumerable' inspection.
             </summary>
             <example><code>
             static void ThrowIfNull&lt;T&gt;([NoEnumeration] T v, string n) where T : class
             {
               // custom check for null but no enumeration
             }
            
             void Foo(IEnumerable&lt;string&gt; values)
             {
               ThrowIfNull(values, nameof(values));
               var x = values.ToList(); // No warnings about multiple enumeration
             }
             </code></example>
        </member>
        <member name="T:Mafi.RegexPatternAttribute">
            <summary>
            Indicates that the marked parameter is a regular expression pattern.
            </summary>
        </member>
        <member name="T:Mafi.NoReorderAttribute">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns.
            </remarks>
        </member>
        <member name="T:Mafi.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be treated
            as <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolve.
            </summary>
        </member>
        <member name="T:Mafi.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:Mafi.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:Mafi.Serialization.DoNotSaveAttribute">
            <summary>
            Mark any property or field of a savable class / struct to make it ignored by the serializer generator. Note that
            properties without setters are ignored by default.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Mafi.Serialization.DoNotSaveCreateNewOnLoadAttribute" -->
        <member name="T:Mafi.Serialization.GenerateSerializer">
             <summary>
             Mark any partial class / struct with this attribute to get its serializers automatically generated for all fields
             and settable properties. If you wish to not save some of the member, mark them with <see
             cref="T:Mafi.Serialization.DoNotSaveAttribute"/>.
            
             When saving class:
             - Empty class will be created (ctors will be skipped)
             - All fields, props will be set via reflection
             - LoadCtor annotation is forbidden
             - Classes are always serialized via reference.
            
             When saving struct:
             - Ctor marked with <see cref="T:Mafi.Serialization.LoadCtorAttribute"/> will be used. Or if there is just one, then that one.ManuallyWrittenSerializationAttribute
             - Ctor args must have the same name as the fields so the generator can match them and populate the ctor.
             - You are not allowed to do any work in your load ctor!!ManuallyWrittenSerializationAttribute
            
             NOTE: Deserialization of structs would require boxing / unboxing and would be 10 times slower then via ctor.
             Which on millions of instance can account for several seconds.
             </summary>
        </member>
        <member name="T:Mafi.Serialization.ManuallyWrittenSerializationAttribute">
            <summary>
            Marked class has manually written serializer. This is only for better readability.
            </summary>
        </member>
        <member name="T:Mafi.Serialization.DisableDirectCallSerializationAttribute">
            <summary>
            Marked class (and all its derived classes) will be serialized via `GetSerializerFor`/`GetDeserializerFor` that
            allows injecting special serializers. Direct-call serialization will be disabled on members of this type.
            </summary>
        </member>
        <member name="T:Mafi.Serialization.SkipDuringDeterminismValidation">
            <summary>
            Serialization of marked class will be skipped during determinism validation. This works only for filtering
            classes in resolver, not as members of other classes.
            </summary>
            <remarks>
            This should be generally used for UI state classes that are not present in any other serializable classes.
            </remarks>
        </member>
        <member name="T:Mafi.Serialization.SerializeAsGlobalDepAttribute">
            <summary>
            Marks class to be serialized as a global dependency. This is only needed for classes that are not marked
            with [GlobalDependency]
            </summary>
        </member>
        <member name="T:Mafi.Serialization.IgnoreMissingSerializer">
            <summary>
            When serializer generator finds a class marked by this attribute it will not throw any errors
            in case the class implements an interface that is being saved but such class has no serializer.
            Normally this should not happen and if you need to use this you are asking for problem.
            </summary>
        </member>
        <member name="T:Mafi.Serialization.LoadCtorAttribute">
            <summary>
            Attribute to mark class constructor to be used to create its instances on game load.
            Used for structs in <see cref="T:Mafi.Serialization.GenerateSerializer"/>
            </summary>
        </member>
        <member name="T:Mafi.Serialization.OnlyForSaveCompatibilityAttribute">
            <summary>
            Marks anything to be only for save compability. When we are upgrading save in backwards incompatible ways,
            we can search for this and cleanup the code.
            </summary>
        </member>
        <member name="T:Mafi.Serialization.InitAfterLoadAttribute">
             <summary>
             Marked method will be called during or immediately after deserialization.
            
             Note: Marked method should be private. It is guaranteed that methods defined on base class are called first
             (same ordering as constructors).
             </summary>
        </member>
        <member name="M:Mafi.Serialization.InitAfterLoadAttribute.#ctor(System.Boolean,Mafi.Serialization.InitPriority)">
            <param name="immediatelyAfterSelfDeserialized">If set, this method will be called immediately after
            all members are deserialized. Priority is unused in this case.</param>
            <param name="priority">Priority for initialization, the higher priority (or the lower number), the earlier
            it will be called.</param>
        </member>
        <member name="F:Mafi.Serialization.InitPriority.Highest">
            <summary>
            Use only for self-init of classes that must initialize before anything else, like collections or resolver.
            Resolver should NOT be used during this stage if possible.
            </summary>
        </member>
        <member name="F:Mafi.Serialization.InitPriority.High">
            <summary>
            Initialize before other classes but after critical components such as collections.
            </summary>
        </member>
        <member name="F:Mafi.Serialization.InitPriority.Normal">
            <summary>
            Default priority, use this when you need to initialize self but don't need to rely on other classes being
            initialized.
            </summary>
        </member>
        <member name="F:Mafi.Serialization.InitPriority.Low">
            <summary>
            Initialize after most of other classes. Use this if you need some other classes already initialized as part
            of your own initialization.
            </summary>
        </member>
        <member name="F:Mafi.Serialization.InitPriority.Lowest">
            <summary>
            This is usually used for data validation.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.BlobReader.FinalizeLoading(Mafi.Option{Mafi.DependencyResolver})">
            <summary>
            Reads data for all loaded classes. This has to be called at the end of loading.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.BlobReader.TryStartClassDeserialization``1(``0@,System.Func{Mafi.Serialization.BlobReader,System.Type,``0})">
             <summary>
             Starts class deserialization by reading next class ID from the stream. If the deserialized class is new,
             previously unseen, creates an empty instance and returns <c>true</c>. If the class was previously seen
             and deserialized <c>false</c> is returned. It is sole responsibility of the caller to properly load class
             data when <c>true</c> was returned.
            
             See <see cref="M:Mafi.Serialization.BlobWriter.TryStartClassSerialization``1(``0)"/>.
             </summary>
             <param name="customNewObjFactory">Custom factory function. WARNING: This function cannot read new objects.</param>
        </member>
        <member name="M:Mafi.Serialization.BlobReader.EnqueueDataDeserialization(System.Object,System.Action{System.Object,Mafi.Serialization.BlobReader})">
            <summary>
            Opposite of <see cref="M:Mafi.Serialization.BlobWriter.EnqueueDataSerialization(System.Object,System.Action{System.Object,Mafi.Serialization.BlobWriter})"/>.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.ReadUtils.SetField``1(``0,System.String,System.Object)">
            <summary>
            Prefer using <see cref="T:Mafi.Serialization.BlobReader"/> directly for better perf if you can.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.BlobWriter.CanSerialize(System.Type)">
            <summary>
            Returns whether given type can be serialized. This is quite slow. Consider caching results if needed.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.BlobWriter.EnqueueDataSerialization(System.Object,System.Action{System.Object,Mafi.Serialization.BlobWriter})">
            <summary>
            Enqueues object for data serialization. This is to break potentially too deep recursion when serializing
            large object graphs.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.ISpecialSerializerFactory.CanSerialize``1">
            <summary>
            Whether this serializer can handle serialization of the given type.
            </summary>
        </member>
        <member name="T:Mafi.Serialization.CSharpGenCtorAttribute">
            <summary>
            Marks constructor to be used by the <see cref="T:Mafi.Serialization.CSharpGen"/>
            </summary>
        </member>
        <member name="T:Mafi.Serialization.GameLoadException">
            <summary>
            Thrown when there is an unrecoverable problem while loading a saved game.
            </summary>
        </member>
        <member name="T:Mafi.Serialization.GameSaveException">
            <summary>
            Thrown when there is an unrecoverable problem while saving a game.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.Generators.MembersGenerator.getWriteCodeStr(Mafi.Serialization.Generators.MemberWrapper)">
            <summary>
            Returns code that writes a value of given name and type to the blob writer.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.Generators.MembersGenerator.getReaderCodeStr(Mafi.Serialization.Generators.MemberWrapper,System.Boolean)">
            <summary>
            Returns code that reads and returns a value for given member.
            </summary>
        </member>
        <member name="P:Mafi.Serialization.Generators.MemberWrapper.IsSerialized">
            <summary>
            Whether this member is actually serialized to the save file.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.Generators.SerializerGenerator.WriteAllResults(Mafi.Collections.ReadonlyCollections.IIndexable{Mafi.Serialization.Generators.SerializerGeneratorResult})">
            <summary>
            Saves all files in parallel. Called from T4 template.
            </summary>
        </member>
        <member name="T:Mafi.Serialization.GenericSerializersFactory">
             <summary>
             Allows serialization of any objects in cases where serialized types cannot be determined during compile time,
             for example interfaces or members of generic types.
            
             IMPORTANT: If this class is used for serialization, it also MUST be used for deserialization, since in some
             cases more data is written/read to/from the data stream.
             </summary>
             <remarks>
             All built-in types are directly written/read to/from the stream, structs are not boxed.
             For other types calls `Serialize` and `Deserialize` are made via compiled lambda expressions.
             If a type is not built-in and does not have `Serialize` and `Deserialize` methods, exception will be thrown
             during serializer class creation.
             </remarks>
        </member>
        <member name="T:Mafi.Serialization.DirectCallSerializer`1">
            <summary>
            Serializer that calls `Serialize` and `Deserialize` on given type directly. The given type must implement these
            methods otherwise Exception is thrown. If you have an interface type that does not implement these methods, use
            <see cref="T:Mafi.Serialization.DynamicDispatchClassSerializer`1"/>.
            </summary>
            <remarks>
            This class uses compiled lambda expression so that the calls are very efficient, much faster than
            `GetMethod().Call()` would be.</remarks>
        </member>
        <member name="M:Mafi.Serialization.DirectCallSerializer`1.#ctor(System.Type)">
            <summary>
            Use this ctor if <typeparamref name="T"/> is an interface (or abstract/derived class) but you wish to call
            `Serialize` and `Deserialize` on some concrete implementation <paramref name="typeToSerialize"/>. Note that
            <paramref name="typeToSerialize"/> must be assignable to <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:Mafi.Serialization.IIsSafeAsHashKey">
            <summary>
            Marks a class to be safe as a key of hash-based container such as dict or set. This means that the class must
            produce hash with is not based in the object ID (which is not stable between game instances).
            </summary>
        </member>
        <member name="T:Mafi.Serialization.ObjectIds.IdToObjectMap">
            <summary>
            Keeps track of map of loaded ids to corresponding objects.
            It is a counterpart for <see cref="T:Mafi.Serialization.ObjectIds.ObjectIdsGenerator"/>
            </summary>
        </member>
        <member name="T:Mafi.Serialization.ObjectIds.ObjectIdsGenerator">
            <summary>
            Generates unique ids for objects.
            </summary>
            <remarks>
            We could use ObjectIDGenerator for ids generation, but it generates <see cref="T:System.Int64"/> ids, whereas we generate
            shorter <see cref="T:System.Int32"/> ids to save space. And even use have shorter ids for all or some object in the future.
            </remarks>
        </member>
        <member name="M:Mafi.Serialization.ObjectIds.ObjectIdsGenerator.GetOrAddIdFor``1(``0,System.Boolean@)">
            <remarks>
            Type parameter is not limited to class, because of usage in methods in <see cref="T:Mafi.Serialization.BlobWriter"/>, where their
            type parameter is not limited to class either.
            </remarks>
        </member>
        <member name="T:Mafi.Serialization.ObjectIds.ReferenceEqualityComparer`1">
            <summary>
            Equality comparer comparing objects by their references.
            </summary>
        </member>
        <member name="T:Mafi.Serialization.UniqueId">
            <summary>
            Represents an identifier saved at the start of each class serialized class.
            Merges identification of objects used by reference serialized types and identification of object type used by
            copy serialized types.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.UniqueId.ToUint">
            <summary>
            Serialization into 4 bytes.
            </summary>
        </member>
        <member name="M:Mafi.Serialization.UniqueId.ParseUint(System.UInt32)">
            <summary>
            Deserialization.
            </summary>
        </member>
        <member name="M:Mafi.Swap.Them``1(``0@,``0@)">
            <summary>
            Swaps two given ref values.
            </summary>
        </member>
        <member name="P:Mafi.ThreadUtils.ThreadNameFast">
            <summary>
            Returns current thread's name without allocations. The <see cref="P:System.Threading.Thread.Name"/> GC-allocates.
            </summary>
        </member>
        <member name="M:Mafi.Tracing.StartTracing">
            <summary>
            Starts tracing. When tracing is already running, this restarts it.
            Trace is only saved when a stream writer is passed to the <see cref="M:Mafi.Tracing.StopTracing(Mafi.Option{System.IO.StreamWriter})"/> method.
            </summary>
        </member>
        <member name="M:Mafi.Tracing.ClearTraces">
            <summary>
            Clears internal buffer but does not change state of tracing.
            </summary>
        </member>
        <member name="M:Mafi.Tracing.StopTracing(Mafi.Option{System.IO.StreamWriter})">
            <summary>
            Stops tracing and optionally saves collected data.
            </summary>
        </member>
        <member name="M:Mafi.Tracing.Instant(System.String,System.String)">
            <summary>
            Records instant event.
            </summary>
        </member>
        <member name="M:Mafi.Tracing.Begin(System.String,System.String)">
            <summary>
            Records event begin (should be paired with <see cref="M:Mafi.Tracing.End(System.String,System.String)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Tracing.End(System.String,System.String)">
            <summary>
            Records event end (should be paired with <see cref="M:Mafi.Tracing.Begin(System.String,System.String)"/>).
            </summary>
        </member>
        <member name="M:Mafi.Tracing.saveEvent(System.Char,System.String,System.String,System.String)">
            <summary>
            Saves event to internal list in a thread-safe way.
            </summary>
        </member>
        <member name="T:Mafi.PerfCounter">
             <summary>
             Helper class to count number of calls to interesting methods such as caching to help evaluate effectivity.
            
             Intended usage is:
             <code>
             PerfCounter.Inc("ClassName: YourKey OptinalyWithMore Parts");
             </code>
             Please try to not use any string concatenation or formatting for the key to make the operation allocation-free.
             For generic classes that want to report their type please use static readonly strings as keys.
            
             All public methods are conditionally compiled and are not gonna be called in the release build to avoid overhead.
             </summary>
        </member>
        <member name="M:Mafi.PerfCounter.Inc(System.String)">
            <summary>
            Increments given counter. This method can be considered thread safe (for detail see remarks section of this
            class).
            </summary>
        </member>
        <member name="M:Mafi.PerfCounter.Add(System.String,System.Int64)">
            <summary>
            Adds given number to the counter. This method can be considered thread safe (for detail see remarks section
            of this class).
            </summary>
        </member>
        <member name="M:Mafi.PerfCounter.GetCounter(System.String)">
            <summary>
            Returns count of requested counter.
            </summary>
        </member>
        <member name="M:Mafi.PerfCounter.GetAllCounters">
            <summary>
            Returns a copy of internal counters.
            </summary>
        </member>
        <member name="T:Mafi.PerfCounter.Counter">
            <summary>
            Helper class to use interlocked increment inside of Dictionary.
            </summary>
        </member>
        <member name="M:Mafi.ThreadAssert.IsOnSimThreadOrInSync(System.String)">
            <summary>
            Asserts that caller is on sim thread or on main thread during sync.
            </summary>
        </member>
        <member name="T:Mafi.VisualDebug">
            <summary>
            Class that allows to debug visual data. This class just logs all debug event. Graphics backend has to query the
            events and show them.
            </summary>
        </member>
        <member name="T:Mafi.Vornoi.DelaunayBowyerWatson">
            <summary>
            Computes delaunay triangulation using Bowyer-Watson algorithm.
            </summary>
            <remarks>https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm</remarks>
        </member>
        <member name="M:Mafi.Vornoi.DelaunayBowyerWatson.ComputeDelaunayTriangulation(Mafi.Collections.ReadonlyCollections.IIndexable{Mafi.Vector2i})">
            <summary>
            Returns delaunay triangulation of given points.
            </summary>
        </member>
        <member name="M:Mafi.Vornoi.DelaunayBowyerWatson.addNewTriangle(Mafi.Collections.Set{Mafi.Vornoi.DelaunayTriangle2i},Mafi.Collections.ReadonlyCollections.IIndexable{Mafi.Vector2i},Mafi.Vector2i[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Helper function that inserts triangle based on point indices.
            </summary>
        </member>
        <member name="T:Mafi.Vornoi.DelaunayTriangle2i">
            <summary>
            A 2D triangle with integer coordinates.
            </summary>
            <remarks>This class has been optimized to use in Delaunay triangulation algorithm</remarks>
        </member>
        <member name="F:Mafi.Vornoi.DelaunayTriangle2i.TwiceArea">
            <summary>
            Cached value of 2 * area of this triangle. We intentionally store it as double to keep it integer.
            </summary>
        </member>
        <member name="M:Mafi.Vornoi.DelaunayTriangle2i.Contains(Mafi.Vector2i)">
            <summary>
            Whether given point is in the triangle or on its edge.
            </summary>
            <remarks>
            We compute <c>s` = s * 2 Area</c> and <c>t` = t * 2 Area</c> to avoid division. This won't have affect the
            positivity check of <c>s</c> and <c>t</c>. Finally, instead of checking positive <c>1-s-t</c> we check
            equivalent condition of <c>s` + t`</c> is greater than <c>2 * Area</c>.
            http://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle
            </remarks>
        </member>
        <member name="M:Mafi.Vornoi.DelaunayTriangle2i.IsInCircumcircle(Mafi.Vector2i)">
            <summary>
            Whether given point is inside the circumcircle of this triangle but not exactly on it.
            </summary>
            <remarks>https://en.wikipedia.org/wiki/Delaunay_triangulation#Algorithms</remarks>
        </member>
        <member name="T:Mafi.Vornoi.VornoiCell">
            <summary>
            Vornoi cell represented as counter-clockwise polygon and cell center.
            </summary>
        </member>
        <member name="F:Mafi.Vornoi.VornoiCell.PointIndex">
            <summary>
            Index of the center point of this cell. This indexes array of center points which is different from perimeter
            points.
            </summary>
        </member>
        <member name="F:Mafi.Vornoi.VornoiCell.Perimeter">
            <summary>
            Indices of vornoi points around perimeter of this cell in counterclockwise. An edge [i, i + 1] is shared with
            neighbor at index i.
            </summary>
        </member>
        <member name="F:Mafi.Vornoi.VornoiCell.NeighborsPointIndices">
            <summary>
            Neighbors represented as point indices to their center point. The neighbors are in counterclockwise order. If
            <see cref="F:Mafi.Vornoi.VornoiCell.IsOnBoundary"/> is true, not all neighbors are valid cells.
            </summary>
        </member>
        <member name="F:Mafi.Vornoi.VornoiCell.IsOnBoundary">
            <summary>
            Whether this cell is on the boundary. This is true iff some neighbors are not valid cells.
            </summary>
        </member>
        <member name="M:Mafi.Vornoi.VornoiFromDelaunay.ComputeVornoi(Mafi.Collections.ReadonlyCollections.IIndexable{Mafi.Vector2i},Mafi.Collections.ReadonlyCollections.IIndexable{Mafi.Vornoi.DelaunayTriangle2i},System.Int32,Mafi.Collections.Lyst{Mafi.Vector2i}@)">
            <summary>
            Computes Vornoi diagram from given delaunay triangulation.
            </summary>
            <param name="points">Cell centers, vertices of delaunay triangulation.</param>
            <param name="delaunayTriangulation">Triangulation.</param>
            <param name="minEdgeLength">Minimum edge length of the vornoi diagram. Shorter edges will be collapsed to a single point.</param>
            <param name="vornoiPoints">Output list of Vornoi diagram vertices, referenced from <see cref="T:Mafi.Vornoi.VornoiCell"/>.</param>
            <returns>Resulting vornoi cells.</returns>
        </member>
    </members>
</doc>
